{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ReadMe","text":"Opulse <p>     Opulse is a dynamic operator generation system designed to create and manage mathematical operators, with 'pulse' reflecting its dynamic and impactful nature in the creation process!      Explore the docs \u00bb </p> Table of Contents <ol> <li> Getting Started <ul> <li>Installation</li> </ul> </li> <li>Usage</li> </ol>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#installation","title":"Installation","text":"<pre><code>git clone https://github.com/opulse-exp/Opulse.git\ncd ./Opulse\npip install -r requirement.txt\n</code></pre> <p>(back to top)</p>"},{"location":"#usage","title":"Usage","text":""},{"location":"#generate-operator","title":"generate operator","text":"<pre><code>python generate_operator.py \\\n  --config \"$CONFIG_PATH\" \\\n  --initial-operators-path \"$INITIAL_OPERATORS_PATH\" \\\n  --generated-operators-path \"$GENERATED_OPERATORS_PATH\" \\\n  --num \"$NUM_OPERATORS\"\n</code></pre>"},{"location":"#generate-expression","title":"generate expression","text":"<pre><code>python generate_expression.py \\\n    --config \"$CONFIG_PATH\" \\\n    --operators-path \"$OPERATORS_PATH\" \\\n    --generated-expression-path \"$GENERATED_EXPRESSION_PATH\" \\\n    --generated-opexpr-dependency-path \"$GENERATED_OPEXPRESS_DEPENDENCY_PATH\" \\\n    --num \"$NUM\" \\\n    --thread \"$THREADS\"\n</code></pre> <p>(back to top)</p>"},{"location":"Core%20API/expression/base_converter/","title":"Base converter","text":""},{"location":"Core%20API/expression/base_converter/#opulse.expression.base_converter.BaseConverter","title":"<code>BaseConverter</code>","text":"<p>Tool class that converts an integer to a string representation in the specified binary.</p> <p>Supports any base between 2 and 36, using numbers and letters as symbols. The conversion behavior can be customized by setting different configuration items.</p> Source code in <code>opulse/expression/base_converter.py</code> <pre><code>class BaseConverter:\n    \"\"\"\n    Tool class that converts an integer to a string representation in the specified binary.\n\n    Supports any base between 2 and 36, using numbers and letters as symbols.\n    The conversion behavior can be customized by setting different configuration items.\n    \"\"\"\n\n    # \u9ed8\u8ba4\u5b57\u7b26\u96c6\uff1a0-9, A-Z\n    DEFAULT_DIGITS = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\n    def __init__(self, max_base=10, digits: str = None):\n        \"\"\"\n        Initializes the BaseConverter instance.\n\n        Parameters:\n            max_base (int): target base, defaults to 10.\n            digits (str): the character set used to represent the value, defaults to the default character set.\n        \"\"\"\n        self.max_base = max_base\n        self.digits = digits if digits else self.DEFAULT_DIGITS[:max_base]\n\n    def convert(self, number: int, base: int) -&gt; str:\n        \"\"\"\n        Converts an integer to a string representation in the specified binary.\n\n        Parameters:\n            number (int): The integer to be converted.\n\n        Returns:\n            (str): The string representation in the specified hexadecimal system.\n        \"\"\"\n        if number == 0:\n            return f\"{self.digits[0]}\"\n\n        if number &lt; 0:\n            sign = \"-\"\n            number = -number\n        else:\n            sign = \"\"\n\n        result = \"\"\n        while number &gt; 0:\n            remainder = number % base\n            result = self.digits[remainder] + result\n            number = number // base\n\n        return f\"{sign}{result}\"\n\n    @staticmethod\n    def get_supported_bases():\n        \"\"\"\n        Return the supported base range\n\n        Returns:\n            (List[int]): The supported base range.\n        \"\"\"\n        return list(range(2, 37))\n</code></pre>"},{"location":"Core%20API/expression/base_converter/#opulse.expression.base_converter.BaseConverter.__init__","title":"<code>__init__(max_base=10, digits=None)</code>","text":"<p>Initializes the BaseConverter instance.</p> <p>Parameters:</p> Name Type Description Default <code>max_base</code> <code>int</code> <p>target base, defaults to 10.</p> <code>10</code> <code>digits</code> <code>str</code> <p>the character set used to represent the value, defaults to the default character set.</p> <code>None</code> Source code in <code>opulse/expression/base_converter.py</code> <pre><code>def __init__(self, max_base=10, digits: str = None):\n    \"\"\"\n    Initializes the BaseConverter instance.\n\n    Parameters:\n        max_base (int): target base, defaults to 10.\n        digits (str): the character set used to represent the value, defaults to the default character set.\n    \"\"\"\n    self.max_base = max_base\n    self.digits = digits if digits else self.DEFAULT_DIGITS[:max_base]\n</code></pre>"},{"location":"Core%20API/expression/base_converter/#opulse.expression.base_converter.BaseConverter.convert","title":"<code>convert(number, base)</code>","text":"<p>Converts an integer to a string representation in the specified binary.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int</code> <p>The integer to be converted.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The string representation in the specified hexadecimal system.</p> Source code in <code>opulse/expression/base_converter.py</code> <pre><code>def convert(self, number: int, base: int) -&gt; str:\n    \"\"\"\n    Converts an integer to a string representation in the specified binary.\n\n    Parameters:\n        number (int): The integer to be converted.\n\n    Returns:\n        (str): The string representation in the specified hexadecimal system.\n    \"\"\"\n    if number == 0:\n        return f\"{self.digits[0]}\"\n\n    if number &lt; 0:\n        sign = \"-\"\n        number = -number\n    else:\n        sign = \"\"\n\n    result = \"\"\n    while number &gt; 0:\n        remainder = number % base\n        result = self.digits[remainder] + result\n        number = number // base\n\n    return f\"{sign}{result}\"\n</code></pre>"},{"location":"Core%20API/expression/base_converter/#opulse.expression.base_converter.BaseConverter.get_supported_bases","title":"<code>get_supported_bases()</code>  <code>staticmethod</code>","text":"<p>Return the supported base range</p> <p>Returns:</p> Type Description <code>List[int]</code> <p>The supported base range.</p> Source code in <code>opulse/expression/base_converter.py</code> <pre><code>@staticmethod\ndef get_supported_bases():\n    \"\"\"\n    Return the supported base range\n\n    Returns:\n        (List[int]): The supported base range.\n    \"\"\"\n    return list(range(2, 37))\n</code></pre>"},{"location":"Core%20API/expression/expression_base_converter/","title":"Expression base converter","text":""},{"location":"Core%20API/expression/expression_base_converter/#opulse.expression.expression_base_converter.ExpressionBaseConverter","title":"<code>ExpressionBaseConverter</code>","text":"Source code in <code>opulse/expression/expression_base_converter.py</code> <pre><code>class ExpressionBaseConverter:\n    # def __init__(self, input_base: int = 10, output_base: int = 10):\n    #     \"\"\"\n    #     Initializes the ExpressionBaseConverter class and sets the base for input and output.\n\n    #     :param input_base: Enter the base of the expression, which defaults to decimal (10).\n    #     :param output_base: The base of the output expression, defaults to decimal (10).\n    #     \"\"\"\n    #     self.input_base = input_base\n    #     self.output_base = output_base\n    @staticmethod\n    def convert_expr_str_to_base(\n        expression: str, output_base: int, base_converter: BaseConverter\n    ) -&gt; str:\n        \"\"\"\n        Converts all decimal digits surrounded by $ in the expression to the target base and removes the $ sign.\n\n        This static method takes a mathematical expression string where numbers are marked with dollar signs ($),\n        converts those numbers from decimal to the specified target base, and returns a new string with the updated numbers.\n        The conversion is performed using the provided BaseConverter instance.\n\n        Args:\n            expression (str): The original math expression string containing numbers marked with $...$.\n            output_base (int): The target base to which the numbers should be converted.\n            base_converter (BaseConverter): An instance of BaseConverter used for converting between bases.\n\n        Returns:\n            str: A new math expression string with numbers converted to the target base and without the $ sign.\n\n        Example:\n            Given an expression \"$100$ + $25$\" and output_base 2,\n            the returned string would be \"1100100 + 11001\".\n        \"\"\"\n\n        def replacer(match):\n            decimal_str = match.group(1)\n            decimal_num = int(decimal_str)\n            converted_str = base_converter.convert(decimal_num, output_base)\n            return converted_str\n\n        # \u4f7f\u7528\u6b63\u5219\u8868\u8fbe\u5f0f\u66ff\u6362\u6240\u6709\u5339\u914d\u7684\u90e8\u5206\n        pattern = r\"\\$(\\d+)\\$\"\n        new_expression = re.sub(pattern, replacer, expression)\n        return new_expression\n</code></pre>"},{"location":"Core%20API/expression/expression_base_converter/#opulse.expression.expression_base_converter.ExpressionBaseConverter.convert_expr_str_to_base","title":"<code>convert_expr_str_to_base(expression, output_base, base_converter)</code>  <code>staticmethod</code>","text":"<p>Converts all decimal digits surrounded by $ in the expression to the target base and removes the $ sign.</p> <p>This static method takes a mathematical expression string where numbers are marked with dollar signs ($), converts those numbers from decimal to the specified target base, and returns a new string with the updated numbers. The conversion is performed using the provided BaseConverter instance.</p> <p>Parameters:</p> Name Type Description Default <code>expression</code> <code>str</code> <p>The original math expression string containing numbers marked with $...$.</p> required <code>output_base</code> <code>int</code> <p>The target base to which the numbers should be converted.</p> required <code>base_converter</code> <code>BaseConverter</code> <p>An instance of BaseConverter used for converting between bases.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A new math expression string with numbers converted to the target base and without the $ sign.</p> Example <p>Given an expression \"$100$ + $25$\" and output_base 2, the returned string would be \"1100100 + 11001\".</p> Source code in <code>opulse/expression/expression_base_converter.py</code> <pre><code>@staticmethod\ndef convert_expr_str_to_base(\n    expression: str, output_base: int, base_converter: BaseConverter\n) -&gt; str:\n    \"\"\"\n    Converts all decimal digits surrounded by $ in the expression to the target base and removes the $ sign.\n\n    This static method takes a mathematical expression string where numbers are marked with dollar signs ($),\n    converts those numbers from decimal to the specified target base, and returns a new string with the updated numbers.\n    The conversion is performed using the provided BaseConverter instance.\n\n    Args:\n        expression (str): The original math expression string containing numbers marked with $...$.\n        output_base (int): The target base to which the numbers should be converted.\n        base_converter (BaseConverter): An instance of BaseConverter used for converting between bases.\n\n    Returns:\n        str: A new math expression string with numbers converted to the target base and without the $ sign.\n\n    Example:\n        Given an expression \"$100$ + $25$\" and output_base 2,\n        the returned string would be \"1100100 + 11001\".\n    \"\"\"\n\n    def replacer(match):\n        decimal_str = match.group(1)\n        decimal_num = int(decimal_str)\n        converted_str = base_converter.convert(decimal_num, output_base)\n        return converted_str\n\n    # \u4f7f\u7528\u6b63\u5219\u8868\u8fbe\u5f0f\u66ff\u6362\u6240\u6709\u5339\u914d\u7684\u90e8\u5206\n    pattern = r\"\\$(\\d+)\\$\"\n    new_expression = re.sub(pattern, replacer, expression)\n    return new_expression\n</code></pre>"},{"location":"Core%20API/expression/expression_evaluator/","title":"Expression evaluator","text":""},{"location":"Core%20API/expression/expression_evaluator/#opulse.expression.expression_evaluator.ExpressionEvaluator","title":"<code>ExpressionEvaluator</code>","text":"Source code in <code>opulse/expression/expression_evaluator.py</code> <pre><code>class ExpressionEvaluator:\n\n    def __init__(\n        self,\n        param_config: ParamConfig,\n        logger: LogConfig,\n        operator_manager: OperatorManager,\n        base_converter: BaseConverter = None,\n    ):\n        \"\"\"\n        Initializes an instance of the ExpressionEvaluator class.\n\n        This constructor sets up the expression evaluator with necessary configurations and managers.\n        It initializes attributes to manage expression trees, operators, logging, and base conversions.\n        Additionally, it prepares data structures to track operator priorities, operation counts, and highest n-order values.\n\n        Parameters:\n            param_config (ParamConfig): Configuration settings for controlling the behavior of the expression evaluator.\n            logger (LogConfig): Configuration for setting up logging. Used to create a logger instance for this evaluator.\n            operator_manager (OperatorManager): Manager object that provides information about operators used in expressions.\n            base_converter (BaseConverter, optional): Converter object for handling different numerical bases in expressions. Defaults to None.\n        \"\"\"\n        self.param_config = param_config\n        self.logger = logger.get_logger()\n        # Initialization of relevant expressions to None\n        self.id = None\n        self.expression_tree: ExpressionNode = None\n        self.expression_str: str = None\n        self.operator_manager = operator_manager\n        self.base_converter = base_converter\n        self.all_priority = []\n        self.operation_count = 0\n        self.highest_n_order = 0\n        # Record all operators key: op id, value: number of occurrences\n        self.all_operators: Dict[int, int] = defaultdict(int)\n        self.with_all_brackets = False\n\n        # Used to replace meta words in expression strings\n        self.load_atoms()\n\n    def set_with_all_brackets(self, with_all_brackets: bool) -&gt; None:\n        \"\"\"\n        Sets whether to include all brackets in the expression string.\n\n        This method configures the behavior for generating expression strings. If set to True, it ensures that all parts of the \n        expression that require parentheses for correct order of operations will be enclosed in brackets. This can be useful \n        for ensuring clarity or for specific formatting requirements.\n\n        Parameters:\n            with_all_brackets (bool): A flag indicating whether to include all necessary brackets in the expression string.\n        \"\"\"\n        self.with_all_brackets = with_all_brackets\n\n    def load_atoms(self) -&gt; None:\n        \"\"\"\n        Loads atomic symbols from the parameter configuration.\n        \"\"\"\n        self.atoms = {\n            \"left_bracket\": self.param_config.get(\"other_symbols_atoms\")[\n                \"left_parenthesis\"\n            ],\n            \"right_bracket\": self.param_config.get(\"other_symbols_atoms\")[\n                \"right_parenthesis\"\n            ],\n            \"NaN\": self.param_config.get(\"other_symbols_atoms\")[\"nan_symbol\"],\n            \"equal\": self.param_config.get(\"other_symbols_atoms\")[\"equals_sign\"],\n        }\n\n    def init_expr(self, expression_tree, id, op_mode: bool = False):\n        \"\"\"\n        Initializes expression attributes with an expression tree and ID.\n\n        This method sets up the initial state for an expression by assigning an identifier and an expression tree.\n        It also initializes counters and dictionaries that will be used to track various properties of the expression,\n        such as operator priorities, operation counts, and operator occurrences. Finally, it generates string representations \n        of the expression based on the provided tree structure and optional parameters.\n\n        Parameters:\n            expression_tree (ExpressionNode): The root node of the expression tree to initialize.\n            id (any): An identifier for the expression, which can be any type that uniquely identifies the expression.\n            op_mode (bool, optional): A flag indicating whether the expression should be processed in operator mode. Defaults to False.\n        \"\"\"\n        self.id = id\n        self.expression_tree = expression_tree\n        self.all_priority = []\n        self.operation_count = 0\n        self.highest_n_order = 0\n        self.all_operators: Dict[int, int] = defaultdict(int)\n        if op_mode:\n            self.expression_str = self.tree_to_str(self.expression_tree, op_mode=True)\n        else:\n            self.expression_str = self.tree_to_str(self.expression_tree)\n            self.expression_str_no_base_symbol = self.tree_to_str(\n                self.expression_tree, with_base_symbol=False\n            )\n\n    def tree_to_str(\n        self,\n        node: ExpressionNode,\n        parent_op: OperatorInfo = None,\n        with_base_symbol: bool = True,\n        op_mode: bool = False,\n    ) -&gt; str:\n        \"\"\"\n        Converts an expression tree node to a string representation.\n\n        This method recursively traverses the expression tree and builds a string representation based on the node type.\n        For binary and unary expression nodes, it checks the operator priority relative to the parent node's operator priority\n        to determine if parentheses are needed to preserve correct order of operations.\n        For number and variable nodes, it returns their direct string representations.\n\n        Parameters:\n            node (ExpressionNode): The expression node to convert.\n            parent_op (OperatorInfo, optional): Information about the parent operator, used to determine if parentheses are needed. Defaults to None.\n            with_base_symbol (bool, optional): Whether to include base symbols in the string. Defaults to True.\n            op_mode (bool, optional): A flag indicating operator mode. Defaults to False.\n\n        Returns:\n            str: String representation of the expression node.\n\n        Raises:\n            NotImplementedError: If an unsupported expression node type is encountered.\n        \"\"\"\n        # Requires the priority of the parent node's operator for determining whether to add brackets\n        if isinstance(node, NumberNode):\n            node = cast(NumberNode, node)\n            if op_mode:\n                return f\"{node.to_str_no_base_symbol(op_mode=True)}\"\n            else:\n                if with_base_symbol:\n                    return f\"{node.to_str(self.operator_manager,self.base_converter)}\"\n                else:\n                    return f\"{node.to_str_no_base_symbol()}\"\n        elif isinstance(node, VariableNode):\n            return f\"{node.v}\"\n        elif isinstance(node, BinaryExpressionNode):\n            node = cast(BinaryExpressionNode, node)\n            # Statistical priority for calculating calculate_priority_hierarchical_complexity\n            if (\n                node.operator.priority != None\n                and node.operator.priority not in self.all_priority\n            ):\n                self.all_priority.append(node.operator.priority)\n            # Count the number of operations and associate the expression with the operator\n            self.operation_count += 1\n            self.all_operators[node.operator.id] += 1\n            # Count the n_order info\n            if self.highest_n_order &lt; node.operator.n_order:\n                self.highest_n_order = node.operator.n_order\n            # Convert the expression of the subtree\n            left_str = self.tree_to_str(\n                node.left_expr,\n                node.operator,\n                with_base_symbol=with_base_symbol,\n                op_mode=op_mode,\n            )\n            right_str = self.tree_to_str(\n                node.right_expr,\n                node.operator,\n                with_base_symbol=with_base_symbol,\n                op_mode=op_mode,\n            )\n\n            if self.with_all_brackets:\n                return f\"{self.atoms['left_bracket']}{left_str}{node.operator.symbol}{right_str}{self.atoms['right_bracket']}\"\n            # self.logger.debug(f\"parent_op: {parent_op}\")\n            if parent_op != None and node.operator.priority &lt; parent_op.priority:\n                return f\"{self.atoms['left_bracket']}{left_str}{node.operator.symbol}{right_str}{self.atoms['right_bracket']}\"\n            elif parent_op != None and node.operator.priority == parent_op.priority:\n                # If it has the same priority as parent op, choose whether to add parentheses or not based on location and binding.\n                if (\n                    parent_op.associativity_direction == \"left\"\n                    and node.position == \"right\"\n                ):\n                    return f\"{self.atoms['left_bracket']}{left_str}{node.operator.symbol}{right_str}{self.atoms['right_bracket']}\"\n                elif (\n                    parent_op.associativity_direction == \"right\"\n                    and node.position == \"left\"\n                ):\n                    return f\"{self.atoms['left_bracket']}{left_str}{node.operator.symbol}{right_str}{self.atoms['right_bracket']}\"\n                else:\n                    return f\"{left_str}{node.operator.symbol}{right_str}\"\n            else:\n                return f\"{left_str}{node.operator.symbol}{right_str}\"\n        elif isinstance(node, UnaryExpressionNode):\n            node = cast(UnaryExpressionNode, node)\n            # Statistical priority for calculating calculate_priority_hierarchical_complexity\n            if (\n                node.operator.priority != None\n                and node.operator.priority not in self.all_priority\n            ):\n                self.all_priority.append(node.operator.priority)\n            # Count the number of operations and associate the expression with the operator\n            self.operation_count += 1\n            self.all_operators[node.operator.id] += 1\n            # Count the n_order info\n            if self.highest_n_order &lt; node.operator.n_order:\n                self.highest_n_order = node.operator.n_order\n            unary_str = self.tree_to_str(\n                node.unary_expr,\n                node.operator,\n                with_base_symbol=with_base_symbol,\n                op_mode=op_mode,\n            )\n            # Doubt: Always choose to add brackets to unary\n            return f\"({node.operator.symbol}{unary_str})\"\n        else:\n            raise NotImplementedError(\"ExpressionEvaluator.tree_to_str\")\n\n    def calculate_highest_n_order(self) -&gt; int:\n        \"\"\"\n        Calculates the highest n-order of the expression.\n\n        Returns: \n            (int): The highest n-order value.\n        \"\"\"\n        return self.highest_n_order\n\n    def calculate_priority_hierarchical_complexity(self) -&gt; int:\n        \"\"\"\n        Calculates the priority-based hierarchical complexity.\n\n        Returns: \n            (int): The complexity value.\n        \"\"\"\n        return len(self.all_priority)\n\n    def calculate_normalized_expansion_degree(self) -&gt; Union[int, str]:\n        # Implementing the computational logic for normalized expansion degree\n        \"\"\"\n        Calculates the normalized expansion degree of the expression.\n\n        Returns: \n            (int): The normalized expansion degree or \"NaN\".\n        \"\"\"\n        # return \"NaN\"\n        if hasattr(self, \"normalized_expansion_degree\"):\n            return (\n                self.normalized_expansion_degree\n                if self.normalized_expansion_degree != \"NaN\"\n                else self.atoms[\"NaN\"]\n            )\n        else:\n            degree, result = self.calculate_normalized_expansion_degree_node(\n                self.expression_tree\n            )\n            self.normalized_expansion_degree = degree\n            self.expr_result = result\n            return (\n                self.normalized_expansion_degree\n                if self.normalized_expansion_degree != \"NaN\"\n                else self.atoms[\"NaN\"]\n            )\n\n    def calculate_result(self) -&gt; Union[int, str]:\n        \"\"\"\n        Calculates the normalized expansion degree of the expression.\n\n        The normalized expansion degree is a measure that represents how much an expression has been expanded or simplified.\n        It can be used to evaluate the complexity of the expression in terms of its structure and size after operations.\n\n        Returns: \n            (Union[int, str]): The normalized expansion degree or \"NaN\".s an integer or \"NaN\" if it cannot be calculated.\n        \"\"\"\n        # return \"NaN\"\n        if hasattr(self, \"expr_result\"):\n            return self.expr_result if self.expr_result != \"NaN\" else self.atoms[\"NaN\"]\n        else:\n            degree, result = self.calculate_normalized_expansion_degree_node(\n                self.expression_tree\n            )\n            self.normalized_expansion_degree = degree\n            self.expr_result = result\n            return self.expr_result if self.expr_result != \"NaN\" else self.atoms[\"NaN\"]\n\n    def calculate_normalized_expansion_degree_node(\n        self, node: ExpressionNode\n    ) -&gt; Tuple[Union[int, str], Union[int, str]]:\n        \"\"\"\n        Helper method to recursively calculate the normalized expansion degree for each node in the expression tree.\n\n        This method traverses the expression tree and computes the degree based on the type and structure of nodes.\n\n        Args:\n            node (ExpressionNode): The current node in the expression tree.\n\n        Returns: \n            (Tuple[Union[int, str], Union[int, str]]): A tuple containing the normalized expansion degree and the evaluation result of the node.\n\n        Raises:\n            NotImplementedError: If the node type is not recognized.\n\n        \"\"\"\n        # For a single expression tree node, compute the normalized expansion of the tree rooted at this node and the resultant\n        if isinstance(node, NumberNode):\n            return 0, node.value\n        elif isinstance(node, UnaryExpressionNode):\n            sub_degree, sub_result = self.calculate_normalized_expansion_degree_node(\n                node.unary_expr\n            )\n            if sub_degree == \"NaN\" or sub_result == \"NaN\":\n                return \"NaN\", \"NaN\"\n            cur_result = node.operator.get_compute_function()(sub_result)\n            cur_degree = node.operator.get_count_function()(sub_result)\n            return cur_degree + sub_degree, cur_result\n        elif isinstance(node, BinaryExpressionNode):\n            # \u4e8c\u5143\u64cd\u4f5c\u7b26\uff0c\u5206\u522b\u8ba1\u7b97\u5de6\u53f3\u5b50\u6811\u7684\u5f52\u4e00\u5c55\u5f00\u5ea6\n            left_degree, left_result = self.calculate_normalized_expansion_degree_node(\n                node.left_expr\n            )\n            if left_degree == \"NaN\" or left_result == \"NaN\":\n                return \"NaN\", \"NaN\"\n            right_degree, right_result = (\n                self.calculate_normalized_expansion_degree_node(node.right_expr)\n            )\n            if right_degree == \"NaN\" or right_result == \"NaN\":\n                return \"NaN\", \"NaN\"\n            cur_result = node.operator.get_compute_function()(left_result, right_result)\n            cur_degree = node.operator.get_count_function()(left_result, right_result)\n            if cur_degree == \"NaN\" or cur_result == \"NaN\":\n                return \"NaN\", \"NaN\"\n            return cur_degree + left_degree + right_degree, cur_result\n        elif isinstance(node, VariableNode):\n            return \"NaN\", \"NaN\"\n        else:\n            raise NotImplementedError(\n                \"ExpressionEvaluator.calculate_normalized_expansion_degree_node\"\n            )\n\n    def calculate_operation_count(self):\n        \"\"\"\n        Calculates the total number of operations in the expression.\n\n        This method returns the count of all operations that were encountered during the construction of the expression tree.\n\n        Returns: \n            (int): The operation count as an integer.\n        \"\"\"\n        # \u5b9e\u73b0\u8fd0\u7b97\u6b21\u6570\u7684\u8ba1\u7b97\u903b\u8f91\n        return self.operation_count\n\n    def calculate_complexity_ratio(self):\n        \"\"\"\n        Calculates the complexity ratio based on normalized expansion degree and operation count.\n\n        The complexity ratio provides a measure of how complex the expression is relative to the number of operations it contains.\n        It is calculated by dividing the normalized expansion degree by the operation count.\n\n        Returns: \n            (int): The complexity ratio as a floating-point number. Returns 0 if the operation count is 0 or the expansion degree is \"NaN\".\n        \"\"\"\n        operation_count = self.calculate_operation_count()\n        normalized_expansion_degree = self.calculate_normalized_expansion_degree()\n        return (\n            normalized_expansion_degree / operation_count\n            if operation_count &gt; 0 and normalized_expansion_degree != \"NaN\"\n            else 0\n        )\n\n    def calculate_max_digit_count(self):\n        \"\"\"\n        Calculates the maximum digit count in the expression string.\n\n        This method extracts all numbers from the expression string, converts them to integers, and determines the length of the largest number.\n\n        Returns: \n            (int): The maximum digit count as an integer. Returns 0 if there are no digits in the expression string.\n        \"\"\"\n        numbers = [int(num) for num in self.expression_str.split() if num.isdigit()]\n        return max((len(str(num)) for num in numbers), default=0)\n\n    def evaluate(self):\n        \"\"\"\n        Evaluates the expression and returns its properties.\n\n        This method aggregates various metrics about the expression, such as its highest n-order, hierarchical complexity,\n        normalized expansion degree, operation count, complexity ratio, maximum digit count, and result.\n\n        Returns: \n            (dict): A dictionary containing various properties of the evaluated expression.\n        \"\"\"\n        return {\n            \"id\": self.id,\n            \"expression_no_base_symbol\": self.expression_str_no_base_symbol,\n            \"expression\": self.expression_str,\n            \"highest_n_order\": self.calculate_highest_n_order(),\n            \"priority_hierarchical_complexity\": self.calculate_priority_hierarchical_complexity(),\n            \"normalized_expansion_degree\": self.calculate_normalized_expansion_degree(),\n            \"operation_count\": self.calculate_operation_count(),\n            \"complexity_ratio\": self.calculate_complexity_ratio(),\n            \"max_digit_count\": self.calculate_max_digit_count(),\n            \"tree\": self.expression_tree.to_dict(),\n            \"used_operators\": list(self.all_operators.keys()),\n            \"result\": self.calculate_result(),\n        }\n</code></pre>"},{"location":"Core%20API/expression/expression_evaluator/#opulse.expression.expression_evaluator.ExpressionEvaluator.__init__","title":"<code>__init__(param_config, logger, operator_manager, base_converter=None)</code>","text":"<p>Initializes an instance of the ExpressionEvaluator class.</p> <p>This constructor sets up the expression evaluator with necessary configurations and managers. It initializes attributes to manage expression trees, operators, logging, and base conversions. Additionally, it prepares data structures to track operator priorities, operation counts, and highest n-order values.</p> <p>Parameters:</p> Name Type Description Default <code>param_config</code> <code>ParamConfig</code> <p>Configuration settings for controlling the behavior of the expression evaluator.</p> required <code>logger</code> <code>LogConfig</code> <p>Configuration for setting up logging. Used to create a logger instance for this evaluator.</p> required <code>operator_manager</code> <code>OperatorManager</code> <p>Manager object that provides information about operators used in expressions.</p> required <code>base_converter</code> <code>BaseConverter</code> <p>Converter object for handling different numerical bases in expressions. Defaults to None.</p> <code>None</code> Source code in <code>opulse/expression/expression_evaluator.py</code> <pre><code>def __init__(\n    self,\n    param_config: ParamConfig,\n    logger: LogConfig,\n    operator_manager: OperatorManager,\n    base_converter: BaseConverter = None,\n):\n    \"\"\"\n    Initializes an instance of the ExpressionEvaluator class.\n\n    This constructor sets up the expression evaluator with necessary configurations and managers.\n    It initializes attributes to manage expression trees, operators, logging, and base conversions.\n    Additionally, it prepares data structures to track operator priorities, operation counts, and highest n-order values.\n\n    Parameters:\n        param_config (ParamConfig): Configuration settings for controlling the behavior of the expression evaluator.\n        logger (LogConfig): Configuration for setting up logging. Used to create a logger instance for this evaluator.\n        operator_manager (OperatorManager): Manager object that provides information about operators used in expressions.\n        base_converter (BaseConverter, optional): Converter object for handling different numerical bases in expressions. Defaults to None.\n    \"\"\"\n    self.param_config = param_config\n    self.logger = logger.get_logger()\n    # Initialization of relevant expressions to None\n    self.id = None\n    self.expression_tree: ExpressionNode = None\n    self.expression_str: str = None\n    self.operator_manager = operator_manager\n    self.base_converter = base_converter\n    self.all_priority = []\n    self.operation_count = 0\n    self.highest_n_order = 0\n    # Record all operators key: op id, value: number of occurrences\n    self.all_operators: Dict[int, int] = defaultdict(int)\n    self.with_all_brackets = False\n\n    # Used to replace meta words in expression strings\n    self.load_atoms()\n</code></pre>"},{"location":"Core%20API/expression/expression_evaluator/#opulse.expression.expression_evaluator.ExpressionEvaluator.calculate_complexity_ratio","title":"<code>calculate_complexity_ratio()</code>","text":"<p>Calculates the complexity ratio based on normalized expansion degree and operation count.</p> <p>The complexity ratio provides a measure of how complex the expression is relative to the number of operations it contains. It is calculated by dividing the normalized expansion degree by the operation count.</p> <p>Returns:</p> Type Description <code>int</code> <p>The complexity ratio as a floating-point number. Returns 0 if the operation count is 0 or the expansion degree is \"NaN\".</p> Source code in <code>opulse/expression/expression_evaluator.py</code> <pre><code>def calculate_complexity_ratio(self):\n    \"\"\"\n    Calculates the complexity ratio based on normalized expansion degree and operation count.\n\n    The complexity ratio provides a measure of how complex the expression is relative to the number of operations it contains.\n    It is calculated by dividing the normalized expansion degree by the operation count.\n\n    Returns: \n        (int): The complexity ratio as a floating-point number. Returns 0 if the operation count is 0 or the expansion degree is \"NaN\".\n    \"\"\"\n    operation_count = self.calculate_operation_count()\n    normalized_expansion_degree = self.calculate_normalized_expansion_degree()\n    return (\n        normalized_expansion_degree / operation_count\n        if operation_count &gt; 0 and normalized_expansion_degree != \"NaN\"\n        else 0\n    )\n</code></pre>"},{"location":"Core%20API/expression/expression_evaluator/#opulse.expression.expression_evaluator.ExpressionEvaluator.calculate_highest_n_order","title":"<code>calculate_highest_n_order()</code>","text":"<p>Calculates the highest n-order of the expression.</p> <p>Returns:</p> Type Description <code>int</code> <p>The highest n-order value.</p> Source code in <code>opulse/expression/expression_evaluator.py</code> <pre><code>def calculate_highest_n_order(self) -&gt; int:\n    \"\"\"\n    Calculates the highest n-order of the expression.\n\n    Returns: \n        (int): The highest n-order value.\n    \"\"\"\n    return self.highest_n_order\n</code></pre>"},{"location":"Core%20API/expression/expression_evaluator/#opulse.expression.expression_evaluator.ExpressionEvaluator.calculate_max_digit_count","title":"<code>calculate_max_digit_count()</code>","text":"<p>Calculates the maximum digit count in the expression string.</p> <p>This method extracts all numbers from the expression string, converts them to integers, and determines the length of the largest number.</p> <p>Returns:</p> Type Description <code>int</code> <p>The maximum digit count as an integer. Returns 0 if there are no digits in the expression string.</p> Source code in <code>opulse/expression/expression_evaluator.py</code> <pre><code>def calculate_max_digit_count(self):\n    \"\"\"\n    Calculates the maximum digit count in the expression string.\n\n    This method extracts all numbers from the expression string, converts them to integers, and determines the length of the largest number.\n\n    Returns: \n        (int): The maximum digit count as an integer. Returns 0 if there are no digits in the expression string.\n    \"\"\"\n    numbers = [int(num) for num in self.expression_str.split() if num.isdigit()]\n    return max((len(str(num)) for num in numbers), default=0)\n</code></pre>"},{"location":"Core%20API/expression/expression_evaluator/#opulse.expression.expression_evaluator.ExpressionEvaluator.calculate_normalized_expansion_degree","title":"<code>calculate_normalized_expansion_degree()</code>","text":"<p>Calculates the normalized expansion degree of the expression.</p> <p>Returns:</p> Type Description <code>int</code> <p>The normalized expansion degree or \"NaN\".</p> Source code in <code>opulse/expression/expression_evaluator.py</code> <pre><code>def calculate_normalized_expansion_degree(self) -&gt; Union[int, str]:\n    # Implementing the computational logic for normalized expansion degree\n    \"\"\"\n    Calculates the normalized expansion degree of the expression.\n\n    Returns: \n        (int): The normalized expansion degree or \"NaN\".\n    \"\"\"\n    # return \"NaN\"\n    if hasattr(self, \"normalized_expansion_degree\"):\n        return (\n            self.normalized_expansion_degree\n            if self.normalized_expansion_degree != \"NaN\"\n            else self.atoms[\"NaN\"]\n        )\n    else:\n        degree, result = self.calculate_normalized_expansion_degree_node(\n            self.expression_tree\n        )\n        self.normalized_expansion_degree = degree\n        self.expr_result = result\n        return (\n            self.normalized_expansion_degree\n            if self.normalized_expansion_degree != \"NaN\"\n            else self.atoms[\"NaN\"]\n        )\n</code></pre>"},{"location":"Core%20API/expression/expression_evaluator/#opulse.expression.expression_evaluator.ExpressionEvaluator.calculate_normalized_expansion_degree_node","title":"<code>calculate_normalized_expansion_degree_node(node)</code>","text":"<p>Helper method to recursively calculate the normalized expansion degree for each node in the expression tree.</p> <p>This method traverses the expression tree and computes the degree based on the type and structure of nodes.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>ExpressionNode</code> <p>The current node in the expression tree.</p> required <p>Returns:</p> Type Description <code>Tuple[Union[int, str], Union[int, str]]</code> <p>A tuple containing the normalized expansion degree and the evaluation result of the node.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the node type is not recognized.</p> Source code in <code>opulse/expression/expression_evaluator.py</code> <pre><code>def calculate_normalized_expansion_degree_node(\n    self, node: ExpressionNode\n) -&gt; Tuple[Union[int, str], Union[int, str]]:\n    \"\"\"\n    Helper method to recursively calculate the normalized expansion degree for each node in the expression tree.\n\n    This method traverses the expression tree and computes the degree based on the type and structure of nodes.\n\n    Args:\n        node (ExpressionNode): The current node in the expression tree.\n\n    Returns: \n        (Tuple[Union[int, str], Union[int, str]]): A tuple containing the normalized expansion degree and the evaluation result of the node.\n\n    Raises:\n        NotImplementedError: If the node type is not recognized.\n\n    \"\"\"\n    # For a single expression tree node, compute the normalized expansion of the tree rooted at this node and the resultant\n    if isinstance(node, NumberNode):\n        return 0, node.value\n    elif isinstance(node, UnaryExpressionNode):\n        sub_degree, sub_result = self.calculate_normalized_expansion_degree_node(\n            node.unary_expr\n        )\n        if sub_degree == \"NaN\" or sub_result == \"NaN\":\n            return \"NaN\", \"NaN\"\n        cur_result = node.operator.get_compute_function()(sub_result)\n        cur_degree = node.operator.get_count_function()(sub_result)\n        return cur_degree + sub_degree, cur_result\n    elif isinstance(node, BinaryExpressionNode):\n        # \u4e8c\u5143\u64cd\u4f5c\u7b26\uff0c\u5206\u522b\u8ba1\u7b97\u5de6\u53f3\u5b50\u6811\u7684\u5f52\u4e00\u5c55\u5f00\u5ea6\n        left_degree, left_result = self.calculate_normalized_expansion_degree_node(\n            node.left_expr\n        )\n        if left_degree == \"NaN\" or left_result == \"NaN\":\n            return \"NaN\", \"NaN\"\n        right_degree, right_result = (\n            self.calculate_normalized_expansion_degree_node(node.right_expr)\n        )\n        if right_degree == \"NaN\" or right_result == \"NaN\":\n            return \"NaN\", \"NaN\"\n        cur_result = node.operator.get_compute_function()(left_result, right_result)\n        cur_degree = node.operator.get_count_function()(left_result, right_result)\n        if cur_degree == \"NaN\" or cur_result == \"NaN\":\n            return \"NaN\", \"NaN\"\n        return cur_degree + left_degree + right_degree, cur_result\n    elif isinstance(node, VariableNode):\n        return \"NaN\", \"NaN\"\n    else:\n        raise NotImplementedError(\n            \"ExpressionEvaluator.calculate_normalized_expansion_degree_node\"\n        )\n</code></pre>"},{"location":"Core%20API/expression/expression_evaluator/#opulse.expression.expression_evaluator.ExpressionEvaluator.calculate_operation_count","title":"<code>calculate_operation_count()</code>","text":"<p>Calculates the total number of operations in the expression.</p> <p>This method returns the count of all operations that were encountered during the construction of the expression tree.</p> <p>Returns:</p> Type Description <code>int</code> <p>The operation count as an integer.</p> Source code in <code>opulse/expression/expression_evaluator.py</code> <pre><code>def calculate_operation_count(self):\n    \"\"\"\n    Calculates the total number of operations in the expression.\n\n    This method returns the count of all operations that were encountered during the construction of the expression tree.\n\n    Returns: \n        (int): The operation count as an integer.\n    \"\"\"\n    # \u5b9e\u73b0\u8fd0\u7b97\u6b21\u6570\u7684\u8ba1\u7b97\u903b\u8f91\n    return self.operation_count\n</code></pre>"},{"location":"Core%20API/expression/expression_evaluator/#opulse.expression.expression_evaluator.ExpressionEvaluator.calculate_priority_hierarchical_complexity","title":"<code>calculate_priority_hierarchical_complexity()</code>","text":"<p>Calculates the priority-based hierarchical complexity.</p> <p>Returns:</p> Type Description <code>int</code> <p>The complexity value.</p> Source code in <code>opulse/expression/expression_evaluator.py</code> <pre><code>def calculate_priority_hierarchical_complexity(self) -&gt; int:\n    \"\"\"\n    Calculates the priority-based hierarchical complexity.\n\n    Returns: \n        (int): The complexity value.\n    \"\"\"\n    return len(self.all_priority)\n</code></pre>"},{"location":"Core%20API/expression/expression_evaluator/#opulse.expression.expression_evaluator.ExpressionEvaluator.calculate_result","title":"<code>calculate_result()</code>","text":"<p>Calculates the normalized expansion degree of the expression.</p> <p>The normalized expansion degree is a measure that represents how much an expression has been expanded or simplified. It can be used to evaluate the complexity of the expression in terms of its structure and size after operations.</p> <p>Returns:</p> Type Description <code>Union[int, str]</code> <p>The normalized expansion degree or \"NaN\".s an integer or \"NaN\" if it cannot be calculated.</p> Source code in <code>opulse/expression/expression_evaluator.py</code> <pre><code>def calculate_result(self) -&gt; Union[int, str]:\n    \"\"\"\n    Calculates the normalized expansion degree of the expression.\n\n    The normalized expansion degree is a measure that represents how much an expression has been expanded or simplified.\n    It can be used to evaluate the complexity of the expression in terms of its structure and size after operations.\n\n    Returns: \n        (Union[int, str]): The normalized expansion degree or \"NaN\".s an integer or \"NaN\" if it cannot be calculated.\n    \"\"\"\n    # return \"NaN\"\n    if hasattr(self, \"expr_result\"):\n        return self.expr_result if self.expr_result != \"NaN\" else self.atoms[\"NaN\"]\n    else:\n        degree, result = self.calculate_normalized_expansion_degree_node(\n            self.expression_tree\n        )\n        self.normalized_expansion_degree = degree\n        self.expr_result = result\n        return self.expr_result if self.expr_result != \"NaN\" else self.atoms[\"NaN\"]\n</code></pre>"},{"location":"Core%20API/expression/expression_evaluator/#opulse.expression.expression_evaluator.ExpressionEvaluator.evaluate","title":"<code>evaluate()</code>","text":"<p>Evaluates the expression and returns its properties.</p> <p>This method aggregates various metrics about the expression, such as its highest n-order, hierarchical complexity, normalized expansion degree, operation count, complexity ratio, maximum digit count, and result.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing various properties of the evaluated expression.</p> Source code in <code>opulse/expression/expression_evaluator.py</code> <pre><code>def evaluate(self):\n    \"\"\"\n    Evaluates the expression and returns its properties.\n\n    This method aggregates various metrics about the expression, such as its highest n-order, hierarchical complexity,\n    normalized expansion degree, operation count, complexity ratio, maximum digit count, and result.\n\n    Returns: \n        (dict): A dictionary containing various properties of the evaluated expression.\n    \"\"\"\n    return {\n        \"id\": self.id,\n        \"expression_no_base_symbol\": self.expression_str_no_base_symbol,\n        \"expression\": self.expression_str,\n        \"highest_n_order\": self.calculate_highest_n_order(),\n        \"priority_hierarchical_complexity\": self.calculate_priority_hierarchical_complexity(),\n        \"normalized_expansion_degree\": self.calculate_normalized_expansion_degree(),\n        \"operation_count\": self.calculate_operation_count(),\n        \"complexity_ratio\": self.calculate_complexity_ratio(),\n        \"max_digit_count\": self.calculate_max_digit_count(),\n        \"tree\": self.expression_tree.to_dict(),\n        \"used_operators\": list(self.all_operators.keys()),\n        \"result\": self.calculate_result(),\n    }\n</code></pre>"},{"location":"Core%20API/expression/expression_evaluator/#opulse.expression.expression_evaluator.ExpressionEvaluator.init_expr","title":"<code>init_expr(expression_tree, id, op_mode=False)</code>","text":"<p>Initializes expression attributes with an expression tree and ID.</p> <p>This method sets up the initial state for an expression by assigning an identifier and an expression tree. It also initializes counters and dictionaries that will be used to track various properties of the expression, such as operator priorities, operation counts, and operator occurrences. Finally, it generates string representations  of the expression based on the provided tree structure and optional parameters.</p> <p>Parameters:</p> Name Type Description Default <code>expression_tree</code> <code>ExpressionNode</code> <p>The root node of the expression tree to initialize.</p> required <code>id</code> <code>any</code> <p>An identifier for the expression, which can be any type that uniquely identifies the expression.</p> required <code>op_mode</code> <code>bool</code> <p>A flag indicating whether the expression should be processed in operator mode. Defaults to False.</p> <code>False</code> Source code in <code>opulse/expression/expression_evaluator.py</code> <pre><code>def init_expr(self, expression_tree, id, op_mode: bool = False):\n    \"\"\"\n    Initializes expression attributes with an expression tree and ID.\n\n    This method sets up the initial state for an expression by assigning an identifier and an expression tree.\n    It also initializes counters and dictionaries that will be used to track various properties of the expression,\n    such as operator priorities, operation counts, and operator occurrences. Finally, it generates string representations \n    of the expression based on the provided tree structure and optional parameters.\n\n    Parameters:\n        expression_tree (ExpressionNode): The root node of the expression tree to initialize.\n        id (any): An identifier for the expression, which can be any type that uniquely identifies the expression.\n        op_mode (bool, optional): A flag indicating whether the expression should be processed in operator mode. Defaults to False.\n    \"\"\"\n    self.id = id\n    self.expression_tree = expression_tree\n    self.all_priority = []\n    self.operation_count = 0\n    self.highest_n_order = 0\n    self.all_operators: Dict[int, int] = defaultdict(int)\n    if op_mode:\n        self.expression_str = self.tree_to_str(self.expression_tree, op_mode=True)\n    else:\n        self.expression_str = self.tree_to_str(self.expression_tree)\n        self.expression_str_no_base_symbol = self.tree_to_str(\n            self.expression_tree, with_base_symbol=False\n        )\n</code></pre>"},{"location":"Core%20API/expression/expression_evaluator/#opulse.expression.expression_evaluator.ExpressionEvaluator.load_atoms","title":"<code>load_atoms()</code>","text":"<p>Loads atomic symbols from the parameter configuration.</p> Source code in <code>opulse/expression/expression_evaluator.py</code> <pre><code>def load_atoms(self) -&gt; None:\n    \"\"\"\n    Loads atomic symbols from the parameter configuration.\n    \"\"\"\n    self.atoms = {\n        \"left_bracket\": self.param_config.get(\"other_symbols_atoms\")[\n            \"left_parenthesis\"\n        ],\n        \"right_bracket\": self.param_config.get(\"other_symbols_atoms\")[\n            \"right_parenthesis\"\n        ],\n        \"NaN\": self.param_config.get(\"other_symbols_atoms\")[\"nan_symbol\"],\n        \"equal\": self.param_config.get(\"other_symbols_atoms\")[\"equals_sign\"],\n    }\n</code></pre>"},{"location":"Core%20API/expression/expression_evaluator/#opulse.expression.expression_evaluator.ExpressionEvaluator.set_with_all_brackets","title":"<code>set_with_all_brackets(with_all_brackets)</code>","text":"<p>Sets whether to include all brackets in the expression string.</p> <p>This method configures the behavior for generating expression strings. If set to True, it ensures that all parts of the  expression that require parentheses for correct order of operations will be enclosed in brackets. This can be useful  for ensuring clarity or for specific formatting requirements.</p> <p>Parameters:</p> Name Type Description Default <code>with_all_brackets</code> <code>bool</code> <p>A flag indicating whether to include all necessary brackets in the expression string.</p> required Source code in <code>opulse/expression/expression_evaluator.py</code> <pre><code>def set_with_all_brackets(self, with_all_brackets: bool) -&gt; None:\n    \"\"\"\n    Sets whether to include all brackets in the expression string.\n\n    This method configures the behavior for generating expression strings. If set to True, it ensures that all parts of the \n    expression that require parentheses for correct order of operations will be enclosed in brackets. This can be useful \n    for ensuring clarity or for specific formatting requirements.\n\n    Parameters:\n        with_all_brackets (bool): A flag indicating whether to include all necessary brackets in the expression string.\n    \"\"\"\n    self.with_all_brackets = with_all_brackets\n</code></pre>"},{"location":"Core%20API/expression/expression_evaluator/#opulse.expression.expression_evaluator.ExpressionEvaluator.tree_to_str","title":"<code>tree_to_str(node, parent_op=None, with_base_symbol=True, op_mode=False)</code>","text":"<p>Converts an expression tree node to a string representation.</p> <p>This method recursively traverses the expression tree and builds a string representation based on the node type. For binary and unary expression nodes, it checks the operator priority relative to the parent node's operator priority to determine if parentheses are needed to preserve correct order of operations. For number and variable nodes, it returns their direct string representations.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>ExpressionNode</code> <p>The expression node to convert.</p> required <code>parent_op</code> <code>OperatorInfo</code> <p>Information about the parent operator, used to determine if parentheses are needed. Defaults to None.</p> <code>None</code> <code>with_base_symbol</code> <code>bool</code> <p>Whether to include base symbols in the string. Defaults to True.</p> <code>True</code> <code>op_mode</code> <code>bool</code> <p>A flag indicating operator mode. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String representation of the expression node.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If an unsupported expression node type is encountered.</p> Source code in <code>opulse/expression/expression_evaluator.py</code> <pre><code>def tree_to_str(\n    self,\n    node: ExpressionNode,\n    parent_op: OperatorInfo = None,\n    with_base_symbol: bool = True,\n    op_mode: bool = False,\n) -&gt; str:\n    \"\"\"\n    Converts an expression tree node to a string representation.\n\n    This method recursively traverses the expression tree and builds a string representation based on the node type.\n    For binary and unary expression nodes, it checks the operator priority relative to the parent node's operator priority\n    to determine if parentheses are needed to preserve correct order of operations.\n    For number and variable nodes, it returns their direct string representations.\n\n    Parameters:\n        node (ExpressionNode): The expression node to convert.\n        parent_op (OperatorInfo, optional): Information about the parent operator, used to determine if parentheses are needed. Defaults to None.\n        with_base_symbol (bool, optional): Whether to include base symbols in the string. Defaults to True.\n        op_mode (bool, optional): A flag indicating operator mode. Defaults to False.\n\n    Returns:\n        str: String representation of the expression node.\n\n    Raises:\n        NotImplementedError: If an unsupported expression node type is encountered.\n    \"\"\"\n    # Requires the priority of the parent node's operator for determining whether to add brackets\n    if isinstance(node, NumberNode):\n        node = cast(NumberNode, node)\n        if op_mode:\n            return f\"{node.to_str_no_base_symbol(op_mode=True)}\"\n        else:\n            if with_base_symbol:\n                return f\"{node.to_str(self.operator_manager,self.base_converter)}\"\n            else:\n                return f\"{node.to_str_no_base_symbol()}\"\n    elif isinstance(node, VariableNode):\n        return f\"{node.v}\"\n    elif isinstance(node, BinaryExpressionNode):\n        node = cast(BinaryExpressionNode, node)\n        # Statistical priority for calculating calculate_priority_hierarchical_complexity\n        if (\n            node.operator.priority != None\n            and node.operator.priority not in self.all_priority\n        ):\n            self.all_priority.append(node.operator.priority)\n        # Count the number of operations and associate the expression with the operator\n        self.operation_count += 1\n        self.all_operators[node.operator.id] += 1\n        # Count the n_order info\n        if self.highest_n_order &lt; node.operator.n_order:\n            self.highest_n_order = node.operator.n_order\n        # Convert the expression of the subtree\n        left_str = self.tree_to_str(\n            node.left_expr,\n            node.operator,\n            with_base_symbol=with_base_symbol,\n            op_mode=op_mode,\n        )\n        right_str = self.tree_to_str(\n            node.right_expr,\n            node.operator,\n            with_base_symbol=with_base_symbol,\n            op_mode=op_mode,\n        )\n\n        if self.with_all_brackets:\n            return f\"{self.atoms['left_bracket']}{left_str}{node.operator.symbol}{right_str}{self.atoms['right_bracket']}\"\n        # self.logger.debug(f\"parent_op: {parent_op}\")\n        if parent_op != None and node.operator.priority &lt; parent_op.priority:\n            return f\"{self.atoms['left_bracket']}{left_str}{node.operator.symbol}{right_str}{self.atoms['right_bracket']}\"\n        elif parent_op != None and node.operator.priority == parent_op.priority:\n            # If it has the same priority as parent op, choose whether to add parentheses or not based on location and binding.\n            if (\n                parent_op.associativity_direction == \"left\"\n                and node.position == \"right\"\n            ):\n                return f\"{self.atoms['left_bracket']}{left_str}{node.operator.symbol}{right_str}{self.atoms['right_bracket']}\"\n            elif (\n                parent_op.associativity_direction == \"right\"\n                and node.position == \"left\"\n            ):\n                return f\"{self.atoms['left_bracket']}{left_str}{node.operator.symbol}{right_str}{self.atoms['right_bracket']}\"\n            else:\n                return f\"{left_str}{node.operator.symbol}{right_str}\"\n        else:\n            return f\"{left_str}{node.operator.symbol}{right_str}\"\n    elif isinstance(node, UnaryExpressionNode):\n        node = cast(UnaryExpressionNode, node)\n        # Statistical priority for calculating calculate_priority_hierarchical_complexity\n        if (\n            node.operator.priority != None\n            and node.operator.priority not in self.all_priority\n        ):\n            self.all_priority.append(node.operator.priority)\n        # Count the number of operations and associate the expression with the operator\n        self.operation_count += 1\n        self.all_operators[node.operator.id] += 1\n        # Count the n_order info\n        if self.highest_n_order &lt; node.operator.n_order:\n            self.highest_n_order = node.operator.n_order\n        unary_str = self.tree_to_str(\n            node.unary_expr,\n            node.operator,\n            with_base_symbol=with_base_symbol,\n            op_mode=op_mode,\n        )\n        # Doubt: Always choose to add brackets to unary\n        return f\"({node.operator.symbol}{unary_str})\"\n    else:\n        raise NotImplementedError(\"ExpressionEvaluator.tree_to_str\")\n</code></pre>"},{"location":"Core%20API/expression/expression_expander/","title":"Expression expander","text":""},{"location":"Core%20API/expression/expression_expander/#opulse.expression.expression_expander.ExpressionExpander","title":"<code>ExpressionExpander</code>","text":"Source code in <code>opulse/expression/expression_expander.py</code> <pre><code>class ExpressionExpander:\n    def __init__(self, expression):\n        self.expression = expression  # \u8f93\u5165\u7684\u8868\u8fbe\u5f0f\n\n    def expand(self):\n        \"\"\"\n        The logic of expanding the expression.\n        \"\"\"\n        # \u5177\u4f53\u7684\u5c55\u5f00\u903b\u8f91\uff0c\u6839\u636e\u8fd0\u7b97\u7b26\u7684\u6027\u8d28\u8fdb\u884c\u5c55\u5f00\n        expanded_expression = self._apply_distribution(self.expression)\n        return expanded_expression\n\n    def _apply_distribution(self, expression):\n        \"\"\"\n        A private method to implement expansion rules such as allocation laws.\n        \"\"\"\n        # \u8fd9\u91cc\u5b9e\u73b0\u5177\u4f53\u7684\u5c55\u5f00\u903b\u8f91\uff0c\u6bd4\u5982\u5206\u914d\u5f8b\u7b49\n        # \u53ef\u4ee5\u7528\u6b63\u5219\u8868\u8fbe\u5f0f\u6216\u5176\u4ed6\u65b9\u6cd5\u6765\u5904\u7406\u8868\u8fbe\u5f0f\n        # \u8fd4\u56de\u5c55\u5f00\u540e\u7684\u8868\u8fbe\u5f0f\n        pass\n\n    @staticmethod\n    def generate_expansion_tree(expression):\n        \"\"\"\n        Generate a tree structure for the expansion expression.\n        \"\"\"\n        # \u6839\u636e\u5c55\u5f00\u540e\u7684\u8868\u8fbe\u5f0f\u751f\u6210\u6811\u7ed3\u6784\n        pass\n</code></pre>"},{"location":"Core%20API/expression/expression_expander/#opulse.expression.expression_expander.ExpressionExpander.expand","title":"<code>expand()</code>","text":"<p>The logic of expanding the expression.</p> Source code in <code>opulse/expression/expression_expander.py</code> <pre><code>def expand(self):\n    \"\"\"\n    The logic of expanding the expression.\n    \"\"\"\n    # \u5177\u4f53\u7684\u5c55\u5f00\u903b\u8f91\uff0c\u6839\u636e\u8fd0\u7b97\u7b26\u7684\u6027\u8d28\u8fdb\u884c\u5c55\u5f00\n    expanded_expression = self._apply_distribution(self.expression)\n    return expanded_expression\n</code></pre>"},{"location":"Core%20API/expression/expression_expander/#opulse.expression.expression_expander.ExpressionExpander.generate_expansion_tree","title":"<code>generate_expansion_tree(expression)</code>  <code>staticmethod</code>","text":"<p>Generate a tree structure for the expansion expression.</p> Source code in <code>opulse/expression/expression_expander.py</code> <pre><code>@staticmethod\ndef generate_expansion_tree(expression):\n    \"\"\"\n    Generate a tree structure for the expansion expression.\n    \"\"\"\n    # \u6839\u636e\u5c55\u5f00\u540e\u7684\u8868\u8fbe\u5f0f\u751f\u6210\u6811\u7ed3\u6784\n    pass\n</code></pre>"},{"location":"Core%20API/expression/expression_generator/","title":"Expression generator","text":""},{"location":"Core%20API/expression/expression_generator/#opulse.expression.expression_generator.ExpressionGenerator","title":"<code>ExpressionGenerator</code>","text":"Source code in <code>opulse/expression/expression_generator.py</code> <pre><code>class ExpressionGenerator:\n\n    def __init__(\n        self,\n        param_config: ParamConfig,\n        logger: LogConfig,\n        operator_manager: OperatorManager,\n        # variables: List[str] = None,\n        # min_value: int = 0,\n        # max_value: int = 100,\n        # max_depth: int = 3,\n        # expr_type_weights: Dict[str, float] = None,\n        # atoms_type_weights: Dict[str, float] = None,\n    ):\n        \"\"\"\n        Initializes the ExpressionGenerator with configuration parameters and dependencies.\n\n        Args:\n            param_config (ParamConfig): Configuration parameters for expression generation.\n            logger (LogConfig): Logging configuration to record events and errors.\n            operator_manager (OperatorManager): Manager for handling operators used in expressions.\n        \"\"\"\n        self.param_config = param_config\n        self.logger = logger.get_logger()\n        self.variables = self.param_config.get(\"expr_variables\")\n        self.max_value = self.param_config.get(\"expr_numeric_range\")[\"max_value\"]\n        self.min_value = self.param_config.get(\"expr_numeric_range\")[\"min_value\"]\n        # \u8868\u8fbe\u5f0f\u6811\u7684\u6700\u5927\u6df1\u5ea6 \u9632\u6b62\u9012\u5f52\u8d85\u8fc7\u6700\u5927\u6df1\u5ea6\n        self.max_depth = self.param_config.get(\"expr_max_depth\")\n        # \u8bbe\u7f6e\u8868\u8fbe\u5f0f\u7c7b\u578b\u7684\u6982\u7387\u5206\u5e03\uff0c\u82e5\u672a\u4f20\u5165\u5219\u4f7f\u7528\u9ed8\u8ba4\u503c\n        self.expr_type_weights = self.param_config.get(\"expr_type_weights\")\n        # {\n        #     \"binary\": 0.7,\n        #     \"unary_prefix\": 0.2,\n        #     \"unary_postfix\": 0,\n        #     \"atoms\": 0.1,  # \u6570\u503c\n        # }\n        self.cur_expr_id = 0\n        self.operator_manager = operator_manager\n        self.base_converter = BaseConverter(\n            self.param_config.get(\"max_base\"), self.param_config.get(\"custom_digits\")\n        )\n        self.max_base = self.param_config.get(\"max_base\")\n        self.expr_evaluator = ExpressionEvaluator(\n            param_config,\n            logger,\n            operator_manager,\n            base_converter=self.base_converter,\n        )\n        unary_prefix_ops, unary_postfix_ops, self.binary_ops = (\n            operator_manager.get_unary_and_binary_operators()\n        )\n\n        self.unary_postfix_ops = [\n            opinfo for opinfo in unary_postfix_ops if opinfo.is_base is None\n        ]\n        self.unary_prefix_ops = [\n            opinfo for opinfo in unary_prefix_ops if opinfo.is_base is None\n        ]\n        # operator\u5230expression id\u7684\u6620\u5c04\n        self.operators2expr: Dict[int, list[int]] = defaultdict(list)\n\n        # \u5f53\u662f\u53d8\u91cf\u548c\u6570\u5b57\u7684\u7ec4\u5408\u65f6\uff0c\u624d\u9700\u8981\u8003\u8651\u4e24\u8005\u4e4b\u95f4\u7684\u6743\u91cd\u5206\u5e03\n        self.atoms_type_weights = self.param_config.get(\"expr_atom_type_weights\")\n        # {\n        #     \"variable\": 0.3,\n        #     \"number\": 0.7,\n        # }\n\n    # def generate_random_symbol(self) -&gt; Dict[str, Any]:\n    #     return random.choice(self.operator_set)\n\n    def set_variables(self, new_variables: List[str]):\n        \"\"\"\n        Updates the list of variables used in expression generation.\n\n        Args:\n            new_variables (List[str]): A list of variable names to be used in expressions.\n        \"\"\"\n        self.variables = new_variables\n\n    def set_max_depth(self, max_depth: int) -&gt; None:\n        \"\"\"\n        Sets the maximum depth for generated expression trees.\n\n        Args:\n            max_depth (int): The maximum depth of the expression tree.\n        \"\"\"\n        self.max_depth = max_depth\n\n    def generate_random_value(self) -&gt; int:\n        \"\"\"\n        Generates a random integer value within the predefined min and max range.\n\n        Returns:\n            int: A randomly generated integer value.\n        \"\"\"\n        return random.randint(self.min_value, self.max_value)\n\n    def generate_random_base(self) -&gt; int:\n        \"\"\"\n        Generates a random base for number representation within the allowed range.\n\n        Returns:\n            int: A randomly selected base for number representation.\n        \"\"\"\n        return random.randint(2, self.max_base)\n        # pass\n\n    # def generate_atoms(self) -&gt; ExpressionNode:\n    #     # \u751f\u6210\u53d8\u91cf\u6216\u5e26\u8fdb\u5236\u4fe1\u606f\u7684\u6570\u5b57\n    #     atoms_type = random.choices(\n    #         [\"variable\", \"number\"],\n    #         weights=[\n    #             self.atoms_type_weights[\"variable\"],\n    #             self.atoms_type_weights[\"number\"],\n    #         ],\n    #     )[0]\n    #     atoms_node = None\n    #     if atoms_type == \"variable\":\n    #         # TODO: \u662f\u5426\u9700\u8981\u4e3a\u6240\u6709\u53d8\u91cf\u505a\u6709\u5206\u5e03\u7684\u91c7\u6837\uff1f\n    #         atoms_node = VariableNode(random.choices(self.variable_set)[0])\n    #     elif atoms_type == \"number\":\n    #         atoms_node = NumberNode(\n    #             self.generate_random_value(), self.generate_random_base()\n    #         )\n    #     else:\n    #         raise NotImplementedError(\"In ExpressionGenerator: generate_atoms\")\n\n    #     return atoms_node\n\n    def generate_atoms(self, atom_choice: str) -&gt; ExpressionNode:\n        \"\"\"\n        Generates an atomic node based on the specified type.\n\n        Args:\n            atom_choice (str): Specifies the type of atomic element to generate. Options are 'variable', 'number', or 'variable_and_number'.\n\n        Returns:\n            ExpressionNode: An atomic node representing either a variable or a number.\n\n        Raises:\n            ValueError: If the provided atom_choice is not recognized.\n        \"\"\"\n        atoms_node = None\n        if atom_choice == \"variable\":\n            # \u53ea\u751f\u6210\u53d8\u91cf\n            atoms_node = VariableNode(random.choice(self.variables))\n        elif atom_choice == \"number\":\n            # \u53ea\u751f\u6210\u6570\u5b57\n            atoms_node = NumberNode(\n                self.generate_random_value(), self.generate_random_base()\n            )\n        elif atom_choice == \"variable_and_number\":\n            # \u751f\u6210\u53d8\u91cf\u548c\u6570\u5b57\u7684\u7ec4\u5408\n            atoms_type = random.choices(\n                [\"variable\", \"number\"],\n                weights=[\n                    self.atoms_type_weights[\"variable\"],\n                    self.atoms_type_weights[\"number\"],\n                ],\n            )[0]\n            if atoms_type == \"variable\":\n                atoms_node = VariableNode(random.choice(self.variables))\n            else:\n                atoms_node = NumberNode(\n                    self.generate_random_value(), self.generate_random_base()\n                )\n        else:\n            raise ValueError(\n                f\"Unknown atom_choice value: {atom_choice}. Valid options are 'variable', 'number', or 'variable_and_number'.\"\n            )\n        return atoms_node\n\n    def generate_expression(\n        self, cur_depth, max_depth, atom_choice: str\n    ) -&gt; Dict[str, Any]:\n        \"\"\"\n        Recursively generates a random expression tree up to a specified depth.\n\n        Args:\n            cur_depth (int): Current depth of recursion.\n            max_depth (int): Maximum depth of the expression tree.\n            atom_choice (str): Determines what type of atoms can be generated ('variable', 'number', 'variable_and_number').\n\n        Returns:\n            ExpressionNode: A node representing part of the expression tree.\n        \"\"\"\n        if cur_depth &gt;= max_depth:\n            expr_node = self.generate_atoms(atom_choice)\n            return expr_node\n\n        expr_type = random.choices(\n            [\"binary\", \"unary_prefix\", \"unary_postfix\", \"atoms\"],\n            weights=[\n                self.expr_type_weights[\"binary\"],\n                self.expr_type_weights[\"unary_prefix\"],\n                self.expr_type_weights[\"unary_postfix\"],\n                self.expr_type_weights[\"atoms\"],\n            ],\n        )[0]\n\n        if expr_type == \"binary\":\n            # \u68c0\u67e5 binary_ops \u662f\u5426\u4e3a\u7a7a\n            if not self.binary_ops:\n                # \u5982\u679c\u4e3a\u7a7a\uff0c\u5219\u91cd\u65b0\u968f\u673a\u9009\u62e9\u5176\u4ed6\u7c7b\u522b\n                return self.generate_expression(cur_depth, max_depth, atom_choice)\n            select_op = random.choice(self.binary_ops)\n            expr_node = BinaryExpressionNode(select_op)\n            # \u8fd9\u91cc\u9700\u8981\u8bb0\u5f55\u4f4d\u7f6e\u7684\u539f\u56e0\u5728\u4e8e\uff1a\u8f6c\u6362\u6210\u8868\u8fbe\u5f0f\u5b57\u7b26\u4e32\u7684\u65f6\u5019\u9700\u8981\u8003\u8651\u62ec\u53f7\u7684\u6dfb\u52a0\uff0c\u5c24\u5176\u8003\u8651\u7ed3\u5408\u6027\n            # \u5982\uff1a\u8868\u8fbe\u5f0f\u6811\uff1a1+\uff082+3\uff09\uff0c\u5728\u8f93\u51fa2+3\u540e\uff0c\u9012\u5f52\u7684\u4e0a\u5c42\u9700\u8981\u8003\u8651\u662f\u5426\u6dfb\u52a0\u62ec\u53f7\n            expr_node.left_expr = self.generate_expression(\n                cur_depth + 1, max_depth, atom_choice\n            )\n            expr_node.left_expr.position = \"left\"\n            expr_node.right_expr = self.generate_expression(\n                cur_depth + 1, max_depth, atom_choice\n            )\n            expr_node.right_expr.position = \"right\"\n            return expr_node\n        elif expr_type == \"unary_prefix\":\n            # \u68c0\u67e5 unary_prefix_ops \u662f\u5426\u4e3a\u7a7a\n            if not self.unary_prefix_ops:\n                # \u5982\u679c\u4e3a\u7a7a\uff0c\u5219\u91cd\u65b0\u968f\u673a\u9009\u62e9\u5176\u4ed6\u7c7b\u522b\n                return self.generate_expression(cur_depth, max_depth, atom_choice)\n            select_op = random.choice(self.unary_prefix_ops)\n            if select_op.is_base:\n                print(\"error\")\n                exit(1)\n            expr_node = UnaryExpressionNode(select_op)\n            expr_node.unary_expr = self.generate_expression(\n                cur_depth + 1, max_depth, atom_choice\n            )\n            expr_node.unary_expr.position = \"unary\"\n            return expr_node\n        elif expr_type == \"unary_postfix\":\n            # \u68c0\u67e5 unary_postfix_ops \u662f\u5426\u4e3a\u7a7a\n            if not self.unary_postfix_ops:\n                # \u5982\u679c\u4e3a\u7a7a\uff0c\u5219\u91cd\u65b0\u968f\u673a\u9009\u62e9\u5176\u4ed6\u7c7b\u522b\n                return self.generate_expression(cur_depth, max_depth, atom_choice)\n            select_op = random.choice(self.unary_postfix_ops)\n            expr_node = UnaryExpressionNode(select_op)\n            expr_node.unary_expr = self.generate_expression(\n                cur_depth + 1, max_depth, atom_choice\n            )\n            expr_node.unary_expr.position = \"unary\"\n        elif expr_type == \"atoms\":\n            expr_node = expr_node = self.generate_atoms(atom_choice)\n            return expr_node\n\n    def create_expression(self, atom_choice: str) -&gt; Dict[str, Any]:\n        \"\"\"\n        Creates a new expression, evaluates it, and records the used operators.\n\n        Args:\n            atom_choice (str): Determines the type of atoms that can be included in the expression.\n\n        Returns:\n            Dict[str, Any]: Properties of the evaluated expression, including used operators.\n        \"\"\"\n        expression_tree = self.generate_expression(\n            cur_depth=0, max_depth=self.max_depth, atom_choice=atom_choice\n        )\n        self.expr_evaluator.init_expr(expression_tree, self.cur_expr_id)\n\n        properties = self.expr_evaluator.evaluate()\n        # print(properties[\"used_operators\"])\n        for op_id in properties[\"used_operators\"]:\n            self.operators2expr[op_id].append(self.cur_expr_id)\n\n        # return expression_tree\n        self.cur_expr_id += 1\n\n        return properties\n\n    def create_expression_str(self, atom_choice: str) -&gt; Dict[str, Any]:\n        \"\"\"\n        Generates a string representation of an expression with all sub-expressions enclosed in brackets.\n\n        This method creates a new expression tree and evaluates it to obtain a string representation,\n        ensuring that all parts of the expression are fully parenthesized for clarity. It also updates\n        the unary and binary operators before generating the expression.\n\n        Args:\n            atom_choice (str): Specifies the type of atomic elements to include in the expression ('variable', 'number', or 'variable_and_number').\n\n        Returns:\n            str: A fully parenthesized string representation of the generated expression.\n        \"\"\"\n        self.unary_prefix_ops, self.unary_postfix_ops, self.binary_ops = (\n            self.operator_manager.get_unary_and_binary_operators()\n        )\n        expression_tree = self.generate_expression(\n            cur_depth=0, max_depth=self.max_depth, atom_choice=atom_choice\n        )\n        self.expr_evaluator.set_with_all_brackets(True)\n        self.expr_evaluator.init_expr(expression_tree, self.cur_expr_id, op_mode=True)\n        # evaluator = ExpressionEvaluator(expression_tree, self.operator_manager)\n        # properties = self.expr_evaluator.evaluate()\n\n        return self.expr_evaluator.expression_str\n\n    def dump_op2expr(self, file_path):\n        \"\"\"\n        Dumps the mapping of operator IDs to expression IDs into a JSON Lines file.\n\n        Each line in the output file contains a JSON object representing the relationship between\n        an operator ID and the list of expression IDs that use this operator.\n\n        Args:\n            file_path (str): The path to the output file where the operator-expression mappings will be saved.\n        \"\"\"\n        with open(file_path, \"w\") as f:\n            for op_id in self.operators2expr:\n                data = {\n                    \"op_id\": op_id,\n                    \"expr_id\": self.operators2expr[op_id],\n                }\n                json.dump(data, f)\n                f.write(\"\\n\")\n</code></pre>"},{"location":"Core%20API/expression/expression_generator/#opulse.expression.expression_generator.ExpressionGenerator.__init__","title":"<code>__init__(param_config, logger, operator_manager)</code>","text":"<p>Initializes the ExpressionGenerator with configuration parameters and dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>param_config</code> <code>ParamConfig</code> <p>Configuration parameters for expression generation.</p> required <code>logger</code> <code>LogConfig</code> <p>Logging configuration to record events and errors.</p> required <code>operator_manager</code> <code>OperatorManager</code> <p>Manager for handling operators used in expressions.</p> required Source code in <code>opulse/expression/expression_generator.py</code> <pre><code>def __init__(\n    self,\n    param_config: ParamConfig,\n    logger: LogConfig,\n    operator_manager: OperatorManager,\n    # variables: List[str] = None,\n    # min_value: int = 0,\n    # max_value: int = 100,\n    # max_depth: int = 3,\n    # expr_type_weights: Dict[str, float] = None,\n    # atoms_type_weights: Dict[str, float] = None,\n):\n    \"\"\"\n    Initializes the ExpressionGenerator with configuration parameters and dependencies.\n\n    Args:\n        param_config (ParamConfig): Configuration parameters for expression generation.\n        logger (LogConfig): Logging configuration to record events and errors.\n        operator_manager (OperatorManager): Manager for handling operators used in expressions.\n    \"\"\"\n    self.param_config = param_config\n    self.logger = logger.get_logger()\n    self.variables = self.param_config.get(\"expr_variables\")\n    self.max_value = self.param_config.get(\"expr_numeric_range\")[\"max_value\"]\n    self.min_value = self.param_config.get(\"expr_numeric_range\")[\"min_value\"]\n    # \u8868\u8fbe\u5f0f\u6811\u7684\u6700\u5927\u6df1\u5ea6 \u9632\u6b62\u9012\u5f52\u8d85\u8fc7\u6700\u5927\u6df1\u5ea6\n    self.max_depth = self.param_config.get(\"expr_max_depth\")\n    # \u8bbe\u7f6e\u8868\u8fbe\u5f0f\u7c7b\u578b\u7684\u6982\u7387\u5206\u5e03\uff0c\u82e5\u672a\u4f20\u5165\u5219\u4f7f\u7528\u9ed8\u8ba4\u503c\n    self.expr_type_weights = self.param_config.get(\"expr_type_weights\")\n    # {\n    #     \"binary\": 0.7,\n    #     \"unary_prefix\": 0.2,\n    #     \"unary_postfix\": 0,\n    #     \"atoms\": 0.1,  # \u6570\u503c\n    # }\n    self.cur_expr_id = 0\n    self.operator_manager = operator_manager\n    self.base_converter = BaseConverter(\n        self.param_config.get(\"max_base\"), self.param_config.get(\"custom_digits\")\n    )\n    self.max_base = self.param_config.get(\"max_base\")\n    self.expr_evaluator = ExpressionEvaluator(\n        param_config,\n        logger,\n        operator_manager,\n        base_converter=self.base_converter,\n    )\n    unary_prefix_ops, unary_postfix_ops, self.binary_ops = (\n        operator_manager.get_unary_and_binary_operators()\n    )\n\n    self.unary_postfix_ops = [\n        opinfo for opinfo in unary_postfix_ops if opinfo.is_base is None\n    ]\n    self.unary_prefix_ops = [\n        opinfo for opinfo in unary_prefix_ops if opinfo.is_base is None\n    ]\n    # operator\u5230expression id\u7684\u6620\u5c04\n    self.operators2expr: Dict[int, list[int]] = defaultdict(list)\n\n    # \u5f53\u662f\u53d8\u91cf\u548c\u6570\u5b57\u7684\u7ec4\u5408\u65f6\uff0c\u624d\u9700\u8981\u8003\u8651\u4e24\u8005\u4e4b\u95f4\u7684\u6743\u91cd\u5206\u5e03\n    self.atoms_type_weights = self.param_config.get(\"expr_atom_type_weights\")\n</code></pre>"},{"location":"Core%20API/expression/expression_generator/#opulse.expression.expression_generator.ExpressionGenerator.create_expression","title":"<code>create_expression(atom_choice)</code>","text":"<p>Creates a new expression, evaluates it, and records the used operators.</p> <p>Parameters:</p> Name Type Description Default <code>atom_choice</code> <code>str</code> <p>Determines the type of atoms that can be included in the expression.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Properties of the evaluated expression, including used operators.</p> Source code in <code>opulse/expression/expression_generator.py</code> <pre><code>def create_expression(self, atom_choice: str) -&gt; Dict[str, Any]:\n    \"\"\"\n    Creates a new expression, evaluates it, and records the used operators.\n\n    Args:\n        atom_choice (str): Determines the type of atoms that can be included in the expression.\n\n    Returns:\n        Dict[str, Any]: Properties of the evaluated expression, including used operators.\n    \"\"\"\n    expression_tree = self.generate_expression(\n        cur_depth=0, max_depth=self.max_depth, atom_choice=atom_choice\n    )\n    self.expr_evaluator.init_expr(expression_tree, self.cur_expr_id)\n\n    properties = self.expr_evaluator.evaluate()\n    # print(properties[\"used_operators\"])\n    for op_id in properties[\"used_operators\"]:\n        self.operators2expr[op_id].append(self.cur_expr_id)\n\n    # return expression_tree\n    self.cur_expr_id += 1\n\n    return properties\n</code></pre>"},{"location":"Core%20API/expression/expression_generator/#opulse.expression.expression_generator.ExpressionGenerator.create_expression_str","title":"<code>create_expression_str(atom_choice)</code>","text":"<p>Generates a string representation of an expression with all sub-expressions enclosed in brackets.</p> <p>This method creates a new expression tree and evaluates it to obtain a string representation, ensuring that all parts of the expression are fully parenthesized for clarity. It also updates the unary and binary operators before generating the expression.</p> <p>Parameters:</p> Name Type Description Default <code>atom_choice</code> <code>str</code> <p>Specifies the type of atomic elements to include in the expression ('variable', 'number', or 'variable_and_number').</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>Dict[str, Any]</code> <p>A fully parenthesized string representation of the generated expression.</p> Source code in <code>opulse/expression/expression_generator.py</code> <pre><code>def create_expression_str(self, atom_choice: str) -&gt; Dict[str, Any]:\n    \"\"\"\n    Generates a string representation of an expression with all sub-expressions enclosed in brackets.\n\n    This method creates a new expression tree and evaluates it to obtain a string representation,\n    ensuring that all parts of the expression are fully parenthesized for clarity. It also updates\n    the unary and binary operators before generating the expression.\n\n    Args:\n        atom_choice (str): Specifies the type of atomic elements to include in the expression ('variable', 'number', or 'variable_and_number').\n\n    Returns:\n        str: A fully parenthesized string representation of the generated expression.\n    \"\"\"\n    self.unary_prefix_ops, self.unary_postfix_ops, self.binary_ops = (\n        self.operator_manager.get_unary_and_binary_operators()\n    )\n    expression_tree = self.generate_expression(\n        cur_depth=0, max_depth=self.max_depth, atom_choice=atom_choice\n    )\n    self.expr_evaluator.set_with_all_brackets(True)\n    self.expr_evaluator.init_expr(expression_tree, self.cur_expr_id, op_mode=True)\n    # evaluator = ExpressionEvaluator(expression_tree, self.operator_manager)\n    # properties = self.expr_evaluator.evaluate()\n\n    return self.expr_evaluator.expression_str\n</code></pre>"},{"location":"Core%20API/expression/expression_generator/#opulse.expression.expression_generator.ExpressionGenerator.dump_op2expr","title":"<code>dump_op2expr(file_path)</code>","text":"<p>Dumps the mapping of operator IDs to expression IDs into a JSON Lines file.</p> <p>Each line in the output file contains a JSON object representing the relationship between an operator ID and the list of expression IDs that use this operator.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the output file where the operator-expression mappings will be saved.</p> required Source code in <code>opulse/expression/expression_generator.py</code> <pre><code>def dump_op2expr(self, file_path):\n    \"\"\"\n    Dumps the mapping of operator IDs to expression IDs into a JSON Lines file.\n\n    Each line in the output file contains a JSON object representing the relationship between\n    an operator ID and the list of expression IDs that use this operator.\n\n    Args:\n        file_path (str): The path to the output file where the operator-expression mappings will be saved.\n    \"\"\"\n    with open(file_path, \"w\") as f:\n        for op_id in self.operators2expr:\n            data = {\n                \"op_id\": op_id,\n                \"expr_id\": self.operators2expr[op_id],\n            }\n            json.dump(data, f)\n            f.write(\"\\n\")\n</code></pre>"},{"location":"Core%20API/expression/expression_generator/#opulse.expression.expression_generator.ExpressionGenerator.generate_atoms","title":"<code>generate_atoms(atom_choice)</code>","text":"<p>Generates an atomic node based on the specified type.</p> <p>Parameters:</p> Name Type Description Default <code>atom_choice</code> <code>str</code> <p>Specifies the type of atomic element to generate. Options are 'variable', 'number', or 'variable_and_number'.</p> required <p>Returns:</p> Name Type Description <code>ExpressionNode</code> <code>ExpressionNode</code> <p>An atomic node representing either a variable or a number.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided atom_choice is not recognized.</p> Source code in <code>opulse/expression/expression_generator.py</code> <pre><code>def generate_atoms(self, atom_choice: str) -&gt; ExpressionNode:\n    \"\"\"\n    Generates an atomic node based on the specified type.\n\n    Args:\n        atom_choice (str): Specifies the type of atomic element to generate. Options are 'variable', 'number', or 'variable_and_number'.\n\n    Returns:\n        ExpressionNode: An atomic node representing either a variable or a number.\n\n    Raises:\n        ValueError: If the provided atom_choice is not recognized.\n    \"\"\"\n    atoms_node = None\n    if atom_choice == \"variable\":\n        # \u53ea\u751f\u6210\u53d8\u91cf\n        atoms_node = VariableNode(random.choice(self.variables))\n    elif atom_choice == \"number\":\n        # \u53ea\u751f\u6210\u6570\u5b57\n        atoms_node = NumberNode(\n            self.generate_random_value(), self.generate_random_base()\n        )\n    elif atom_choice == \"variable_and_number\":\n        # \u751f\u6210\u53d8\u91cf\u548c\u6570\u5b57\u7684\u7ec4\u5408\n        atoms_type = random.choices(\n            [\"variable\", \"number\"],\n            weights=[\n                self.atoms_type_weights[\"variable\"],\n                self.atoms_type_weights[\"number\"],\n            ],\n        )[0]\n        if atoms_type == \"variable\":\n            atoms_node = VariableNode(random.choice(self.variables))\n        else:\n            atoms_node = NumberNode(\n                self.generate_random_value(), self.generate_random_base()\n            )\n    else:\n        raise ValueError(\n            f\"Unknown atom_choice value: {atom_choice}. Valid options are 'variable', 'number', or 'variable_and_number'.\"\n        )\n    return atoms_node\n</code></pre>"},{"location":"Core%20API/expression/expression_generator/#opulse.expression.expression_generator.ExpressionGenerator.generate_expression","title":"<code>generate_expression(cur_depth, max_depth, atom_choice)</code>","text":"<p>Recursively generates a random expression tree up to a specified depth.</p> <p>Parameters:</p> Name Type Description Default <code>cur_depth</code> <code>int</code> <p>Current depth of recursion.</p> required <code>max_depth</code> <code>int</code> <p>Maximum depth of the expression tree.</p> required <code>atom_choice</code> <code>str</code> <p>Determines what type of atoms can be generated ('variable', 'number', 'variable_and_number').</p> required <p>Returns:</p> Name Type Description <code>ExpressionNode</code> <code>Dict[str, Any]</code> <p>A node representing part of the expression tree.</p> Source code in <code>opulse/expression/expression_generator.py</code> <pre><code>def generate_expression(\n    self, cur_depth, max_depth, atom_choice: str\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Recursively generates a random expression tree up to a specified depth.\n\n    Args:\n        cur_depth (int): Current depth of recursion.\n        max_depth (int): Maximum depth of the expression tree.\n        atom_choice (str): Determines what type of atoms can be generated ('variable', 'number', 'variable_and_number').\n\n    Returns:\n        ExpressionNode: A node representing part of the expression tree.\n    \"\"\"\n    if cur_depth &gt;= max_depth:\n        expr_node = self.generate_atoms(atom_choice)\n        return expr_node\n\n    expr_type = random.choices(\n        [\"binary\", \"unary_prefix\", \"unary_postfix\", \"atoms\"],\n        weights=[\n            self.expr_type_weights[\"binary\"],\n            self.expr_type_weights[\"unary_prefix\"],\n            self.expr_type_weights[\"unary_postfix\"],\n            self.expr_type_weights[\"atoms\"],\n        ],\n    )[0]\n\n    if expr_type == \"binary\":\n        # \u68c0\u67e5 binary_ops \u662f\u5426\u4e3a\u7a7a\n        if not self.binary_ops:\n            # \u5982\u679c\u4e3a\u7a7a\uff0c\u5219\u91cd\u65b0\u968f\u673a\u9009\u62e9\u5176\u4ed6\u7c7b\u522b\n            return self.generate_expression(cur_depth, max_depth, atom_choice)\n        select_op = random.choice(self.binary_ops)\n        expr_node = BinaryExpressionNode(select_op)\n        # \u8fd9\u91cc\u9700\u8981\u8bb0\u5f55\u4f4d\u7f6e\u7684\u539f\u56e0\u5728\u4e8e\uff1a\u8f6c\u6362\u6210\u8868\u8fbe\u5f0f\u5b57\u7b26\u4e32\u7684\u65f6\u5019\u9700\u8981\u8003\u8651\u62ec\u53f7\u7684\u6dfb\u52a0\uff0c\u5c24\u5176\u8003\u8651\u7ed3\u5408\u6027\n        # \u5982\uff1a\u8868\u8fbe\u5f0f\u6811\uff1a1+\uff082+3\uff09\uff0c\u5728\u8f93\u51fa2+3\u540e\uff0c\u9012\u5f52\u7684\u4e0a\u5c42\u9700\u8981\u8003\u8651\u662f\u5426\u6dfb\u52a0\u62ec\u53f7\n        expr_node.left_expr = self.generate_expression(\n            cur_depth + 1, max_depth, atom_choice\n        )\n        expr_node.left_expr.position = \"left\"\n        expr_node.right_expr = self.generate_expression(\n            cur_depth + 1, max_depth, atom_choice\n        )\n        expr_node.right_expr.position = \"right\"\n        return expr_node\n    elif expr_type == \"unary_prefix\":\n        # \u68c0\u67e5 unary_prefix_ops \u662f\u5426\u4e3a\u7a7a\n        if not self.unary_prefix_ops:\n            # \u5982\u679c\u4e3a\u7a7a\uff0c\u5219\u91cd\u65b0\u968f\u673a\u9009\u62e9\u5176\u4ed6\u7c7b\u522b\n            return self.generate_expression(cur_depth, max_depth, atom_choice)\n        select_op = random.choice(self.unary_prefix_ops)\n        if select_op.is_base:\n            print(\"error\")\n            exit(1)\n        expr_node = UnaryExpressionNode(select_op)\n        expr_node.unary_expr = self.generate_expression(\n            cur_depth + 1, max_depth, atom_choice\n        )\n        expr_node.unary_expr.position = \"unary\"\n        return expr_node\n    elif expr_type == \"unary_postfix\":\n        # \u68c0\u67e5 unary_postfix_ops \u662f\u5426\u4e3a\u7a7a\n        if not self.unary_postfix_ops:\n            # \u5982\u679c\u4e3a\u7a7a\uff0c\u5219\u91cd\u65b0\u968f\u673a\u9009\u62e9\u5176\u4ed6\u7c7b\u522b\n            return self.generate_expression(cur_depth, max_depth, atom_choice)\n        select_op = random.choice(self.unary_postfix_ops)\n        expr_node = UnaryExpressionNode(select_op)\n        expr_node.unary_expr = self.generate_expression(\n            cur_depth + 1, max_depth, atom_choice\n        )\n        expr_node.unary_expr.position = \"unary\"\n    elif expr_type == \"atoms\":\n        expr_node = expr_node = self.generate_atoms(atom_choice)\n        return expr_node\n</code></pre>"},{"location":"Core%20API/expression/expression_generator/#opulse.expression.expression_generator.ExpressionGenerator.generate_random_base","title":"<code>generate_random_base()</code>","text":"<p>Generates a random base for number representation within the allowed range.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>A randomly selected base for number representation.</p> Source code in <code>opulse/expression/expression_generator.py</code> <pre><code>def generate_random_base(self) -&gt; int:\n    \"\"\"\n    Generates a random base for number representation within the allowed range.\n\n    Returns:\n        int: A randomly selected base for number representation.\n    \"\"\"\n    return random.randint(2, self.max_base)\n</code></pre>"},{"location":"Core%20API/expression/expression_generator/#opulse.expression.expression_generator.ExpressionGenerator.generate_random_value","title":"<code>generate_random_value()</code>","text":"<p>Generates a random integer value within the predefined min and max range.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>A randomly generated integer value.</p> Source code in <code>opulse/expression/expression_generator.py</code> <pre><code>def generate_random_value(self) -&gt; int:\n    \"\"\"\n    Generates a random integer value within the predefined min and max range.\n\n    Returns:\n        int: A randomly generated integer value.\n    \"\"\"\n    return random.randint(self.min_value, self.max_value)\n</code></pre>"},{"location":"Core%20API/expression/expression_generator/#opulse.expression.expression_generator.ExpressionGenerator.set_max_depth","title":"<code>set_max_depth(max_depth)</code>","text":"<p>Sets the maximum depth for generated expression trees.</p> <p>Parameters:</p> Name Type Description Default <code>max_depth</code> <code>int</code> <p>The maximum depth of the expression tree.</p> required Source code in <code>opulse/expression/expression_generator.py</code> <pre><code>def set_max_depth(self, max_depth: int) -&gt; None:\n    \"\"\"\n    Sets the maximum depth for generated expression trees.\n\n    Args:\n        max_depth (int): The maximum depth of the expression tree.\n    \"\"\"\n    self.max_depth = max_depth\n</code></pre>"},{"location":"Core%20API/expression/expression_generator/#opulse.expression.expression_generator.ExpressionGenerator.set_variables","title":"<code>set_variables(new_variables)</code>","text":"<p>Updates the list of variables used in expression generation.</p> <p>Parameters:</p> Name Type Description Default <code>new_variables</code> <code>List[str]</code> <p>A list of variable names to be used in expressions.</p> required Source code in <code>opulse/expression/expression_generator.py</code> <pre><code>def set_variables(self, new_variables: List[str]):\n    \"\"\"\n    Updates the list of variables used in expression generation.\n\n    Args:\n        new_variables (List[str]): A list of variable names to be used in expressions.\n    \"\"\"\n    self.variables = new_variables\n</code></pre>"},{"location":"Core%20API/expression/expression_info/","title":"Expression info","text":""},{"location":"Core%20API/expression/expression_node/","title":"Expression node","text":""},{"location":"Core%20API/expression/expression_node/#opulse.expression.expression_node.BinaryExpressionNode","title":"<code>BinaryExpressionNode</code>","text":"<p>               Bases: <code>ExpressionNode</code></p> Source code in <code>opulse/expression/expression_node.py</code> <pre><code>class BinaryExpressionNode(ExpressionNode):\n    def __init__(self, operator: OperatorInfo):\n        \"\"\"\n        Initializes a binary expression node with an operator.\n\n        Args:\n           operator (OperatorInfo): The operator information for the expression.\n        \"\"\"\n        super().__init__()\n        self.left_expr: ExpressionNode = None\n        self.right_expr: ExpressionNode = None\n        self.operator = operator\n\n    def to_dict(self):\n        \"\"\"\n        Converts the binary expression node to a dictionary representation.\n\n        Returns: \n            (dict): A dictionary with the node's type, operator, and child expressions.\n        \"\"\"\n        return {\n            \"type\": \"binary\",\n            \"operator\": self.operator.symbol,\n            \"left_expr\": self.left_expr.to_dict(),\n            \"right_expr\": self.right_expr.to_dict(),\n        }\n</code></pre>"},{"location":"Core%20API/expression/expression_node/#opulse.expression.expression_node.BinaryExpressionNode.__init__","title":"<code>__init__(operator)</code>","text":"<p>Initializes a binary expression node with an operator.</p> <p>Parameters:</p> Name Type Description Default <code>operator</code> <code>OperatorInfo</code> <p>The operator information for the expression.</p> required Source code in <code>opulse/expression/expression_node.py</code> <pre><code>def __init__(self, operator: OperatorInfo):\n    \"\"\"\n    Initializes a binary expression node with an operator.\n\n    Args:\n       operator (OperatorInfo): The operator information for the expression.\n    \"\"\"\n    super().__init__()\n    self.left_expr: ExpressionNode = None\n    self.right_expr: ExpressionNode = None\n    self.operator = operator\n</code></pre>"},{"location":"Core%20API/expression/expression_node/#opulse.expression.expression_node.BinaryExpressionNode.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the binary expression node to a dictionary representation.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary with the node's type, operator, and child expressions.</p> Source code in <code>opulse/expression/expression_node.py</code> <pre><code>def to_dict(self):\n    \"\"\"\n    Converts the binary expression node to a dictionary representation.\n\n    Returns: \n        (dict): A dictionary with the node's type, operator, and child expressions.\n    \"\"\"\n    return {\n        \"type\": \"binary\",\n        \"operator\": self.operator.symbol,\n        \"left_expr\": self.left_expr.to_dict(),\n        \"right_expr\": self.right_expr.to_dict(),\n    }\n</code></pre>"},{"location":"Core%20API/expression/expression_node/#opulse.expression.expression_node.ExpressionNode","title":"<code>ExpressionNode</code>","text":"Source code in <code>opulse/expression/expression_node.py</code> <pre><code>class ExpressionNode:\n    def __init__(self):\n        \"\"\"\n        Initializes a basic expression node with a position attribute.\n        \"\"\"\n        self.position = None\n\n    def to_dict(self):\n        \"\"\"\n        Abstract method to convert the node to a dictionary representation.\n        Subclasses should implement this method.\n        \"\"\"\n        raise NotImplementedError(\"Subclasses should implement this method\")\n</code></pre>"},{"location":"Core%20API/expression/expression_node/#opulse.expression.expression_node.ExpressionNode.__init__","title":"<code>__init__()</code>","text":"<p>Initializes a basic expression node with a position attribute.</p> Source code in <code>opulse/expression/expression_node.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes a basic expression node with a position attribute.\n    \"\"\"\n    self.position = None\n</code></pre>"},{"location":"Core%20API/expression/expression_node/#opulse.expression.expression_node.ExpressionNode.to_dict","title":"<code>to_dict()</code>","text":"<p>Abstract method to convert the node to a dictionary representation. Subclasses should implement this method.</p> Source code in <code>opulse/expression/expression_node.py</code> <pre><code>def to_dict(self):\n    \"\"\"\n    Abstract method to convert the node to a dictionary representation.\n    Subclasses should implement this method.\n    \"\"\"\n    raise NotImplementedError(\"Subclasses should implement this method\")\n</code></pre>"},{"location":"Core%20API/expression/expression_node/#opulse.expression.expression_node.NumberNode","title":"<code>NumberNode</code>","text":"<p>               Bases: <code>ExpressionNode</code></p> Source code in <code>opulse/expression/expression_node.py</code> <pre><code>class NumberNode(ExpressionNode):\n    def __init__(self, value: int, base: int = 10):\n        \"\"\"\n        Initializes a number node with a value and an optional base.\n\n        Args:\n            value (int): The numeric value of the node.\n            base (int): The base of the number (default is 10).\n        \"\"\"\n        super().__init__()\n        self.value = value\n        self.base = base\n\n    def to_dict(self):\n        \"\"\"\n        Converts the number node to a dictionary representation.\n\n        Returns\n            (dict): A dictionary with the node's type, value, and base.\n        \"\"\"\n        return {\"type\": \"numeric_atoms\", \"value\": self.value, \"base\": self.base}\n\n    def to_str_no_base_symbol(self, op_mode: bool = False):\n        \"\"\"\n        Converts the node's value to a string without base symbols.\n\n        Args:\n           op_mode (bool): A boolean indicating if operator mode is enabled (default False).\n\n        Returns: \n            (str): A string representation of the value.\n        \"\"\"\n        if op_mode:\n            return f\"{self.value}\"\n        else:\n            return f\"${self.value}$\"\n\n    def to_str(self, operator_manager: OperatorManager, base_converter: BaseConverter):\n        \"\"\"\n        Converts the node's value to a string with base symbols.\n\n        Args:\n           operator_manager (OperatorManager): The operator manager to get base operators.\n           base_converter (BaseConverter): The base converter to convert the value.\n\n        Returns:\n            (str): A string representation of the value with base symbols.\n\n        Raises:\n            ValueError: If base_converter is None.\n        \"\"\"\n        # \u4f7f\u7528operator_manager\u83b7\u5f97\u7279\u5b9a\u76f8\u5173base\u7684\u4e00\u5143\u8fd0\u7b97\u7b26\n        op_info = operator_manager.base_operators[self.base]\n        if base_converter is None:\n            raise ValueError(\"In NumberNode, base_converter is None\")\n        assert len(op_info) == 1\n        return f\"{op_info[0].symbol}{base_converter.convert(self.value, self.base)}\"\n</code></pre>"},{"location":"Core%20API/expression/expression_node/#opulse.expression.expression_node.NumberNode.__init__","title":"<code>__init__(value, base=10)</code>","text":"<p>Initializes a number node with a value and an optional base.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>The numeric value of the node.</p> required <code>base</code> <code>int</code> <p>The base of the number (default is 10).</p> <code>10</code> Source code in <code>opulse/expression/expression_node.py</code> <pre><code>def __init__(self, value: int, base: int = 10):\n    \"\"\"\n    Initializes a number node with a value and an optional base.\n\n    Args:\n        value (int): The numeric value of the node.\n        base (int): The base of the number (default is 10).\n    \"\"\"\n    super().__init__()\n    self.value = value\n    self.base = base\n</code></pre>"},{"location":"Core%20API/expression/expression_node/#opulse.expression.expression_node.NumberNode.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the number node to a dictionary representation.</p> <p>Returns     (dict): A dictionary with the node's type, value, and base.</p> Source code in <code>opulse/expression/expression_node.py</code> <pre><code>def to_dict(self):\n    \"\"\"\n    Converts the number node to a dictionary representation.\n\n    Returns\n        (dict): A dictionary with the node's type, value, and base.\n    \"\"\"\n    return {\"type\": \"numeric_atoms\", \"value\": self.value, \"base\": self.base}\n</code></pre>"},{"location":"Core%20API/expression/expression_node/#opulse.expression.expression_node.NumberNode.to_str","title":"<code>to_str(operator_manager, base_converter)</code>","text":"<p>Converts the node's value to a string with base symbols.</p> <p>Parameters:</p> Name Type Description Default <code>operator_manager</code> <code>OperatorManager</code> <p>The operator manager to get base operators.</p> required <code>base_converter</code> <code>BaseConverter</code> <p>The base converter to convert the value.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the value with base symbols.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If base_converter is None.</p> Source code in <code>opulse/expression/expression_node.py</code> <pre><code>def to_str(self, operator_manager: OperatorManager, base_converter: BaseConverter):\n    \"\"\"\n    Converts the node's value to a string with base symbols.\n\n    Args:\n       operator_manager (OperatorManager): The operator manager to get base operators.\n       base_converter (BaseConverter): The base converter to convert the value.\n\n    Returns:\n        (str): A string representation of the value with base symbols.\n\n    Raises:\n        ValueError: If base_converter is None.\n    \"\"\"\n    # \u4f7f\u7528operator_manager\u83b7\u5f97\u7279\u5b9a\u76f8\u5173base\u7684\u4e00\u5143\u8fd0\u7b97\u7b26\n    op_info = operator_manager.base_operators[self.base]\n    if base_converter is None:\n        raise ValueError(\"In NumberNode, base_converter is None\")\n    assert len(op_info) == 1\n    return f\"{op_info[0].symbol}{base_converter.convert(self.value, self.base)}\"\n</code></pre>"},{"location":"Core%20API/expression/expression_node/#opulse.expression.expression_node.NumberNode.to_str_no_base_symbol","title":"<code>to_str_no_base_symbol(op_mode=False)</code>","text":"<p>Converts the node's value to a string without base symbols.</p> <p>Parameters:</p> Name Type Description Default <code>op_mode</code> <code>bool</code> <p>A boolean indicating if operator mode is enabled (default False).</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the value.</p> Source code in <code>opulse/expression/expression_node.py</code> <pre><code>def to_str_no_base_symbol(self, op_mode: bool = False):\n    \"\"\"\n    Converts the node's value to a string without base symbols.\n\n    Args:\n       op_mode (bool): A boolean indicating if operator mode is enabled (default False).\n\n    Returns: \n        (str): A string representation of the value.\n    \"\"\"\n    if op_mode:\n        return f\"{self.value}\"\n    else:\n        return f\"${self.value}$\"\n</code></pre>"},{"location":"Core%20API/expression/expression_node/#opulse.expression.expression_node.UnaryExpressionNode","title":"<code>UnaryExpressionNode</code>","text":"<p>               Bases: <code>ExpressionNode</code></p> Source code in <code>opulse/expression/expression_node.py</code> <pre><code>class UnaryExpressionNode(ExpressionNode):\n    def __init__(self, operator: OperatorInfo):\n        \"\"\"\n        Initializes a unary expression node with an operator.\n\n        Args:\n            operator (OperatorInfo): The operator information for the expression.\n        \"\"\"\n        super().__init__()\n        self.operator = operator\n        self.unary_expr: ExpressionNode = None\n\n    def to_dict(self):\n        \"\"\"\n        Converts the unary expression node to a dictionary representation.\n\n        Returns: \n            (dict): A dictionary with the node's type, operator, and unary expression.\n        \"\"\"\n        return {\n            \"type\": \"unary\",\n            \"operator\": self.operator.symbol,\n            \"unary_expr\": self.unary_expr.to_dict(),\n        }\n</code></pre>"},{"location":"Core%20API/expression/expression_node/#opulse.expression.expression_node.UnaryExpressionNode.__init__","title":"<code>__init__(operator)</code>","text":"<p>Initializes a unary expression node with an operator.</p> <p>Parameters:</p> Name Type Description Default <code>operator</code> <code>OperatorInfo</code> <p>The operator information for the expression.</p> required Source code in <code>opulse/expression/expression_node.py</code> <pre><code>def __init__(self, operator: OperatorInfo):\n    \"\"\"\n    Initializes a unary expression node with an operator.\n\n    Args:\n        operator (OperatorInfo): The operator information for the expression.\n    \"\"\"\n    super().__init__()\n    self.operator = operator\n    self.unary_expr: ExpressionNode = None\n</code></pre>"},{"location":"Core%20API/expression/expression_node/#opulse.expression.expression_node.UnaryExpressionNode.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the unary expression node to a dictionary representation.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary with the node's type, operator, and unary expression.</p> Source code in <code>opulse/expression/expression_node.py</code> <pre><code>def to_dict(self):\n    \"\"\"\n    Converts the unary expression node to a dictionary representation.\n\n    Returns: \n        (dict): A dictionary with the node's type, operator, and unary expression.\n    \"\"\"\n    return {\n        \"type\": \"unary\",\n        \"operator\": self.operator.symbol,\n        \"unary_expr\": self.unary_expr.to_dict(),\n    }\n</code></pre>"},{"location":"Core%20API/expression/expression_node/#opulse.expression.expression_node.VariableNode","title":"<code>VariableNode</code>","text":"<p>               Bases: <code>ExpressionNode</code></p> Source code in <code>opulse/expression/expression_node.py</code> <pre><code>class VariableNode(ExpressionNode):\n    def __init__(self, variable: str):\n        \"\"\"\n        Initializes a variable node with a variable name.\n\n        Args:\n           variable (str): The name of the variable.\n        \"\"\"\n        super().__init__()\n        self.v = variable\n\n    def to_dict(self):\n        \"\"\"\n        Converts the variable node to a dictionary representation.\n\n        Returns: \n            (dict): A dictionary with the node's type and variable name.\n        \"\"\"\n        return {\n            \"type\": \"variable\",\n            \"variable\": self.v,\n        }\n</code></pre>"},{"location":"Core%20API/expression/expression_node/#opulse.expression.expression_node.VariableNode.__init__","title":"<code>__init__(variable)</code>","text":"<p>Initializes a variable node with a variable name.</p> <p>Parameters:</p> Name Type Description Default <code>variable</code> <code>str</code> <p>The name of the variable.</p> required Source code in <code>opulse/expression/expression_node.py</code> <pre><code>def __init__(self, variable: str):\n    \"\"\"\n    Initializes a variable node with a variable name.\n\n    Args:\n       variable (str): The name of the variable.\n    \"\"\"\n    super().__init__()\n    self.v = variable\n</code></pre>"},{"location":"Core%20API/expression/expression_node/#opulse.expression.expression_node.VariableNode.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the variable node to a dictionary representation.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary with the node's type and variable name.</p> Source code in <code>opulse/expression/expression_node.py</code> <pre><code>def to_dict(self):\n    \"\"\"\n    Converts the variable node to a dictionary representation.\n\n    Returns: \n        (dict): A dictionary with the node's type and variable name.\n    \"\"\"\n    return {\n        \"type\": \"variable\",\n        \"variable\": self.v,\n    }\n</code></pre>"},{"location":"Core%20API/operatorplus/condition_generator/","title":"Condition generator","text":""},{"location":"Core%20API/operatorplus/condition_generator/#opulse.operatorplus.condition_generator.ConditionGenerator","title":"<code>ConditionGenerator</code>","text":"Source code in <code>opulse/operatorplus/condition_generator.py</code> <pre><code>class ConditionGenerator:\n    def __init__(\n        self,\n        param_config: ParamConfig,\n        logger: LogConfig,\n        operator_manager: \"OperatorManager\" = None,\n    ):\n        \"\"\"\n        Initializes the generator with a list of variable names, unary operators, binary operators, \n        numeric range for values, and the range for the number of conditions to generate.\n\n        Parameters:\n            param_config (ParamConfig): Configuration object containing necessary settings.\n            logger (LogConfig): Logger configuration object for logging.\n            operator_manager (OperatorManager, optional): Operator manager object for accessing operator information.\n        \"\"\"\n        self.param_config = param_config\n        self.logger = logger.get_logger()\n        self.operator_manager = operator_manager\n        self.variables = [self.param_config.atoms[\"left_operand\"], self.param_config.atoms[\"right_operand\"]]\n        self.comparison_ops = self.param_config.get(\"comparison_ops\")\n        self.logical_connectors = self.param_config.get(\"logical_connectors\")\n        self.min_value = self.param_config.get(\"condition_numeric_range\")[\"min_value\"]\n        self.max_value = self.param_config.get(\"condition_numeric_range\")[\"max_value\"]\n        self.condition_probabilities = self.param_config.get('condition_probabilities')\n\n        # Log initial configuration\n        self.logger.debug(f\"ConditionGenerator initialized with variables: {self.variables}\")\n        self.logger.debug(f\"Comparison operators: {self.comparison_ops}\")\n        self.logger.debug(f\"Logical connectors: {self.logical_connectors}\")\n        self.logger.debug(f\"Numeric range: {self.min_value} to {self.max_value}\")\n\n    def set_variables(self, new_variables: List[str]):\n        \"\"\"\n        Sets new values for the list of variables.\n\n        Parameters:\n            new_variables (List[str]): A new list of variables, e.g., ['a'] or ['a', 'b'].\n        \"\"\"\n        self.variables = new_variables\n        self.logger.debug(f\"Variables set to: {self.variables}\")\n\n    def set_condition_probabilities(self, condition_probs: Dict[int, float]):\n        \"\"\"\n        Sets the condition probability dictionary. The keys are numbers and the values are probabilities.\n        If an empty dictionary is passed, the default values are restored.\n\n        Parameters:\n            condition_probs (Dict[int, float]): A dictionary of condition probabilities, where keys are numbers and values are the probabilities.\n\n        Raises:\n            ValueError: If the values in the probability dictionary are not within the valid range (0, 1).\n        \"\"\"\n        # Check if the values in the dictionary are valid probabilities\n        for key, prob in condition_probs.items():\n            if not (0 &lt;= prob &lt;= 1):  # Ensure the probability is between 0 and 1\n                raise ValueError(f\"Probability for key {key} is out of valid range: {prob}\")\n\n        self.condition_probabilities = condition_probs\n        self.param_config['condition_probabilities'] = condition_probs\n        self.logger.debug(f\"Condition probabilities set to: {self.condition_probabilities}\")\n\n    def generate_operand(self, var: str) -&gt; str:\n        \"\"\"\n        Randomly generates an expression with a unary or binary operator, or simply returns a variable.\n\n        Parameters:\n            var (str): The variable name.\n\n        Returns:\n            str: The generated expression, which can be a variable, a unary operator applied to the variable, \n                 or a binary operator with a constant.\n        \"\"\"\n        unary_prefix_ops, unary_postfix_ops, binary_ops = (\n            self.operator_manager.get_unary_and_binary_operators()\n        )\n        # Randomly choose the type of expression to generate: variable, unary operator, or binary operator\n        expr_type = random.choice(\n            [\"variable\", \"unary_prefix\", \"unary_postfix\", \"binary\"]\n        )\n        self.logger.debug(f\"Generating operand for variable '{var}', chosen type: {expr_type}\")\n\n        if expr_type == \"unary_prefix\" and unary_prefix_ops:\n            # Generate unary operator prefix expression\n            unary_op = random.choice(unary_prefix_ops).symbol\n            self.logger.debug(f\"Generated unary prefix operator: {unary_op}\")\n            return f\"{self.param_config.atoms['left_parenthesis']}{unary_op}{var}{self.param_config.atoms['right_parenthesis']}\"\n\n        elif expr_type == \"unary_postfix\" and unary_postfix_ops:\n            # Generate unary operator postfix expression\n            unary_op = random.choice(unary_postfix_ops).symbol\n            self.logger.debug(f\"Generated unary postfix operator: {unary_op}\")\n            return f\"{self.param_config.atoms['left_parenthesis']}{var}{unary_op}{self.param_config.atoms['right_parenthesis']}\"\n\n        elif expr_type == \"binary\" and binary_ops:\n            # Generate binary operator expression\n            binary_op = random.choice(binary_ops).symbol\n            value = random.randint(self.min_value, self.max_value)  # Can adjust the range\n            self.logger.debug(f\"Generated binary operator: {binary_op} with value: {value}\")\n            return f\"{self.param_config.atoms['left_parenthesis']}{var} {binary_op} {value}{self.param_config.atoms['right_parenthesis']}\"\n\n        # Return the variable itself\n        self.logger.debug(f\"Returning variable: {var}\")\n        return var\n\n    def generate_condition(self) -&gt; str:\n        \"\"\"\n        Generates a condition expression.\n\n        Returns:\n            str: The generated condition expression, in the form \"operand comparison_op value\".\n        \"\"\"\n        var = random.choice(self.variables)\n        operand = self.generate_operand(var)\n        comp_op = random.choice(self.comparison_ops)\n        value = random.randint(self.min_value, self.max_value)\n        condition = f\"{operand} {comp_op} {value}\"\n        self.logger.debug(f\"Generated condition: {condition}\")\n        return condition\n\n    def choose_num_conditions(self) -&gt; int:\n        \"\"\"\n        Chooses the number of conditions based on the probability distribution in condition_probabilities.\n\n        Returns:\n            int: The number of conditions to generate, selected based on the probability distribution.\n        \"\"\"\n        # Select the number of conditions based on the given probability distribution\n        population = list(self.condition_probabilities.keys())\n        weights = list(self.condition_probabilities.values())\n        num_conditions = random.choices(population, weights=weights, k=1)[0]\n        self.logger.debug(f\"Chosen number of conditions: {num_conditions}\")\n        return num_conditions\n\n    def generate_condition_expr(self) -&gt; str:\n        \"\"\"\n        Generates an expression consisting of multiple conditions, including logical operators and condition parentheses.\n\n        Returns:\n            str: The generated condition expression, which can either be a single condition or a combination of conditions connected by logical operators.\n        \"\"\"\n        # Choose the number of conditions based on condition_probabilities\n        num_conditions = self.choose_num_conditions()\n\n        # Generate the list of conditions\n        conditions = [self.generate_condition() for _ in range(num_conditions)]\n        self.logger.debug(f\"Generated conditions: {conditions}\")\n\n        # Concatenate the conditions to form the final expression\n        if num_conditions == 1:\n            condition_expr = conditions[0]\n        else:\n            connector = random.choice(self.logical_connectors)\n            self.logger.debug(f\"Chosen logical connector: {connector}\")\n            condition_expr = f\" {connector} \".join(conditions)\n            if random.choice([True, False]):\n                condition_expr = f\"({condition_expr})\"\n        self.logger.debug(f\"Generated final conditional expression : {condition_expr}\")\n        self.logger.info(f\"Generated final conditional expression : {condition_expr}\")\n        return condition_expr\n</code></pre>"},{"location":"Core%20API/operatorplus/condition_generator/#opulse.operatorplus.condition_generator.ConditionGenerator.__init__","title":"<code>__init__(param_config, logger, operator_manager=None)</code>","text":"<p>Initializes the generator with a list of variable names, unary operators, binary operators,  numeric range for values, and the range for the number of conditions to generate.</p> <p>Parameters:</p> Name Type Description Default <code>param_config</code> <code>ParamConfig</code> <p>Configuration object containing necessary settings.</p> required <code>logger</code> <code>LogConfig</code> <p>Logger configuration object for logging.</p> required <code>operator_manager</code> <code>OperatorManager</code> <p>Operator manager object for accessing operator information.</p> <code>None</code> Source code in <code>opulse/operatorplus/condition_generator.py</code> <pre><code>def __init__(\n    self,\n    param_config: ParamConfig,\n    logger: LogConfig,\n    operator_manager: \"OperatorManager\" = None,\n):\n    \"\"\"\n    Initializes the generator with a list of variable names, unary operators, binary operators, \n    numeric range for values, and the range for the number of conditions to generate.\n\n    Parameters:\n        param_config (ParamConfig): Configuration object containing necessary settings.\n        logger (LogConfig): Logger configuration object for logging.\n        operator_manager (OperatorManager, optional): Operator manager object for accessing operator information.\n    \"\"\"\n    self.param_config = param_config\n    self.logger = logger.get_logger()\n    self.operator_manager = operator_manager\n    self.variables = [self.param_config.atoms[\"left_operand\"], self.param_config.atoms[\"right_operand\"]]\n    self.comparison_ops = self.param_config.get(\"comparison_ops\")\n    self.logical_connectors = self.param_config.get(\"logical_connectors\")\n    self.min_value = self.param_config.get(\"condition_numeric_range\")[\"min_value\"]\n    self.max_value = self.param_config.get(\"condition_numeric_range\")[\"max_value\"]\n    self.condition_probabilities = self.param_config.get('condition_probabilities')\n\n    # Log initial configuration\n    self.logger.debug(f\"ConditionGenerator initialized with variables: {self.variables}\")\n    self.logger.debug(f\"Comparison operators: {self.comparison_ops}\")\n    self.logger.debug(f\"Logical connectors: {self.logical_connectors}\")\n    self.logger.debug(f\"Numeric range: {self.min_value} to {self.max_value}\")\n</code></pre>"},{"location":"Core%20API/operatorplus/condition_generator/#opulse.operatorplus.condition_generator.ConditionGenerator.choose_num_conditions","title":"<code>choose_num_conditions()</code>","text":"<p>Chooses the number of conditions based on the probability distribution in condition_probabilities.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of conditions to generate, selected based on the probability distribution.</p> Source code in <code>opulse/operatorplus/condition_generator.py</code> <pre><code>def choose_num_conditions(self) -&gt; int:\n    \"\"\"\n    Chooses the number of conditions based on the probability distribution in condition_probabilities.\n\n    Returns:\n        int: The number of conditions to generate, selected based on the probability distribution.\n    \"\"\"\n    # Select the number of conditions based on the given probability distribution\n    population = list(self.condition_probabilities.keys())\n    weights = list(self.condition_probabilities.values())\n    num_conditions = random.choices(population, weights=weights, k=1)[0]\n    self.logger.debug(f\"Chosen number of conditions: {num_conditions}\")\n    return num_conditions\n</code></pre>"},{"location":"Core%20API/operatorplus/condition_generator/#opulse.operatorplus.condition_generator.ConditionGenerator.generate_condition","title":"<code>generate_condition()</code>","text":"<p>Generates a condition expression.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The generated condition expression, in the form \"operand comparison_op value\".</p> Source code in <code>opulse/operatorplus/condition_generator.py</code> <pre><code>def generate_condition(self) -&gt; str:\n    \"\"\"\n    Generates a condition expression.\n\n    Returns:\n        str: The generated condition expression, in the form \"operand comparison_op value\".\n    \"\"\"\n    var = random.choice(self.variables)\n    operand = self.generate_operand(var)\n    comp_op = random.choice(self.comparison_ops)\n    value = random.randint(self.min_value, self.max_value)\n    condition = f\"{operand} {comp_op} {value}\"\n    self.logger.debug(f\"Generated condition: {condition}\")\n    return condition\n</code></pre>"},{"location":"Core%20API/operatorplus/condition_generator/#opulse.operatorplus.condition_generator.ConditionGenerator.generate_condition_expr","title":"<code>generate_condition_expr()</code>","text":"<p>Generates an expression consisting of multiple conditions, including logical operators and condition parentheses.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The generated condition expression, which can either be a single condition or a combination of conditions connected by logical operators.</p> Source code in <code>opulse/operatorplus/condition_generator.py</code> <pre><code>def generate_condition_expr(self) -&gt; str:\n    \"\"\"\n    Generates an expression consisting of multiple conditions, including logical operators and condition parentheses.\n\n    Returns:\n        str: The generated condition expression, which can either be a single condition or a combination of conditions connected by logical operators.\n    \"\"\"\n    # Choose the number of conditions based on condition_probabilities\n    num_conditions = self.choose_num_conditions()\n\n    # Generate the list of conditions\n    conditions = [self.generate_condition() for _ in range(num_conditions)]\n    self.logger.debug(f\"Generated conditions: {conditions}\")\n\n    # Concatenate the conditions to form the final expression\n    if num_conditions == 1:\n        condition_expr = conditions[0]\n    else:\n        connector = random.choice(self.logical_connectors)\n        self.logger.debug(f\"Chosen logical connector: {connector}\")\n        condition_expr = f\" {connector} \".join(conditions)\n        if random.choice([True, False]):\n            condition_expr = f\"({condition_expr})\"\n    self.logger.debug(f\"Generated final conditional expression : {condition_expr}\")\n    self.logger.info(f\"Generated final conditional expression : {condition_expr}\")\n    return condition_expr\n</code></pre>"},{"location":"Core%20API/operatorplus/condition_generator/#opulse.operatorplus.condition_generator.ConditionGenerator.generate_operand","title":"<code>generate_operand(var)</code>","text":"<p>Randomly generates an expression with a unary or binary operator, or simply returns a variable.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>str</code> <p>The variable name.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The generated expression, which can be a variable, a unary operator applied to the variable,   or a binary operator with a constant.</p> Source code in <code>opulse/operatorplus/condition_generator.py</code> <pre><code>def generate_operand(self, var: str) -&gt; str:\n    \"\"\"\n    Randomly generates an expression with a unary or binary operator, or simply returns a variable.\n\n    Parameters:\n        var (str): The variable name.\n\n    Returns:\n        str: The generated expression, which can be a variable, a unary operator applied to the variable, \n             or a binary operator with a constant.\n    \"\"\"\n    unary_prefix_ops, unary_postfix_ops, binary_ops = (\n        self.operator_manager.get_unary_and_binary_operators()\n    )\n    # Randomly choose the type of expression to generate: variable, unary operator, or binary operator\n    expr_type = random.choice(\n        [\"variable\", \"unary_prefix\", \"unary_postfix\", \"binary\"]\n    )\n    self.logger.debug(f\"Generating operand for variable '{var}', chosen type: {expr_type}\")\n\n    if expr_type == \"unary_prefix\" and unary_prefix_ops:\n        # Generate unary operator prefix expression\n        unary_op = random.choice(unary_prefix_ops).symbol\n        self.logger.debug(f\"Generated unary prefix operator: {unary_op}\")\n        return f\"{self.param_config.atoms['left_parenthesis']}{unary_op}{var}{self.param_config.atoms['right_parenthesis']}\"\n\n    elif expr_type == \"unary_postfix\" and unary_postfix_ops:\n        # Generate unary operator postfix expression\n        unary_op = random.choice(unary_postfix_ops).symbol\n        self.logger.debug(f\"Generated unary postfix operator: {unary_op}\")\n        return f\"{self.param_config.atoms['left_parenthesis']}{var}{unary_op}{self.param_config.atoms['right_parenthesis']}\"\n\n    elif expr_type == \"binary\" and binary_ops:\n        # Generate binary operator expression\n        binary_op = random.choice(binary_ops).symbol\n        value = random.randint(self.min_value, self.max_value)  # Can adjust the range\n        self.logger.debug(f\"Generated binary operator: {binary_op} with value: {value}\")\n        return f\"{self.param_config.atoms['left_parenthesis']}{var} {binary_op} {value}{self.param_config.atoms['right_parenthesis']}\"\n\n    # Return the variable itself\n    self.logger.debug(f\"Returning variable: {var}\")\n    return var\n</code></pre>"},{"location":"Core%20API/operatorplus/condition_generator/#opulse.operatorplus.condition_generator.ConditionGenerator.set_condition_probabilities","title":"<code>set_condition_probabilities(condition_probs)</code>","text":"<p>Sets the condition probability dictionary. The keys are numbers and the values are probabilities. If an empty dictionary is passed, the default values are restored.</p> <p>Parameters:</p> Name Type Description Default <code>condition_probs</code> <code>Dict[int, float]</code> <p>A dictionary of condition probabilities, where keys are numbers and values are the probabilities.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the values in the probability dictionary are not within the valid range (0, 1).</p> Source code in <code>opulse/operatorplus/condition_generator.py</code> <pre><code>def set_condition_probabilities(self, condition_probs: Dict[int, float]):\n    \"\"\"\n    Sets the condition probability dictionary. The keys are numbers and the values are probabilities.\n    If an empty dictionary is passed, the default values are restored.\n\n    Parameters:\n        condition_probs (Dict[int, float]): A dictionary of condition probabilities, where keys are numbers and values are the probabilities.\n\n    Raises:\n        ValueError: If the values in the probability dictionary are not within the valid range (0, 1).\n    \"\"\"\n    # Check if the values in the dictionary are valid probabilities\n    for key, prob in condition_probs.items():\n        if not (0 &lt;= prob &lt;= 1):  # Ensure the probability is between 0 and 1\n            raise ValueError(f\"Probability for key {key} is out of valid range: {prob}\")\n\n    self.condition_probabilities = condition_probs\n    self.param_config['condition_probabilities'] = condition_probs\n    self.logger.debug(f\"Condition probabilities set to: {self.condition_probabilities}\")\n</code></pre>"},{"location":"Core%20API/operatorplus/condition_generator/#opulse.operatorplus.condition_generator.ConditionGenerator.set_variables","title":"<code>set_variables(new_variables)</code>","text":"<p>Sets new values for the list of variables.</p> <p>Parameters:</p> Name Type Description Default <code>new_variables</code> <code>List[str]</code> <p>A new list of variables, e.g., ['a'] or ['a', 'b'].</p> required Source code in <code>opulse/operatorplus/condition_generator.py</code> <pre><code>def set_variables(self, new_variables: List[str]):\n    \"\"\"\n    Sets new values for the list of variables.\n\n    Parameters:\n        new_variables (List[str]): A new list of variables, e.g., ['a'] or ['a', 'b'].\n    \"\"\"\n    self.variables = new_variables\n    self.logger.debug(f\"Variables set to: {self.variables}\")\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_definition_parser/","title":"Operator definition parser","text":""},{"location":"Core%20API/operatorplus/operator_definition_parser/#opulse.operatorplus.operator_definition_parser.OperatorDefinitionParser","title":"<code>OperatorDefinitionParser</code>","text":"<p>A parser class for dynamically generating and parsing operator definitions.</p> <p>This class constructs a grammar dynamically based on the provided <code>ParamConfig</code> and uses the <code>Lark</code> parser  to parse operator definitions. The class supports parsing expressions that involve various operators, conditions,  and logical structures such as \"if\", \"else\", and logical conditions.</p> <p>Attributes:</p> Name Type Description <code>param_config</code> <code>ParamConfig</code> <p>Configuration object containing atoms like operators, parenthesis, and constants.</p> <code>logger</code> <code>LogConfig</code> <p>Logger configuration to record debugging and information logs.</p> <code>parser</code> <code>Lark</code> <p>The Lark parser instance to parse operator definitions.</p> <code>grammar</code> <code>str</code> <p>The dynamically generated grammar used by the Lark parser.</p> Source code in <code>opulse/operatorplus/operator_definition_parser.py</code> <pre><code>class OperatorDefinitionParser:\n    \"\"\"\n    A parser class for dynamically generating and parsing operator definitions.\n\n    This class constructs a grammar dynamically based on the provided `ParamConfig` and uses the `Lark` parser \n    to parse operator definitions. The class supports parsing expressions that involve various operators, conditions, \n    and logical structures such as \"if\", \"else\", and logical conditions.\n\n    Attributes:\n        param_config (ParamConfig): Configuration object containing atoms like operators, parenthesis, and constants.\n        logger (LogConfig): Logger configuration to record debugging and information logs.\n        parser (Lark): The Lark parser instance to parse operator definitions.\n        grammar (str): The dynamically generated grammar used by the Lark parser.\n    \"\"\"\n\n    def __init__(self, param_config: ParamConfig, logger: LogConfig):\n        \"\"\"\n        Initializes the OperatorDefinitionParser with given configuration and logger.\n\n        Args:\n            param_config (ParamConfig): A configuration object that contains parameter definitions, \n                                         including operators, atomic values, and symbols.\n            logger (LogConfig): A logging configuration object used to log debugging and info messages.\n\n        Initializes the grammar dynamically using the `param_config` and configures the Lark parser.\n        \"\"\"\n\n        # Store the provided param_config and logger\n        self.param_config = param_config\n        self.logger = logger.get_logger()\n\n        # Dynamically construct the grammar using `param_config`\n        self.grammar = f\"\"\"\n        ?start: rule\n        rule: lhs_expr \"{self.param_config.atoms[\"equal\"]}\" \"{{\" rhs_expr \"}}\"\n        lhs_expr: expr\n        rhs_expr: branch (SEMICOLON branch)* \n        ?branch: if_branch\n            | else_branch\n            | unconditional_branch\n        if_branch: expr \",\" \"if\" condition\n        else_branch: expr \",\" \"else\"\n        unconditional_branch: expr\n        ?condition: or_condition\n        ?or_condition: or_condition \"or\" and_condition    -&gt; or_condition\n                    | and_condition\n        ?and_condition: and_condition \"and\" comparison     -&gt; and_condition\n                    | comparison\n        ?comparison: \"not\" comparison                      -&gt; not_condition\n                | expr CONDITION_OPERATOR expr          -&gt; comparison\n                | \"{self.param_config.atoms[\"left_parenthesis\"]}\" condition \"{self.param_config.atoms[\"right_parenthesis\"]}\"   -&gt; grouped_condition \n        ?expr: expr OPERATOR term  -&gt; binary_operation\n            | term\n        ?term: factor\n            | OPERATOR factor      -&gt; unary_operation_prefix\n            | factor OPERATOR      -&gt; unary_operation_postfix\n        ?factor: \"{self.param_config.atoms[\"nan\"]}\"          -&gt; no_solution\n            | VARIABLE      -&gt;variable_conversion\n            | INT           -&gt;int_conversion\n            | \"{self.param_config.atoms[\"left_parenthesis\"]}\" expr \"{self.param_config.atoms[\"right_parenthesis\"]}\"\n        OPERATOR: SYMBOL+\n        SYMBOL: \"+\" | \"-\" | \"*\" | \"/\" | \"%\" | /[\\u2200-\\u22FF\\u2A00-\\u2BFF\\u2190-\\u21FF]+/\n        CONDITION_OPERATOR: \"==\" | \"&gt;\" | \"&lt;\" | \"&gt;=\" | \"&lt;=\"| \"!=\"\n        VARIABLE: /[a-zA-Z]/\n        NO_SOLUTION: \"{self.param_config.atoms[\"nan\"]}\"   \n        SEMICOLON: \";\"\n        %import common.INT\n        %import common.WS\n        %ignore WS\n        \"\"\"\n\n        # Logging the generated grammar for debugging\n        self.logger.debug(f\"Generated grammar: {self.grammar}\")\n\n        # Initialize the Lark parser with the dynamically generated grammar\n        self.parser = Lark(self.grammar, start=\"start\")\n\n        # Log that the parser has been successfully initialized\n        self.logger.info(\"OperatorDefinitionParser initialized successfully.\")\n\n    def parse_definition(self, definition):\n        \"\"\"\n        Parse the given operator definition using the generated grammar.\n\n        Args:\n            definition (str): The operator definition string to be parsed.\n\n        Returns:\n            LarkTree: A Lark parsing tree representing the parsed definition.\n\n        Logs the parsing process and any issues during parsing.\n        \"\"\"\n        try:\n            self.logger.info(f\"Attempting to parse definition: {definition}\")\n            parsed_tree = self.parser.parse(definition)\n            self.logger.info(\"Parsing successful.\")\n            return parsed_tree\n        except Exception as e:\n            self.logger.error(f\"Error while parsing definition: {e}\")\n            raise\n\n    def update_definition(self, definition):\n        \"\"\"\n        Update the operator definition by replacing indexed numeric atoms with their values from `param_config`.\n\n        This method performs a replacement in the expression, replacing placeholders such as '0', '1', etc. \n        with corresponding values from `numeric_atoms`.\n\n        Args:\n            definition (str): The operator definition to be updated.\n\n        Returns:\n            str: The updated operator definition with numeric atoms replaced.\n\n        Logs each replacement performed in the update process for debugging.\n        \"\"\"\n        updated_expr = definition\n\n        self.logger.info(f\"Starting update of definition: {definition}\")\n\n        # Limit to the first 10 numeric atoms for replacement\n        for idx, numeric_atom in enumerate(self.param_config.atoms[\"numeric_atoms\"][:10]):\n            self.logger.debug(f\"Replacing index '{idx}' with numeric atom value '{numeric_atom}'\")\n            updated_expr = updated_expr.replace(f'{idx}', str(numeric_atom))\n\n        self.logger.info(f\"Updated definition: {updated_expr}\")\n        return updated_expr\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_definition_parser/#opulse.operatorplus.operator_definition_parser.OperatorDefinitionParser.__init__","title":"<code>__init__(param_config, logger)</code>","text":"<p>Initializes the OperatorDefinitionParser with given configuration and logger.</p> <p>Parameters:</p> Name Type Description Default <code>param_config</code> <code>ParamConfig</code> <p>A configuration object that contains parameter definitions,                           including operators, atomic values, and symbols.</p> required <code>logger</code> <code>LogConfig</code> <p>A logging configuration object used to log debugging and info messages.</p> required <p>Initializes the grammar dynamically using the <code>param_config</code> and configures the Lark parser.</p> Source code in <code>opulse/operatorplus/operator_definition_parser.py</code> <pre><code>def __init__(self, param_config: ParamConfig, logger: LogConfig):\n    \"\"\"\n    Initializes the OperatorDefinitionParser with given configuration and logger.\n\n    Args:\n        param_config (ParamConfig): A configuration object that contains parameter definitions, \n                                     including operators, atomic values, and symbols.\n        logger (LogConfig): A logging configuration object used to log debugging and info messages.\n\n    Initializes the grammar dynamically using the `param_config` and configures the Lark parser.\n    \"\"\"\n\n    # Store the provided param_config and logger\n    self.param_config = param_config\n    self.logger = logger.get_logger()\n\n    # Dynamically construct the grammar using `param_config`\n    self.grammar = f\"\"\"\n    ?start: rule\n    rule: lhs_expr \"{self.param_config.atoms[\"equal\"]}\" \"{{\" rhs_expr \"}}\"\n    lhs_expr: expr\n    rhs_expr: branch (SEMICOLON branch)* \n    ?branch: if_branch\n        | else_branch\n        | unconditional_branch\n    if_branch: expr \",\" \"if\" condition\n    else_branch: expr \",\" \"else\"\n    unconditional_branch: expr\n    ?condition: or_condition\n    ?or_condition: or_condition \"or\" and_condition    -&gt; or_condition\n                | and_condition\n    ?and_condition: and_condition \"and\" comparison     -&gt; and_condition\n                | comparison\n    ?comparison: \"not\" comparison                      -&gt; not_condition\n            | expr CONDITION_OPERATOR expr          -&gt; comparison\n            | \"{self.param_config.atoms[\"left_parenthesis\"]}\" condition \"{self.param_config.atoms[\"right_parenthesis\"]}\"   -&gt; grouped_condition \n    ?expr: expr OPERATOR term  -&gt; binary_operation\n        | term\n    ?term: factor\n        | OPERATOR factor      -&gt; unary_operation_prefix\n        | factor OPERATOR      -&gt; unary_operation_postfix\n    ?factor: \"{self.param_config.atoms[\"nan\"]}\"          -&gt; no_solution\n        | VARIABLE      -&gt;variable_conversion\n        | INT           -&gt;int_conversion\n        | \"{self.param_config.atoms[\"left_parenthesis\"]}\" expr \"{self.param_config.atoms[\"right_parenthesis\"]}\"\n    OPERATOR: SYMBOL+\n    SYMBOL: \"+\" | \"-\" | \"*\" | \"/\" | \"%\" | /[\\u2200-\\u22FF\\u2A00-\\u2BFF\\u2190-\\u21FF]+/\n    CONDITION_OPERATOR: \"==\" | \"&gt;\" | \"&lt;\" | \"&gt;=\" | \"&lt;=\"| \"!=\"\n    VARIABLE: /[a-zA-Z]/\n    NO_SOLUTION: \"{self.param_config.atoms[\"nan\"]}\"   \n    SEMICOLON: \";\"\n    %import common.INT\n    %import common.WS\n    %ignore WS\n    \"\"\"\n\n    # Logging the generated grammar for debugging\n    self.logger.debug(f\"Generated grammar: {self.grammar}\")\n\n    # Initialize the Lark parser with the dynamically generated grammar\n    self.parser = Lark(self.grammar, start=\"start\")\n\n    # Log that the parser has been successfully initialized\n    self.logger.info(\"OperatorDefinitionParser initialized successfully.\")\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_definition_parser/#opulse.operatorplus.operator_definition_parser.OperatorDefinitionParser.parse_definition","title":"<code>parse_definition(definition)</code>","text":"<p>Parse the given operator definition using the generated grammar.</p> <p>Parameters:</p> Name Type Description Default <code>definition</code> <code>str</code> <p>The operator definition string to be parsed.</p> required <p>Returns:</p> Name Type Description <code>LarkTree</code> <p>A Lark parsing tree representing the parsed definition.</p> <p>Logs the parsing process and any issues during parsing.</p> Source code in <code>opulse/operatorplus/operator_definition_parser.py</code> <pre><code>def parse_definition(self, definition):\n    \"\"\"\n    Parse the given operator definition using the generated grammar.\n\n    Args:\n        definition (str): The operator definition string to be parsed.\n\n    Returns:\n        LarkTree: A Lark parsing tree representing the parsed definition.\n\n    Logs the parsing process and any issues during parsing.\n    \"\"\"\n    try:\n        self.logger.info(f\"Attempting to parse definition: {definition}\")\n        parsed_tree = self.parser.parse(definition)\n        self.logger.info(\"Parsing successful.\")\n        return parsed_tree\n    except Exception as e:\n        self.logger.error(f\"Error while parsing definition: {e}\")\n        raise\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_definition_parser/#opulse.operatorplus.operator_definition_parser.OperatorDefinitionParser.update_definition","title":"<code>update_definition(definition)</code>","text":"<p>Update the operator definition by replacing indexed numeric atoms with their values from <code>param_config</code>.</p> <p>This method performs a replacement in the expression, replacing placeholders such as '0', '1', etc.  with corresponding values from <code>numeric_atoms</code>.</p> <p>Parameters:</p> Name Type Description Default <code>definition</code> <code>str</code> <p>The operator definition to be updated.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>The updated operator definition with numeric atoms replaced.</p> <p>Logs each replacement performed in the update process for debugging.</p> Source code in <code>opulse/operatorplus/operator_definition_parser.py</code> <pre><code>def update_definition(self, definition):\n    \"\"\"\n    Update the operator definition by replacing indexed numeric atoms with their values from `param_config`.\n\n    This method performs a replacement in the expression, replacing placeholders such as '0', '1', etc. \n    with corresponding values from `numeric_atoms`.\n\n    Args:\n        definition (str): The operator definition to be updated.\n\n    Returns:\n        str: The updated operator definition with numeric atoms replaced.\n\n    Logs each replacement performed in the update process for debugging.\n    \"\"\"\n    updated_expr = definition\n\n    self.logger.info(f\"Starting update of definition: {definition}\")\n\n    # Limit to the first 10 numeric atoms for replacement\n    for idx, numeric_atom in enumerate(self.param_config.atoms[\"numeric_atoms\"][:10]):\n        self.logger.debug(f\"Replacing index '{idx}' with numeric atom value '{numeric_atom}'\")\n        updated_expr = updated_expr.replace(f'{idx}', str(numeric_atom))\n\n    self.logger.info(f\"Updated definition: {updated_expr}\")\n    return updated_expr\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_dependency_graph/","title":"Operator dependency graph","text":""},{"location":"Core%20API/operatorplus/operator_dependency_graph/#opulse.operatorplus.operator_dependency_graph.OperatorDependencyGraph","title":"<code>OperatorDependencyGraph</code>","text":"Source code in <code>opulse/operatorplus/operator_dependency_graph.py</code> <pre><code>class OperatorDependencyGraph:\n    def __init__(\n        self,\n        logger: LogConfig,\n        operator_manager: \"OperatorManager\" = None,\n    ):\n        \"\"\"\n        Initializes the OperatorDependencyGraph class.\n\n        Parameters:\n            logger (LogConfig): Logger object for logging operations.\n            operator_manager (OperatorManager, optional): An instance of OperatorManager to manage operators and their dependencies (default: None).\n        \"\"\"\n        self.logger = logger.get_logger()\n        self.operator_manager = operator_manager\n\n    def build_dependency_graph(self):\n        \"\"\"\n        Constructs a directed acyclic graph (DAG) representing the operator dependencies.\n\n        The graph is built based on the operators managed by the OperatorManager, \n        and a topological sorting of the graph is performed.\n\n        Returns: \n            (tuple(dict[int, list[int]], list[int)): A tuple (graph, topo_sorted), where graph is the adjacency list \n                 representation of the DAG and topo_sorted is the topologically sorted list of operators.\n        \"\"\"\n        graph = defaultdict(list)  # Adjacency list to store graph\n        in_degree = defaultdict(int)  # Dictionary to store the in-degree of each node\n\n        self.logger.debug(\"Building the dependency graph.\")\n\n        # Construct the graph\n        for operator_id, operator_info in self.operator_manager.operators.items():\n            if operator_info.dependencies:\n                for dep_id in operator_info.dependencies:\n                    graph[dep_id].append(operator_id)\n                    in_degree[operator_id] += 1\n                    self.logger.debug(f\"Operator {operator_id} depends on {dep_id}.\")\n            else:\n                in_degree[operator_id] = 0  # If no dependencies, set in-degree to 0\n                self.logger.debug(f\"Operator {operator_id} has no dependencies.\")\n\n        # Perform topological sorting\n        topo_sorted = self.topological_sort(graph, in_degree)\n\n        self.logger.info(\"Dependency graph built successfully.\")\n\n        return graph, topo_sorted\n\n    def topological_sort(self, graph, in_degree):\n        \"\"\"\n        Performs a topological sort on the graph using Kahn's algorithm.\n\n        Parameters:\n            graph (dict[int, list[int]]): The adjacency list representation of the graph.\n            in_degree (dict[int, int]): A dictionary that tracks the in-degree of each node.\n\n        Returns: \n            (list[int]): A topologically sorted list of operators.\n\n        Raises:\n            ValueError: If the graph contains a cycle, making topological sorting impossible.\n        \"\"\"\n        queue = deque([node for node in in_degree if in_degree[node] == 0])\n        sorted_order = []\n\n        self.logger.debug(\"Starting topological sorting.\")\n\n        while queue:\n            node = queue.popleft()\n            sorted_order.append(node)\n            self.logger.debug(f\"Node {node} added to the sorted order.\")\n\n            for neighbor in graph[node]:\n                in_degree[neighbor] -= 1\n                if in_degree[neighbor] == 0:\n                    queue.append(neighbor)\n                    self.logger.debug(f\"Node {neighbor} now has in-degree 0 and is added to the queue.\")\n\n        if len(sorted_order) != len(in_degree):\n            self.logger.error(\"Graph contains a cycle, topological sorting cannot be performed.\")\n            raise ValueError(\"Graph has a cycle, cannot perform topological sorting.\")\n\n        self.logger.info(\"Topological sorting completed successfully.\")\n\n        return sorted_order\n\n    def write_dependency_to_jsonl(self, filename=\"data/dependency/operator_dependencies.jsonl\"):\n        \"\"\"\n        Writes the operator dependency graph to a JSONL file.\n\n        Each line in the file represents a node in the graph, with its primitive operator ID \n        and the list of operators derived from it (i.e., its dependencies).\n\n        Parameters:\n            filename (str): The name of the output JSONL file. Default is 'operator_dependencies.jsonl'.\n        \"\"\"\n        self.logger.info(f\"Writing dependency data to {filename}.\")\n\n        # Get the graph and topological sort\n        graph, topo_sorted = self.build_dependency_graph()\n\n        try:\n            with open(filename, 'w') as f:\n                for node in topo_sorted:\n                    node_info = {\n                        \"primitive_op_id\": node,\n                        \"derived_op_id_list\": graph[node]  # List of dependent operators\n                    }\n                    f.write(json.dumps(node_info) + \"\\n\")\n                    self.logger.debug(f\"Written node {node} to {filename}.\")\n\n            self.logger.info(f\"Dependency data successfully written to {filename}.\")\n\n        except Exception as e:\n            self.logger.error(f\"Error writing to file {filename}: {e}\")\n\n    def visualize_dependency_graph(self):\n        \"\"\"\n        Visualizes the operator dependency graph using pyvis.\n\n        This method generates an interactive graph that can be explored in a web browser.\n        The graph shows the operators and their dependencies, where nodes represent \n        operators and edges represent dependencies between them.\n\n        The graph is saved as an HTML file for viewing.\n        \"\"\"\n        self.logger.info(\"Visualizing the operator dependency graph.\")\n\n        # Create an interactive network graph\n        net = Network(directed=True)\n\n        # Add nodes and edges to the graph\n        for operator_id, operator_info in self.operator_manager.operators.items():\n            label = f\"{operator_id}:{operator_info.symbol}\"  # Combine operator ID and symbol\n            net.add_node(operator_id, label=label)\n            if operator_info.dependencies:\n                for dep_id in operator_info.dependencies:\n                    net.add_edge(dep_id, operator_id)\n                    self.logger.debug(f\"Edge added between {dep_id} and {operator_id}.\")\n\n        net.force_atlas_2based()  # Enable the ForceAtlas2 layout engine, but disable continuous updates\n        net.physics = False  # Disable physics engine for static layout\n\n        # Save the graph as an HTML file\n        try:\n            net.show(\"operator_dependency_graph.html\", notebook=False)\n            self.logger.info(\"Dependency graph saved as 'operator_dependency_graph.html'.\")\n        except Exception as e:\n            self.logger.error(f\"Error visualizing the dependency graph: {e}\")\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_dependency_graph/#opulse.operatorplus.operator_dependency_graph.OperatorDependencyGraph.__init__","title":"<code>__init__(logger, operator_manager=None)</code>","text":"<p>Initializes the OperatorDependencyGraph class.</p> <p>Parameters:</p> Name Type Description Default <code>logger</code> <code>LogConfig</code> <p>Logger object for logging operations.</p> required <code>operator_manager</code> <code>OperatorManager</code> <p>An instance of OperatorManager to manage operators and their dependencies (default: None).</p> <code>None</code> Source code in <code>opulse/operatorplus/operator_dependency_graph.py</code> <pre><code>def __init__(\n    self,\n    logger: LogConfig,\n    operator_manager: \"OperatorManager\" = None,\n):\n    \"\"\"\n    Initializes the OperatorDependencyGraph class.\n\n    Parameters:\n        logger (LogConfig): Logger object for logging operations.\n        operator_manager (OperatorManager, optional): An instance of OperatorManager to manage operators and their dependencies (default: None).\n    \"\"\"\n    self.logger = logger.get_logger()\n    self.operator_manager = operator_manager\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_dependency_graph/#opulse.operatorplus.operator_dependency_graph.OperatorDependencyGraph.build_dependency_graph","title":"<code>build_dependency_graph()</code>","text":"<p>Constructs a directed acyclic graph (DAG) representing the operator dependencies.</p> <p>The graph is built based on the operators managed by the OperatorManager,  and a topological sorting of the graph is performed.</p> <p>Returns:</p> Type Description <code>tuple(dict[int, list[int]], list[int)</code> <p>A tuple (graph, topo_sorted), where graph is the adjacency list   representation of the DAG and topo_sorted is the topologically sorted list of operators.</p> Source code in <code>opulse/operatorplus/operator_dependency_graph.py</code> <pre><code>def build_dependency_graph(self):\n    \"\"\"\n    Constructs a directed acyclic graph (DAG) representing the operator dependencies.\n\n    The graph is built based on the operators managed by the OperatorManager, \n    and a topological sorting of the graph is performed.\n\n    Returns: \n        (tuple(dict[int, list[int]], list[int)): A tuple (graph, topo_sorted), where graph is the adjacency list \n             representation of the DAG and topo_sorted is the topologically sorted list of operators.\n    \"\"\"\n    graph = defaultdict(list)  # Adjacency list to store graph\n    in_degree = defaultdict(int)  # Dictionary to store the in-degree of each node\n\n    self.logger.debug(\"Building the dependency graph.\")\n\n    # Construct the graph\n    for operator_id, operator_info in self.operator_manager.operators.items():\n        if operator_info.dependencies:\n            for dep_id in operator_info.dependencies:\n                graph[dep_id].append(operator_id)\n                in_degree[operator_id] += 1\n                self.logger.debug(f\"Operator {operator_id} depends on {dep_id}.\")\n        else:\n            in_degree[operator_id] = 0  # If no dependencies, set in-degree to 0\n            self.logger.debug(f\"Operator {operator_id} has no dependencies.\")\n\n    # Perform topological sorting\n    topo_sorted = self.topological_sort(graph, in_degree)\n\n    self.logger.info(\"Dependency graph built successfully.\")\n\n    return graph, topo_sorted\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_dependency_graph/#opulse.operatorplus.operator_dependency_graph.OperatorDependencyGraph.topological_sort","title":"<code>topological_sort(graph, in_degree)</code>","text":"<p>Performs a topological sort on the graph using Kahn's algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>dict[int, list[int]]</code> <p>The adjacency list representation of the graph.</p> required <code>in_degree</code> <code>dict[int, int]</code> <p>A dictionary that tracks the in-degree of each node.</p> required <p>Returns:</p> Type Description <code>list[int]</code> <p>A topologically sorted list of operators.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the graph contains a cycle, making topological sorting impossible.</p> Source code in <code>opulse/operatorplus/operator_dependency_graph.py</code> <pre><code>def topological_sort(self, graph, in_degree):\n    \"\"\"\n    Performs a topological sort on the graph using Kahn's algorithm.\n\n    Parameters:\n        graph (dict[int, list[int]]): The adjacency list representation of the graph.\n        in_degree (dict[int, int]): A dictionary that tracks the in-degree of each node.\n\n    Returns: \n        (list[int]): A topologically sorted list of operators.\n\n    Raises:\n        ValueError: If the graph contains a cycle, making topological sorting impossible.\n    \"\"\"\n    queue = deque([node for node in in_degree if in_degree[node] == 0])\n    sorted_order = []\n\n    self.logger.debug(\"Starting topological sorting.\")\n\n    while queue:\n        node = queue.popleft()\n        sorted_order.append(node)\n        self.logger.debug(f\"Node {node} added to the sorted order.\")\n\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n                self.logger.debug(f\"Node {neighbor} now has in-degree 0 and is added to the queue.\")\n\n    if len(sorted_order) != len(in_degree):\n        self.logger.error(\"Graph contains a cycle, topological sorting cannot be performed.\")\n        raise ValueError(\"Graph has a cycle, cannot perform topological sorting.\")\n\n    self.logger.info(\"Topological sorting completed successfully.\")\n\n    return sorted_order\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_dependency_graph/#opulse.operatorplus.operator_dependency_graph.OperatorDependencyGraph.visualize_dependency_graph","title":"<code>visualize_dependency_graph()</code>","text":"<p>Visualizes the operator dependency graph using pyvis.</p> <p>This method generates an interactive graph that can be explored in a web browser. The graph shows the operators and their dependencies, where nodes represent  operators and edges represent dependencies between them.</p> <p>The graph is saved as an HTML file for viewing.</p> Source code in <code>opulse/operatorplus/operator_dependency_graph.py</code> <pre><code>def visualize_dependency_graph(self):\n    \"\"\"\n    Visualizes the operator dependency graph using pyvis.\n\n    This method generates an interactive graph that can be explored in a web browser.\n    The graph shows the operators and their dependencies, where nodes represent \n    operators and edges represent dependencies between them.\n\n    The graph is saved as an HTML file for viewing.\n    \"\"\"\n    self.logger.info(\"Visualizing the operator dependency graph.\")\n\n    # Create an interactive network graph\n    net = Network(directed=True)\n\n    # Add nodes and edges to the graph\n    for operator_id, operator_info in self.operator_manager.operators.items():\n        label = f\"{operator_id}:{operator_info.symbol}\"  # Combine operator ID and symbol\n        net.add_node(operator_id, label=label)\n        if operator_info.dependencies:\n            for dep_id in operator_info.dependencies:\n                net.add_edge(dep_id, operator_id)\n                self.logger.debug(f\"Edge added between {dep_id} and {operator_id}.\")\n\n    net.force_atlas_2based()  # Enable the ForceAtlas2 layout engine, but disable continuous updates\n    net.physics = False  # Disable physics engine for static layout\n\n    # Save the graph as an HTML file\n    try:\n        net.show(\"operator_dependency_graph.html\", notebook=False)\n        self.logger.info(\"Dependency graph saved as 'operator_dependency_graph.html'.\")\n    except Exception as e:\n        self.logger.error(f\"Error visualizing the dependency graph: {e}\")\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_dependency_graph/#opulse.operatorplus.operator_dependency_graph.OperatorDependencyGraph.write_dependency_to_jsonl","title":"<code>write_dependency_to_jsonl(filename='data/dependency/operator_dependencies.jsonl')</code>","text":"<p>Writes the operator dependency graph to a JSONL file.</p> <p>Each line in the file represents a node in the graph, with its primitive operator ID  and the list of operators derived from it (i.e., its dependencies).</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the output JSONL file. Default is 'operator_dependencies.jsonl'.</p> <code>'data/dependency/operator_dependencies.jsonl'</code> Source code in <code>opulse/operatorplus/operator_dependency_graph.py</code> <pre><code>def write_dependency_to_jsonl(self, filename=\"data/dependency/operator_dependencies.jsonl\"):\n    \"\"\"\n    Writes the operator dependency graph to a JSONL file.\n\n    Each line in the file represents a node in the graph, with its primitive operator ID \n    and the list of operators derived from it (i.e., its dependencies).\n\n    Parameters:\n        filename (str): The name of the output JSONL file. Default is 'operator_dependencies.jsonl'.\n    \"\"\"\n    self.logger.info(f\"Writing dependency data to {filename}.\")\n\n    # Get the graph and topological sort\n    graph, topo_sorted = self.build_dependency_graph()\n\n    try:\n        with open(filename, 'w') as f:\n            for node in topo_sorted:\n                node_info = {\n                    \"primitive_op_id\": node,\n                    \"derived_op_id_list\": graph[node]  # List of dependent operators\n                }\n                f.write(json.dumps(node_info) + \"\\n\")\n                self.logger.debug(f\"Written node {node} to {filename}.\")\n\n        self.logger.info(f\"Dependency data successfully written to {filename}.\")\n\n    except Exception as e:\n        self.logger.error(f\"Error writing to file {filename}: {e}\")\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_generator/","title":"Operator generator","text":""},{"location":"Core%20API/operatorplus/operator_generator/#opulse.operatorplus.operator_generator.OperatorGenerator","title":"<code>OperatorGenerator</code>","text":"Source code in <code>opulse/operatorplus/operator_generator.py</code> <pre><code>class OperatorGenerator:\n    def __init__(\n        self,\n        param_config: ParamConfig,\n        logger: LogConfig,\n        condition_generator: ConditionGenerator,\n        expr_generator: ExpressionGenerator,\n        operator_manager: OperatorManager,\n    ):\n        \"\"\"\n        Initialize the OperatorGenerator.\n\n        Parameters:\n            param_config (ParamConfig): Configuration object containing parameters like symbols and operator details.\n            logger (LogConfig): Logger configuration to handle logging functionality.\n            condition_generator (ConditionGenerator): A generator responsible for producing conditions.\n            expr_generator (ExpressionGenerator): A generator responsible for producing expressions.\n            operator_generator (OperatorManager): Manages operator-related functionality.\n\n        Attributes:\n            param_config (ParamConfig): Configuration object that holds various parameters.\n            logger (Logger): Logger instance used for logging debug and info messages.\n            standard_symbols (list): A list of standard operator symbols.\n            unicode_symbols (list): A list of Unicode operator symbols.\n            valid_symbols (list): A combined list of valid operator symbols (standard + Unicode).\n            condition_generator (ConditionGenerator): The generator used to generate conditions.\n            expr_generator (ExpressionGenerator): The generator used to generate expressions.\n            operator_manager (OperatorManager): Manages operators for the generator.\n            unary_variables (list): List of variables used in unary operations.\n            binary_variables (list): List of variables used in binary operations.\n            max_base (int): Maximum base value used in the generation process.\n            operator_symbol_min_len (int): Minimum length for operator symbols.\n            operator_symbol_max_len (int): Maximum length for operator symbols.\n            max_if_branches (int): Maximum number of branches in conditional expressions.\n        \"\"\"\n        self.param_config = param_config\n        self.logger = logger.get_logger()  # Get logger instance for logging\n        self.standard_symbols = self.param_config.get(\"basic_operator_symbols\")\n        self.unicode_symbols = self.get_unicode_symbols()\n        self.valid_symbols = self.standard_symbols + self.unicode_symbols\n        self.condition_generator = condition_generator  # Condition generator instance\n        self.expr_generator = expr_generator  # Expression generator instance\n        self.operator_manager = operator_manager  # Operator manager instance\n        self.unary_variables = [self.param_config.atoms['left_operand']]\n        self.binary_variables = [self.param_config.atoms['left_operand'], self.param_config.atoms['right_operand']]\n        self.max_base = self.param_config.get(\"max_base\")\n        self.operator_symbol_min_len = self.param_config.get(\"operator_symbol_min_len\")\n        self.operator_symbol_max_len = self.param_config.get(\"operator_symbol_max_len\")\n        self.max_if_branches = self.param_config.get(\"max_if_branches\")\n\n        # Log initialization details\n        self.logger.info(\"OperatorGenerator initialized with the following configuration:\")\n        self.logger.debug(f\"Standard symbols: {self.standard_symbols}\")\n        self.logger.debug(f\"Unicode symbols: {self.unicode_symbols}\")\n        self.logger.debug(f\"Valid symbols: {self.valid_symbols}\")\n        self.logger.debug(f\"Unary variables: {self.unary_variables}\")\n        self.logger.debug(f\"Binary variables: {self.binary_variables}\")\n        self.logger.debug(f\"Max base: {self.max_base}\")\n        self.logger.debug(f\"Operator symbol min length: {self.operator_symbol_min_len}\")\n        self.logger.debug(f\"Operator symbol max length: {self.operator_symbol_max_len}\")\n        self.logger.debug(f\"Max if branches: {self.max_if_branches}\")\n\n    def get_unicode_symbols(self):\n        \"\"\"\n        Collects valid Unicode operator symbols from predefined ranges.\n\n        This method retrieves symbols from several mathematical and arrow ranges in Unicode:\n        - Mathematical Operators (U+2200 to U+22FF)\n        - Supplemental Mathematical Operators (U+2A00 to U+2AFF)\n        - Arrows (U+2190 to U+21FF)\n\n        Returns:\n            list: A list of valid Unicode operator symbols.\n        \"\"\"\n        self.logger.info(\"Collecting Unicode symbols from predefined ranges.\")\n        unicode_ranges = [\n            (0x2200, 0x22FF),  # Mathematical Operators\n            (0x2A00, 0x2AFF),  # Supplemental Mathematical Operators\n            (0x2190, 0x21FF),  # Arrows\n        ]\n\n        symbols = []\n\n        for start, end in unicode_ranges:\n            for codepoint in range(start, end + 1):\n                char = chr(codepoint)\n                symbols.append(char)\n\n        self.logger.debug(f\"Collected {len(symbols)} Unicode symbols.\")\n        return symbols\n\n    def random_operator(self, existing_symbols: List[str]):\n        \"\"\"\n        Generates a random operator string composed of one or more valid symbols.\n\n        This method generates a random operator string with a length between \n        `operator_symbol_min_len` and `operator_symbol_max_len`, ensuring that \n        the generated operator does not already exist in the list of `existing_symbols`.\n\n        Parameters:\n            existing_symbols (List[str]): A list of currently existing operator symbols.\n                                            The new symbol must not be in this list.\n\n        Returns:\n            str: The generated random operator string that is unique and within the specified length range.\n        \"\"\"\n        self.logger.info(\"Generating a random operator string.\")\n\n        # Loop until a unique operator is generated\n        while True:\n            # Randomly choose a length for the operator within the specified range\n            length = random.randint(self.operator_symbol_min_len, self.operator_symbol_max_len)\n\n            # Generate the new symbol by randomly picking characters from valid symbols\n            new_symbol = \"\".join(random.choice(self.valid_symbols) for _ in range(length))\n\n            # Check if the generated symbol is unique (not in existing_symbols)\n            if new_symbol not in existing_symbols:\n                self.logger.debug(f\"Generated new operator symbol: {new_symbol} with length {length}.\")\n                return new_symbol\n            else:\n                self.logger.debug(f\"Generated operator {new_symbol} already exists. Retrying...\")\n\n    def random_operator_type_and_position(self):\n        \"\"\"\n        Generates a random operator type and its position (if applicable).\n\n        This method randomly selects an operator type, either \"unary\" or \"binary\".\n        If the type is \"unary\", it also randomly chooses its position, either \"prefix\" or \"postfix\".\n        For \"binary\" operators, the position is not applicable (set to None).\n\n        Returns:\n            tuple: A tuple containing the operator type and its position.\n                If the operator type is \"unary\", the position is either \"prefix\" or \"postfix\".\n                If the operator type is \"binary\", the position is None.\n        \"\"\"\n        self.logger.info(\"Generating random operator type and position.\")\n\n        # Randomly select the operator type\n        op_type = random.choice([\"unary\", \"binary\"])\n\n        # Initialize unary_position as None\n        unary_position = None\n\n        # If the operator type is \"unary\", randomly choose its position\n        if op_type == \"unary\":\n            unary_position = random.choice([\"prefix\", \"postfix\"])\n\n        # Log the final operator type and position\n        self.logger.info(f\"Operator type: {op_type}, Position: {unary_position if unary_position else 'None'}\")\n\n        return op_type, unary_position\n\n    def generate_base_operators(self):\n        \"\"\"\n        Generates unary prefix operators for each base from 2 to self.max_base.\n\n        This method creates a unary prefix operator for each base in the range from 2 to `self.max_base`.\n        For each base, a random operator symbol is generated, and the operator is added to the operator manager.\n        The operator is stored with additional properties, such as its base number and the unary position.\n\n        Returns:\n            None\n        \"\"\"\n        self.logger.info(\"Starting to generate base operators for each base from 2 to max_base.\")\n\n        # Iterate through the range of bases from 2 to max_base\n        for n in range(2, self.max_base + 1):\n            self.logger.debug(f\"Generating operator for base {n}.\")\n\n            # Get existing operator symbols to avoid duplication\n            existing_symbols = self.operator_manager.get_operator_symbols()\n\n            # Generate a random operator symbol that isn't already used\n            op_symbol = self.random_operator(existing_symbols)\n\n            # Define operator type and position\n            op_type = \"unary\"\n            op_position = \"prefix\"\n\n            # Construct the operator data\n            operator_data = {\n                \"id\": None,  \n                \"symbol\": op_symbol,\n                \"n_ary\": 1,  # Unary operator\n                \"unary_position\": op_position if op_type == \"unary\" else None,\n                \"is_base\": n,  # Base number\n                \"definition\": None,\n                \"definition_type\": None,\n                \"priority\": None,\n                \"associativity_direction\": None,\n                \"n_order\": None,\n                \"op_compute_func\": None,\n                \"op_count_func\": None,\n                \"properties\": None,\n                \"dependencies\": None,\n                \"is_temporary\": False,\n            }\n\n            # Add the generated operator to the operator manager\n            self.operator_manager.add_operator(operator_data)\n\n            self.logger.info(f\"Base operator for base {n} with symbol '{op_symbol}' added successfully.\")\n\n        self.logger.info(\"Base operator generation completed.\")\n\n    def generate_lhs(self, op_symbol, op_type, op_position):\n        \"\"\"\n        Generates the left-hand side (LHS) of an expression based on the operator type and position.\n\n        This method constructs the left-hand side of an expression depending on the type of operator \n        (unary or binary) and its position (prefix or postfix). It uses the operator symbol and operands \n        defined in the configuration.\n\n        Parameters:\n            op_symbol (str): The operator symbol to be used in the expression (e.g., \"+\", \"\u2295\").\n            op_type (str): The type of the operator, either \"unary\" or \"binary\".\n            op_position (str): The position of the operator, either \"prefix\" or \"postfix\" (only for unary operators).\n\n        Returns:\n            str: The generated left-hand side expression as a string.\n\n        Raises:\n            ValueError: If the operator type is neither \"unary\" nor \"binary\".\n        \"\"\"\n\n        self.logger.debug(f\"Generating LHS for operator '{op_symbol}', type '{op_type}', position '{op_position}'.\")\n\n        # Handle the case for unary operators\n        if op_type == \"unary\":\n            if op_position == \"prefix\":\n                lhs = f\"{op_symbol}{self.param_config.atoms['left_operand']}\"  # e.g., \"-a\"\n            elif op_position == \"postfix\":\n                lhs = f\"{self.param_config.atoms['left_operand']}{op_symbol}\"  # e.g., \"a-\"\n            else:\n                self.logger.error(f\"Invalid position '{op_position}' for unary operator.\")\n                raise ValueError(f\"Invalid position '{op_position}' for unary operator.\")\n\n        # Handle the case for binary operators\n        elif op_type == \"binary\":\n            lhs = f\"{self.param_config.atoms['left_operand']}{op_symbol}{self.param_config.atoms['right_operand']}\"  # e.g., 'a + b', 'a\u2295b'\n        else:\n            self.logger.error(f\"Invalid operator type '{op_type}' received.\")\n            raise ValueError(f\"Operator type must be either 'unary' or 'binary'.\")\n\n        self.logger.info(f\"LHS generated: {lhs}\")\n        return lhs\n\n    def generate_branches(self):\n        \"\"\"\n        Generates a list of conditional branches for an expression, including 'if' and 'else' branches.\n\n        This method generates a random number of 'if' branches based on the maximum allowed number \n        of branches (`max_if_branches`), each containing a randomly generated expression and a condition.\n        Additionally, an 'else' branch is added with a randomly generated expression.\n\n        The format of each branch is a tuple containing the expression and the corresponding condition.\n\n        Returns:\n            list: A list of tuples, each containing a generated expression and its associated condition.\n            Each tuple is in the form (expression, condition).\n        \"\"\"\n        self.logger.debug(\"Generating branches for conditional expressions.\")\n\n        num_if_branches = random.randint(1, self.max_if_branches)\n        branches = []\n\n        self.logger.info(f\"Generating {num_if_branches} 'if' branches.\")\n\n        # Generate the specified number of 'if' branches\n        for i in range(num_if_branches):\n            expr = self.expr_generator.create_expression_str(atom_choice=\"variable_and_number\")\n            condition = self.condition_generator.generate_condition_expr()\n            branches.append((expr, f\"if {condition}\"))\n\n            self.logger.debug(f\"Generated 'if' branch {i+1}: {expr} with condition {condition}\")\n\n        # Add the required 'else' branch\n        else_expr = self.expr_generator.create_expression_str(atom_choice=\"variable_and_number\")  # Generate expression for 'else'\n        branches.append((else_expr, \"else\"))\n\n        self.logger.debug(f\"Generated 'else' branch: {else_expr}\")\n        self.logger.info(f\"Total branches generated: {len(branches)}.\")\n\n        return branches\n\n    def generate_recursive_call(self, op_symbol, op_type, op_position):\n        \"\"\"\n        Generates recursive expressions for binary and unary operators.\n\n        This function creates recursive calls for both unary and binary operators\n        based on the following rules:\n\n        For binary operators:\n            - If b == 0, generates a basic expression involving a and b.\n            - If b &gt; 0, generates an expression involving a and (b-1), where the expression on the right side must include (b-1).\n            - If b &lt; 0, generates an expression involving a and (b+1), where the expression on the right side must include (b+1).\n\n        For unary operators:\n            - If a == 0, randomly generates a number.\n            - If a &gt; 0, generates an expression solely involving (a-1), with its own symbol, and only related to (a-1).\n            - If a &lt; 0, generates an expression solely involving (a+1), with its own symbol, and only related to (a+1).\n\n        Parameters:\n        op_symbol (str): The operator symbol (e.g., '+', '-', '*', etc.) to be used in the expressions.\n        op_type (str): The type of the operator. Can be either 'unary' or 'binary'.\n        op_position (str): The position of the unary operator. Can be either 'prefix' or 'postfix' (relevant only for unary operators).\n\n        Returns:\n        str: A string representing the recursive expression for the operator, with conditions based on the values of 'a' and 'b'.\n\n        Raises:\n        ValueError: If the provided operator type is neither 'unary' nor 'binary'.\n        \"\"\"\n        if op_type == \"binary\":\n            # The recursive expression for generating binary operators with operands a and b.\n            self.expr_generator.set_variables([self.param_config.atoms['left_operand'], self.param_config.atoms['right_operand']])\n\n            # If b == 0, generate a basic expression with a and b.\n            expr_base = self.expr_generator.create_expression_str(atom_choice=\"variable_and_number\")\n\n            # If b &gt; 0, generate an expression involving a and (b-1) (note that the expression on the right side must include b-1).\n            recursive_variable = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['right_operand']}-1{self.param_config.atoms['right_parenthesis']}{self.param_config.atoms['right_parenthesis']}\"\n            self.expr_generator.set_variables([self.param_config.atoms['left_operand'], self.param_config.atoms['right_operand'], recursive_variable])\n            recursive_expr_1 = \"\"\n            while recursive_variable not in recursive_expr_1:\n                recursive_expr_1 = self.expr_generator.create_expression_str(atom_choice=\"variable_and_number\")\n\n            # If b &lt; 0, generate an expression involving a and (b+1).\n            recursive_variable = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['right_operand']}+1{self.param_config.atoms['right_parenthesis']}{self.param_config.atoms['right_parenthesis']}\"\n            self.expr_generator.set_variables([self.param_config.atoms['left_operand'], self.param_config.atoms['right_operand'], recursive_variable])\n            recursive_expr_2 = \"\"\n            while recursive_variable not in recursive_expr_2:\n                recursive_expr_2 = self.expr_generator.create_expression_str(atom_choice=\"variable_and_number\")\n\n            return f\"{expr_base}, if {self.param_config.atoms['right_operand']} == 0 ; {recursive_expr_1}, if {self.param_config.atoms['right_operand']} &gt; 0 ; {recursive_expr_2}, else\"\n\n        elif op_type == \"unary\":\n            # For unary operators, generate a recursive expression with a single parameter.\n            self.expr_generator.set_variables([self.param_config.atoms['left_operand']])\n\n            # If a == 0, randomly generate a number.\n            expr_base = self.expr_generator.create_expression_str(atom_choice=\"number\")\n\n            # If a &gt; 0, generate an expression solely involving (a-1), with its own symbol, and only related to (a-1).\n            if op_position == \"prefix\":\n                recursive_variable = f\"{op_symbol}({self.param_config.atoms['left_operand']}-1)\"\n            elif op_position == \"postfix\":\n                recursive_variable = f\"({self.param_config.atoms['left_operand']}-1){op_symbol}\"\n            self.expr_generator.set_variables([self.param_config.atoms['left_operand'], recursive_variable])\n            recursive_expr_1 = \"\"\n            while recursive_variable not in recursive_expr_1:\n                recursive_expr_1 = self.expr_generator.create_expression_str(atom_choice=\"variable_and_number\")\n\n            # If a &lt; 0, generate an expression solely involving (a+1), with its own symbol, and only related to (a+1).\n            if op_position == \"prefix\":\n                recursive_variable = f\"{op_symbol}({self.param_config.atoms['left_operand']}+1)\"\n            elif op_position == \"postfix\":\n                recursive_variable = f\"({self.param_config.atoms['left_operand']}+1){op_symbol}\"\n            self.expr_generator.set_variables([self.param_config.atoms['left_operand'], recursive_variable])\n            recursive_expr_2 = \"\"\n            while recursive_variable not in recursive_expr_2:\n                recursive_expr_2 = self.expr_generator.create_expression_str(atom_choice=\"variable_and_number\")\n\n            return f\"{expr_base}, if {self.param_config.atoms['left_operand']} == 0 ; {recursive_expr_1}, if {self.param_config.atoms['left_operand']} &gt; 0 ; {recursive_expr_2}, else\"\n\n        else:\n            raise ValueError(\"Unsupported operator type. Only 'unary' and 'binary' are supported.\")\n\n    def generate_definition(self, op_symbol, op_type, op_position, choice):\n        \"\"\"\n        Generates a complete operator definition rule based on the provided parameters.\n\n        This method constructs the definition of an operator, which can vary depending on the \n        `choice` parameter. It can generate a simple expression, a recursive call, or a branching \n        expression with conditional logic.\n\n        The definition can be generated in three different forms:\n            1. **Simple Definition**: A basic operator definition without any conditional branching.\n            2. **Recursive Definition**: A definition where the operator is recursively applied, based on the operator type (unary or binary).\n            3. **Branch Definition**: A definition with multiple branches, using conditional logic (if-else statements) to determine the behavior.\n\n        Parameters:\n            op_symbol (str): The symbol representing the operator (e.g., '+', '-', '*', etc.).\n            op_type (str): The type of the operator, either 'unary' (one operand) or 'binary' (two operands).\n            op_position (str): The position of the unary operator, either 'prefix' or 'postfix'.\n            choice (str): A string that determines the type of operator definition to generate:\n                        - \"simple_definition\": generates a simple expression without branching.\n                        - \"recursive_definition\": generates an expression with a recursive call.\n                        - \"branch_definition\": generates an expression with branching logic (if-else).\n\n        Returns:\n            str: A string representing the operator definition. The content of the string depends on the `choice` parameter:\n                - For \"simple_definition\", a simple expression is returned.\n                - For \"recursive_definition\", a recursive call expression is returned.\n                - For \"branch_definition\", an expression with conditional branches is returned.\n\n        Raises:\n            ValueError: If the `choice` parameter is not one of the recognized options (\"simple_definition\", \"recursive_definition\", \"branch_definition\").\n        \"\"\"\n        self.logger.debug(f\"Generating definition for operator: {op_symbol}, Type: {op_type}, Position: {op_position}, Choice: {choice}\")\n\n        # Generate the left-hand side of the operator definition\n        lhs = self.generate_lhs(op_symbol, op_type, op_position)\n\n        if choice == \"simple_definition\":\n            # Simple expression, no branches\n            expr = self.expr_generator.create_expression_str(atom_choice=\"variable_and_number\")\n            self.logger.info(f\"Simple definition generated: {lhs} {self.param_config.atoms['equal']} {{ {expr} }}\")\n            return f\"{lhs} {self.param_config.atoms['equal']} {{ {expr} }}\"\n\n        elif choice == \"recursive_definition\":\n            recursive_call = self.generate_recursive_call(\n                op_symbol, op_type, op_position\n            )\n            return f\"{lhs} = {{ {recursive_call} }}\"\n\n        elif choice == \"branch_definition\":\n            # Generate branches with conditions\n            branches = self.generate_branches()\n\n            # Build the branch strings\n            branch_strings = []\n            for expr, condition in branches:\n                if condition.startswith(\"if\"):\n                    branch_strings.append(f\"{expr} , {condition}\")\n                elif condition == \"else\":\n                    branch_strings.append(f\"{expr}, else\")\n\n            # Join branches with semicolons\n            rhs = \" ; \".join(branch_strings)\n            definition = f\"{lhs} {self.param_config.atoms['equal']} {{ {rhs} }}\"\n            self.logger.info(f\"Branch definition generated: {definition}\")\n            return definition\n\n        else:\n            self.logger.warning(f\"Unknown choice: {choice}. Returning None.\")\n            return None\n\n    def generate_operator_data_by_definition(self, choice):\n        \"\"\"\n        Generates operator data based on a specified operator definition type.\n\n        This method generates an operator symbol, determines its type (unary or binary), and sets\n        its position (prefix or postfix). Then, it creates an operator definition based on the given\n        `choice` parameter, which determines whether the operator definition is simple or involves \n        conditional branching. The generated operator data includes the operator's symbol, type, \n        position, and its corresponding definition.\n\n        Parameters:\n            choice (str): The type of operator definition to generate. \n                        Can be one of the following:\n                        - \"simple_definition\": Generates a basic operator expression without branching.\n                        - \"branch_definition\": Generates an operator definition with conditional branching (if-else).\n                        - \"recursive_definition\": generates an expression with a recursive call.\n\n        Returns:\n            dict: A dictionary containing the generated operator data.\n        \"\"\"\n        self.logger.debug(f\"Generating operator data by definition with choice: {choice}\")\n\n        # Generate a random operator symbol that doesn't already exist in the operator manager\n        existing_symbols = self.operator_manager.get_operator_symbols()\n        op_symbol = self.random_operator(existing_symbols)\n        self.logger.debug(f\"Generated operator symbol: {op_symbol}\")\n\n        # Determine the type (unary or binary) and position (prefix or postfix) of the operator\n        op_type, op_position = self.random_operator_type_and_position()\n        self.logger.debug(f\"Operator type: {op_type}, Operator position: {op_position}\")\n\n        # Choose the appropriate variables based on the operator type\n        variables = self.unary_variables if op_type == \"unary\" else self.binary_variables\n        self.condition_generator.set_variables(variables)\n        self.expr_generator.set_variables(variables)\n        self.logger.debug(f\"Operator variables set to: {variables}\")\n\n        # Generate the operator definition based on the choice (simple or branch definition)\n        definition = self.generate_definition(op_symbol, op_type, op_position, choice)\n        self.logger.debug(f\"Generated operator definition: {definition}\")\n\n        # Construct the operator data dictionary\n        operator_data = {\n            \"id\": None,  # The id will be assigned by OperatorManager\n            \"symbol\": op_symbol,\n            \"n_ary\": 1 if op_type == \"unary\" else 2,  # Unary operators have 1 operand, binary have 2\n            \"unary_position\": op_position if op_type == \"unary\" else None,\n            \"is_base\": None,  # Not a base operator for now\n            \"definition\": definition,\n            \"definition_type\": choice,  # The type of definition generated (simple or branch)\n            \"priority\": None,  # Priority is not assigned for now\n            \"associativity_direction\": None,  # Not assigned for now\n            \"n_order\": None,  # Dependency order will be handled by OperatorManager\n            \"op_compute_func\": None,  # Compute function will be defined by the parser\n            \"op_count_func\": None,  # Count function will be defined by the parser\n            \"properties\": None,  # Properties are not assigned for now\n            \"dependencies\": None,  # Dependencies are not yet defined\n            \"is_temporary\": True,  # Indicates that this operator is temporary\n        }\n\n        self.logger.info(f\"Generated operator data: {operator_data}\")\n        return operator_data\n\n    def get_random_recursive_call_operator(self) -&gt; OperatorInfo:\n        \"\"\"\n        Selects a random operator that supports recursion from the operator manager.\n\n        This method filters the operators managed by the `operator_manager` to find those\n        that have recursion enabled (i.e., `is_recursion_enabled` is True). It then selects\n        a random operator from the filtered list and returns the corresponding `OperatorInfo` object.\n\n        Raises:\n            ValueError: If no operators are available in the operator manager.\n            ValueError: If no operators with recursion enabled are available.\n\n        Returns:\n            OperatorInfo: The selected operator's `OperatorInfo` object, including its ID, symbol, and other properties.\n        \"\"\"\n        self.logger.debug(\"Attempting to get a random recursive call operator.\")\n\n        # Check if there are any operators available in the operator manager\n        if not self.operator_manager.operators:\n            self.logger.error(\"No operators available in the operator manager.\")\n            raise ValueError(\"No operators available.\")\n\n        # Filter operators that have recursion enabled\n        recursive_operators = [\n            (operator_id, operator_info)\n            for operator_id, operator_info in self.operator_manager.operators.items()\n            if operator_info.is_recursion_enabled\n        ]\n\n        self.logger.debug(f\"Filtered operators with recursion enabled: {recursive_operators}\")\n\n        # If no operators with recursion are available, raise an exception\n        if not recursive_operators:\n            self.logger.error(\"No operators with recursion enabled.\")\n            raise ValueError(\"No operators with recursion enabled.\")\n\n        # Randomly select one operator from the filtered list\n        _, operator_info = random.choice(recursive_operators)\n        self.logger.debug(f\"Selected operator: {operator_info}\")\n\n        # Return the `OperatorInfo` instance instead of a tuple\n        self.logger.info(f\"Random recursive call operator selected: {operator_info}\")\n        return operator_info  # Returning an instance of OperatorInfo\n\n    def set_bit_if_not_set(self, called_operator_info, bit_position):\n        \"\"\"\n        Sets a specific bit in the `recursive_used_cases` attribute of the given operator\n        if that bit is not already set. The method also checks the number of recursive cases \n        used and disables recursion if certain conditions are met.\n\n        This function performs the following actions:\n        1. Checks if the bit at `bit_position` is 0.\n        2. If it is 0, sets the bit to 1.\n        3. If the operator is unary (n_ary == 1) and all bits in the first 2 positions are set, recursion is disabled.\n        4. If the operator is binary (n_ary == 2) and all bits in the first 8 positions are set, recursion is disabled.\n\n        Args:\n            called_operator_info (OperatorInfo): The operator whose `recursive_used_cases` attribute is to be modified.\n            bit_position (int): The bit position to check and set.\n\n        Returns:\n            bool: Returns `True` if the bit was successfully set, `False` if the bit was already set.\n\n        \"\"\"\n        self.logger.debug(f\"Checking bit position {bit_position} in operator {called_operator_info.symbol}.\")\n\n        # Check if the bit at the given position is 0\n        if (called_operator_info.recursive_used_cases &amp; (1 &lt;&lt; bit_position)) == 0:\n            # If the bit is 0, set it to 1\n            called_operator_info.recursive_used_cases |= (1 &lt;&lt; bit_position)\n            self.logger.debug(f\"Bit {bit_position} was not set. Setting it now. Updated recursive_used_cases: {bin(called_operator_info.recursive_used_cases)}\")\n\n            # Check conditions for disabling recursion for unary or binary operators\n            if called_operator_info.n_ary == 1:\n                if called_operator_info.recursive_used_cases == 0b00000011:\n                    called_operator_info.is_recursion_enabled = False\n                    self.logger.info(f\"Recursion disabled for unary operator {called_operator_info.symbol} due to recursive_used_cases: {bin(called_operator_info.recursive_used_cases)}\")\n            elif called_operator_info.n_ary == 2:\n                if called_operator_info.recursive_used_cases == 0b11111111:\n                    called_operator_info.is_recursion_enabled = False\n                    self.logger.info(f\"Recursion disabled for binary operator {called_operator_info.symbol} due to recursive_used_cases: {bin(called_operator_info.recursive_used_cases)}\")\n\n            return True\n        else:\n            self.logger.debug(f\"Bit {bit_position} is already set for operator {called_operator_info.symbol}. No action taken.\")\n            return False\n\n    def check_and_set_recursion_validity(self, called_operator_info, op_type, param_order):\n        \"\"\"\n        Checks the recursion validity for a given operator based on its type (binary or unary),\n        and the parameter order. If the conditions are met, it sets the corresponding bit in the\n        operator's `recursive_used_cases` attribute to track recursion usage.\n\n        This function handles recursion for both binary and unary operators, checking the `param_order`\n        and setting the appropriate bit in `recursive_used_cases` for recursion tracking.\n\n        Args:\n            called_operator_info (OperatorInfo): The operator whose recursion validity is being checked.\n            op_type (str): The type of the operator, either \"binary\" or \"unary\".\n            param_order (tuple): A tuple representing the order of parameters, such as (\"result\", self.param_config.atoms['left_operand']).\n\n        Returns:\n            bool: Returns `True` if the bit was successfully set, `False` if the bit was already set.\n\n        Raises:\n            ValueError: If the `op_type` or `param_order` does not match expected values.\n\n        \"\"\"\n        self.logger.debug(f\"Checking recursion validity for operator {called_operator_info.symbol} of type {op_type} with param order {param_order}.\")\n\n        # Check binary operator conditions (binary -&gt; binary recursion)\n        if op_type == \"binary\" and called_operator_info.n_ary == 2:\n            if param_order == (\"result\", \"result\"):\n                self.logger.debug(\"Setting recursion for binary operator with binary-to-binary recursion ('result', 'result').\")\n                return self.set_bit_if_not_set(called_operator_info, 0)\n            elif param_order == (\"result\", self.param_config.atoms['left_operand']):\n                self.logger.debug(\"Setting recursion for binary operator with binary-to-binary recursion ('result', 'a').\")\n                return self.set_bit_if_not_set(called_operator_info, 1)\n            elif param_order == (\"result\", self.param_config.atoms['right_operand']):\n                self.logger.debug(\"Setting recursion for binary operator with binary-to-binary recursion ('result', 'b').\")\n                return self.set_bit_if_not_set(called_operator_info, 2)\n            elif param_order == (self.param_config.atoms['left_operand'], \"result\"):\n                self.logger.debug(\"Setting recursion for binary operator with binary-to-binary recursion ('a', 'result').\")\n                return self.set_bit_if_not_set(called_operator_info, 3)\n            elif param_order == (self.param_config.atoms['right_operand'], \"result\"):\n                self.logger.debug(\"Setting recursion for binary operator with binary-to-binary recursion ('b', 'result').\")\n                return self.set_bit_if_not_set(called_operator_info, 4)\n\n        # Check unary operator conditions with two parameters (unary -&gt; unary recursion)\n        elif op_type == \"unary\" and called_operator_info.n_ary == 2:\n            if param_order == (\"result\", \"result\"):\n                self.logger.debug(\"Setting recursion for unary operator with unary-to-unary recursion ('result', 'result').\")\n                return self.set_bit_if_not_set(called_operator_info, 5)\n            elif param_order == (\"result\", self.param_config.atoms['left_operand']):\n                self.logger.debug(\"Setting recursion for unary operator with unary-to-unary recursion ('result', 'a').\")\n                return self.set_bit_if_not_set(called_operator_info, 6)\n            elif param_order == (self.param_config.atoms['left_operand'], \"result\"):\n                self.logger.debug(\"Setting recursion for unary operator with unary-to-unary recursion ('a', 'result').\")\n                return self.set_bit_if_not_set(called_operator_info, 7)\n\n        # Check binary operator conditions with one parameter (binary -&gt; unary recursion)\n        elif op_type == \"binary\" and called_operator_info.n_ary == 1:\n            self.logger.debug(\"Setting recursion for binary operator with binary-to-unary recursion.\")\n            return self.set_bit_if_not_set(called_operator_info, 0)\n\n        # Check unary operator conditions with one parameter (unary -&gt; unary recursion)\n        elif op_type == \"unary\" and called_operator_info.n_ary == 1:\n            self.logger.debug(\"Setting recursion for unary operator with unary-to-unary recursion.\")\n            return self.set_bit_if_not_set(called_operator_info, 1)\n\n        else:\n            self.logger.error(f\"Invalid operation: op_type {op_type} and param_order {param_order} are not compatible.\")\n            raise ValueError(f\"Invalid operation: op_type {op_type} and param_order {param_order} are not compatible.\")\n\n    def generate_recursive_operator_data_by_loop(self):\n        \"\"\"\n        Generates recursive operator data, including both unary and binary operators, \n        and defines recursive computation functions for the operators. The recursion \n        involves calling other operators within the defined computation functions.\n\n        This method constructs recursive operator definitions and the corresponding \n        computation functions for both unary and binary operators based on the \n        random operator type, position, and symbols. It checks recursion validity \n        and ensures that recursion will not lead to infinite loops.\n\n        The generated operator data includes:\n        - The operator's symbol\n        - Its type (unary or binary)\n        - A computation function\n        - A count function\n        - A definition for the operator's behavior\n\n        Returns:\n            dict: A dictionary containing the operator data, including the operator's \n                  symbol, definition, and computation functions.\n            None: If the recursion validity check fails, returns None.\n        \"\"\"\n\n        self.logger.debug(\"Fetching existing operator symbols to avoid duplication.\")\n        existing_symbols = self.operator_manager.get_operator_symbols()\n\n        # Randomly select a new operator symbol\n        op_symbol = self.random_operator(existing_symbols)\n\n        self.logger.debug(f\"Selected operator symbol: {op_symbol}\")\n\n        # Randomly choose operator type (unary or binary) and position\n        # op_type, op_position = self.random_operator_type_and_position()\n        op_type, op_position = \"binary\", None\n        # Set the variables for condition and expression generators\n        variables = self.unary_variables if op_type == \"unary\" else self.binary_variables\n        self.condition_generator.set_variables(variables)\n        self.expr_generator.set_variables(variables)\n\n        # Generate the operator ID\n        id = self.operator_manager.get_next_operator_id()\n\n        self.logger.debug(f\"Generated operator ID: {id}\")\n\n        # Fetch a random recursive operator to be called in the recursion\n        called_operator_info = self.get_random_recursive_call_operator()\n        called_id = called_operator_info.id\n        called_symbol = called_operator_info.symbol\n\n        self.logger.debug(f\"Chosen operator for recursion: {called_symbol} (ID: {called_id})\")\n\n        # Generate the left-hand side expression\n        lhs = self.generate_lhs(op_symbol, op_type, op_position)\n\n        indent = \"    \"  \n        # Handle binary operator recursion\n        if op_type == \"binary\":\n            self.logger.debug(\"Generating recursive binary operator.\")\n\n            if called_operator_info.n_ary == 2:\n                # Randomly select the parameter order for recursion\n                param_order = random.choice([\n                    (\"result\", \"result\"), \n                    (\"result\", self.param_config.atoms['left_operand']), \n                    (\"result\", self.param_config.atoms['right_operand']),\n                    (self.param_config.atoms['left_operand'], \"result\"), \n                    (self.param_config.atoms['right_operand'], \"result\")\n                ])\n                param1, param2 = param_order\n\n                self.logger.debug(f\"Selected parameter order for recursion: {param_order}\")\n\n                # Check recursion validity\n                if not self.check_and_set_recursion_validity(called_operator_info, op_type, param_order):\n                    self.logger.warning(\"Recursion validity check failed.\")\n                    return None\n\n                # Generate the recursive computation function for binary operator\n                op_compute_fun = f'''def op_{id}(a, b):\n{indent}if a == 'NaN' or b == 'NaN':\n{indent*2}return 'NaN'\n{indent}result = a\n{indent}for i in range(abs(b)):\n{indent*2}result = op_{called_id}({param1}, {param2})\n{indent}return result\n'''\n                op_count_fun = f'''def op_count_{id}(a, b):\n{indent}if a == 'NaN' or b == 'NaN':\n{indent*2}return 'NaN'\n{indent}count = 0 \n{indent}for i in range(abs(b)):\n{indent*2}count += op_count_{called_id}({param1}, {param2})\n{indent}return count \n'''\n                # Generate the right-hand side expressions for the recursive function\n                if param1 == \"result\":\n                    param1_str_1 = f\"{self.param_config.atoms['left_operand']}{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['right_operand']}-1{self.param_config.atoms['right_parenthesis']}\"\n                    param1_str_2 = f\"{self.param_config.atoms['left_operand']}{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['right_operand']}+1{self.param_config.atoms['right_parenthesis']}\"\n                else:\n                    param1_str_1 = param1\n                    param1_str_2 = param1\n\n                if param2 == \"result\":\n                    param2_str_1 = f\"{self.param_config.atoms['left_operand']}{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['right_operand']}-1{self.param_config.atoms['right_parenthesis']}\"\n                    param2_str_2 = f\"{self.param_config.atoms['left_operand']}{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['right_operand']}+1{self.param_config.atoms['right_parenthesis']}\"\n                else:\n                    param2_str_1 = param2\n                    param2_str_2 = param2\n\n                rhs_1 = f\"{self.param_config.atoms['left_parenthesis']}{param1_str_1}{self.param_config.atoms['right_parenthesis']}{called_symbol}{self.param_config.atoms['left_parenthesis']}{param2_str_1}{self.param_config.atoms['right_parenthesis']}\"\n                rhs_2 = f\"{self.param_config.atoms['left_parenthesis']}{param1_str_2}{self.param_config.atoms['right_parenthesis']}{called_symbol}{self.param_config.atoms['left_parenthesis']}{param2_str_2}{self.param_config.atoms['right_parenthesis']}\"\n                definition = f\"{lhs} = {{{self.param_config.atoms['left_operand']}, if {self.param_config.atoms['right_operand']} == 0; {rhs_1}, if {self.param_config.atoms['right_operand']} &gt; 0; {rhs_2}, else}}\"\n\n                self.logger.debug(f\"Binary operator definition generated: {definition}\")\n\n            elif called_operator_info.n_ary == 1:\n                # Check recursion validity for unary call within binary operator\n                if not self.check_and_set_recursion_validity(called_operator_info, op_type, None):\n                    self.logger.warning(\"Recursion validity check failed.\")\n                    return None\n\n                # Generate recursive function for unary operator call in binary\n                op_compute_fun = f'''def op_{id}(a, b):\n{indent}if a == 'NaN' or b == 'NaN':\n{indent*2}return 'NaN'\n{indent}result = a\n{indent}for i in range(abs(b)):\n{indent*2}result = op_{called_id}(result)\n{indent}return result\n'''\n                op_count_fun = f'''def op_count_{id}(a, b):\n{indent}if a == 'NaN' or b == 'NaN':\n{indent*2}return 'NaN'\n{indent}count = 0 \n{indent}for i in range(abs(b)):\n{indent*2}count += op_count_{called_id}(result)\n{indent}return count \n'''\n\n                # Generate the right-hand side for the unary operator in binary recursion\n                param_str_1 = f\"{self.param_config.atoms['left_operand']}{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['right_operand']}-1{self.param_config.atoms['right_parenthesis']}\"\n                param_str_2 = f\"{self.param_config.atoms['left_operand']}{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['right_operand']}+1{self.param_config.atoms['right_parenthesis']}\"\n\n                if called_operator_info.unary_position == \"prefix\":\n                    rhs_1 = f\"{called_symbol}{self.param_config.atoms['left_parenthesis']}{param_str_1}{self.param_config.atoms['right_parenthesis']}\"\n                    rhs_2 = f\"{called_symbol}{self.param_config.atoms['left_parenthesis']}{param_str_2}{self.param_config.atoms['right_parenthesis']}\"\n                elif called_operator_info.unary_position == \"postfix\":\n                    rhs_1 = f\"{self.param_config.atoms['left_parenthesis']}{param_str_1}{self.param_config.atoms['right_parenthesis']}{called_symbol}\"\n                    rhs_2 = f\"{self.param_config.atoms['left_parenthesis']}{param_str_2}{self.param_config.atoms['right_parenthesis']}{called_symbol}\"\n\n                definition = f\"{lhs} = {{{self.param_config.atoms['left_operand']}, if {self.param_config.atoms['right_operand']} == 0; {rhs_1}, if {self.param_config.atoms['right_operand']} &gt; 0; {rhs_2}, else}}\"\n\n                self.logger.debug(f\"Unary operator within binary operator definition generated: {definition}\")\n\n        # Handle unary operator recursion\n        elif op_type == \"unary\":\n            self.logger.debug(\"Generating recursive unary operator.\")\n\n            if called_operator_info.n_ary == 2:\n                param_order = random.choice([(\"result\", \"result\"), (\"result\", self.param_config.atoms['left_operand']), (self.param_config.atoms['left_operand'], \"result\")])\n                param1, param2 = param_order\n\n                self.logger.debug(f\"Selected parameter order for recursion: {param_order}\")\n\n                if not self.check_and_set_recursion_validity(called_operator_info, op_type, param_order):\n                    self.logger.warning(\"Recursion validity check failed.\")\n                    return None\n\n                op_compute_fun = f'''def op_{id}(a):\n{indent}if a == 'NaN':\n{indent*2}return 'NaN'\n{indent}result = a\n{indent}for i in range(abs(a)):\n{indent*2}result = op_{called_id}({param1}, {param2})\n{indent}return result\n'''\n                op_count_fun = f'''def op_count_{id}(a):\n{indent}if a == 'NaN':\n{indent*2}return 'NaN'\n{indent}count = 0 \n{indent}for i in range(abs(a)):\n{indent*2}count += op_count_{called_id}({param1}, {param2})\n{indent}return count \n'''\n\n                if param1 == \"result\":\n                    if op_position == \"prefix\":\n                        param1_str_1 = f\"{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}-1{self.param_config.atoms['right_parenthesis']}\"\n                        param1_str_2 = f\"{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}+1{self.param_config.atoms['right_parenthesis']}\"\n                    elif op_position == \"postfix\":\n                        param1_str_1 = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}-1{self.param_config.atoms['right_parenthesis']}{op_symbol}\"\n                        param1_str_2 = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}+1{self.param_config.atoms['right_parenthesis']}{op_symbol}\"\n                else:\n                    param1_str_1 = param1\n                    param1_str_2 = param1\n\n                if param2 == \"result\":\n                    if op_position == \"prefix\":\n                        param2_str_1 = f\"{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}-1{self.param_config.atoms['right_parenthesis']}\"\n                        param2_str_2 = f\"{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}+1{self.param_config.atoms['right_parenthesis']}\"\n                    elif op_position == \"postfix\":\n                        param2_str_1 = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}-1{self.param_config.atoms['right_parenthesis']}{op_symbol}\"\n                        param2_str_2 = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}+1{self.param_config.atoms['right_parenthesis']}{op_symbol}\"\n                else:\n                    param2_str_1 = param1\n                    param2_str_2 = param1\n\n                rhs_1 = f\"{self.param_config.atoms['left_parenthesis']}{param1_str_1}{self.param_config.atoms['right_parenthesis']}{called_symbol}{self.param_config.atoms['left_parenthesis']}{param2_str_1}{self.param_config.atoms['right_parenthesis']}\"\n                rhs_2 = f\"{self.param_config.atoms['left_parenthesis']}{param1_str_2}{self.param_config.atoms['right_parenthesis']}{called_symbol}{self.param_config.atoms['left_parenthesis']}{param2_str_2}{self.param_config.atoms['right_parenthesis']}\"\n                definition = f\"{lhs} = {{{self.param_config.atoms['left_operand']}, if {self.param_config.atoms['left_operand']} == 0; {rhs_1}, if {self.param_config.atoms['left_operand']} &gt; 0; {rhs_2}, else}}\"\n\n                self.logger.debug(f\"Unary operator recursive definition generated: {definition}\")\n\n            elif called_operator_info.n_ary == 1:\n                # Check recursion validity for unary operator\n                if not self.check_and_set_recursion_validity(called_operator_info, op_type, None):\n                    self.logger.warning(\"Recursion validity check failed.\")\n                    return None\n\n                op_compute_fun = f'''def op_{id}(a):\n{indent}if a == 'NaN':\n{indent*2}return 'NaN'\n{indent}result = a\n{indent}for i in range(abs(a)):\n{indent*2}result = op_{called_id}(result)\n{indent}return result\n'''\n                op_count_fun = f'''def op_count_{id}(a):\n{indent}if a == 'NaN':\n{indent*2}return 'NaN'\n{indent}count = 0 \n{indent}for i in range(abs(a)):\n{indent*2}count += op_count_{called_id}(result)\n{indent}return count \n'''\n\n                if op_position == \"prefix\":\n                    param_str_1 = f\"{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}-1{self.param_config.atoms['right_parenthesis']}\"\n                    param_str_2 = f\"{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}+1{self.param_config.atoms['right_parenthesis']}\"\n                elif op_position == \"postfix\":\n                    param_str_1 = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}-1{self.param_config.atoms['right_parenthesis']}{op_symbol}\"\n                    param_str_2 = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}+1{self.param_config.atoms['right_parenthesis']}{op_symbol}\"\n\n                if called_operator_info.unary_position == \"prefix\":\n                    rhs_1 = f\"{called_symbol}{self.param_config.atoms['left_parenthesis']}{param_str_1}{self.param_config.atoms['right_parenthesis']}\"\n                    rhs_2 = f\"{called_symbol}{self.param_config.atoms['left_parenthesis']}{param_str_2}{self.param_config.atoms['right_parenthesis']}\"\n                elif called_operator_info.unary_position == \"postfix\":\n                    rhs_1 = f\"{self.param_config.atoms['left_parenthesis']}{param_str_1}{self.param_config.atoms['right_parenthesis']}{called_symbol}\"\n                    rhs_2 = f\"{self.param_config.atoms['left_parenthesis']}{param_str_2}{self.param_config.atoms['right_parenthesis']}{called_symbol}\"\n\n                definition = f\"{lhs} = {{{self.param_config.atoms['left_operand']}, if {self.param_config.atoms['left_operand']} == 0; {rhs_1}, if {self.param_config.atoms['left_operand']} &gt; 0; {rhs_2}, else}}\"\n\n                self.logger.debug(f\"Unary operator definition generated: {definition}\")\n        else:\n            raise ValueError(\"Unsupported operator type. Only 'unary' and 'binary' are supported.\")\n\n        operator_data = {\n            \"id\": id,  # Unique identifier for the operator.\n            \"symbol\": op_symbol,  # The symbol representing the operator (e.g., \"+\", \"-\", \"*\").\n            \"n_ary\": 1 if op_type == \"unary\" else 2,  # Arity of the operator (1 for unary, 2 for binary).\n            \"unary_position\": op_position if op_type == \"unary\" else None,  # Position of the unary operator, None for binary.\n            \"is_base\": None,  # Initially no base operator flag.\n            \"definition\": definition,  # Recursive definition of the operator.\n            \"definition_type\": \"recursive_definition\",  # Type of the definition (\"recursive_definition\").\n            \"priority\": None,  # Operator priority, not assigned yet.\n            \"associativity_direction\": None,  # Operator associativity, not assigned yet.\n            \"n_order\": None,  # Computation order, managed by OperatorManager.\n            \"op_compute_func\": op_compute_fun,  # Function to compute the operator.\n            \"op_count_func\": op_count_fun,  # Function to count operations or recursive calls.\n            \"properties\": None,  # Additional properties of the operator, None initially.\n            \"dependencies\": None,  # Dependencies of the operator, None initially.\n            \"is_temporary\": True,  # Flag indicating the operator is temporarily generated.\n        }\n\n        # Log the generated operator data for tracking purposes.\n        self.logger.info(f\"Generated operator data: {operator_data}\")\n\n        return operator_data\n\n    def create_operator_info(self, choice: str) -&gt; Dict[str, Any]:\n        \"\"\"\n        Generate an OperatorInfo object.\n        \"\"\"\n        if choice == \"recursive_definition\":\n            operator_data = self.generate_recursive_operator_data_by_loop()\n        else:\n            operator_data = self.generate_operator_data_by_definition(choice)\n        return operator_data\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_generator/#opulse.operatorplus.operator_generator.OperatorGenerator.__init__","title":"<code>__init__(param_config, logger, condition_generator, expr_generator, operator_manager)</code>","text":"<p>Initialize the OperatorGenerator.</p> <p>Parameters:</p> Name Type Description Default <code>param_config</code> <code>ParamConfig</code> <p>Configuration object containing parameters like symbols and operator details.</p> required <code>logger</code> <code>LogConfig</code> <p>Logger configuration to handle logging functionality.</p> required <code>condition_generator</code> <code>ConditionGenerator</code> <p>A generator responsible for producing conditions.</p> required <code>expr_generator</code> <code>ExpressionGenerator</code> <p>A generator responsible for producing expressions.</p> required <code>operator_generator</code> <code>OperatorManager</code> <p>Manages operator-related functionality.</p> required <p>Attributes:</p> Name Type Description <code>param_config</code> <code>ParamConfig</code> <p>Configuration object that holds various parameters.</p> <code>logger</code> <code>Logger</code> <p>Logger instance used for logging debug and info messages.</p> <code>standard_symbols</code> <code>list</code> <p>A list of standard operator symbols.</p> <code>unicode_symbols</code> <code>list</code> <p>A list of Unicode operator symbols.</p> <code>valid_symbols</code> <code>list</code> <p>A combined list of valid operator symbols (standard + Unicode).</p> <code>condition_generator</code> <code>ConditionGenerator</code> <p>The generator used to generate conditions.</p> <code>expr_generator</code> <code>ExpressionGenerator</code> <p>The generator used to generate expressions.</p> <code>operator_manager</code> <code>OperatorManager</code> <p>Manages operators for the generator.</p> <code>unary_variables</code> <code>list</code> <p>List of variables used in unary operations.</p> <code>binary_variables</code> <code>list</code> <p>List of variables used in binary operations.</p> <code>max_base</code> <code>int</code> <p>Maximum base value used in the generation process.</p> <code>operator_symbol_min_len</code> <code>int</code> <p>Minimum length for operator symbols.</p> <code>operator_symbol_max_len</code> <code>int</code> <p>Maximum length for operator symbols.</p> <code>max_if_branches</code> <code>int</code> <p>Maximum number of branches in conditional expressions.</p> Source code in <code>opulse/operatorplus/operator_generator.py</code> <pre><code>def __init__(\n    self,\n    param_config: ParamConfig,\n    logger: LogConfig,\n    condition_generator: ConditionGenerator,\n    expr_generator: ExpressionGenerator,\n    operator_manager: OperatorManager,\n):\n    \"\"\"\n    Initialize the OperatorGenerator.\n\n    Parameters:\n        param_config (ParamConfig): Configuration object containing parameters like symbols and operator details.\n        logger (LogConfig): Logger configuration to handle logging functionality.\n        condition_generator (ConditionGenerator): A generator responsible for producing conditions.\n        expr_generator (ExpressionGenerator): A generator responsible for producing expressions.\n        operator_generator (OperatorManager): Manages operator-related functionality.\n\n    Attributes:\n        param_config (ParamConfig): Configuration object that holds various parameters.\n        logger (Logger): Logger instance used for logging debug and info messages.\n        standard_symbols (list): A list of standard operator symbols.\n        unicode_symbols (list): A list of Unicode operator symbols.\n        valid_symbols (list): A combined list of valid operator symbols (standard + Unicode).\n        condition_generator (ConditionGenerator): The generator used to generate conditions.\n        expr_generator (ExpressionGenerator): The generator used to generate expressions.\n        operator_manager (OperatorManager): Manages operators for the generator.\n        unary_variables (list): List of variables used in unary operations.\n        binary_variables (list): List of variables used in binary operations.\n        max_base (int): Maximum base value used in the generation process.\n        operator_symbol_min_len (int): Minimum length for operator symbols.\n        operator_symbol_max_len (int): Maximum length for operator symbols.\n        max_if_branches (int): Maximum number of branches in conditional expressions.\n    \"\"\"\n    self.param_config = param_config\n    self.logger = logger.get_logger()  # Get logger instance for logging\n    self.standard_symbols = self.param_config.get(\"basic_operator_symbols\")\n    self.unicode_symbols = self.get_unicode_symbols()\n    self.valid_symbols = self.standard_symbols + self.unicode_symbols\n    self.condition_generator = condition_generator  # Condition generator instance\n    self.expr_generator = expr_generator  # Expression generator instance\n    self.operator_manager = operator_manager  # Operator manager instance\n    self.unary_variables = [self.param_config.atoms['left_operand']]\n    self.binary_variables = [self.param_config.atoms['left_operand'], self.param_config.atoms['right_operand']]\n    self.max_base = self.param_config.get(\"max_base\")\n    self.operator_symbol_min_len = self.param_config.get(\"operator_symbol_min_len\")\n    self.operator_symbol_max_len = self.param_config.get(\"operator_symbol_max_len\")\n    self.max_if_branches = self.param_config.get(\"max_if_branches\")\n\n    # Log initialization details\n    self.logger.info(\"OperatorGenerator initialized with the following configuration:\")\n    self.logger.debug(f\"Standard symbols: {self.standard_symbols}\")\n    self.logger.debug(f\"Unicode symbols: {self.unicode_symbols}\")\n    self.logger.debug(f\"Valid symbols: {self.valid_symbols}\")\n    self.logger.debug(f\"Unary variables: {self.unary_variables}\")\n    self.logger.debug(f\"Binary variables: {self.binary_variables}\")\n    self.logger.debug(f\"Max base: {self.max_base}\")\n    self.logger.debug(f\"Operator symbol min length: {self.operator_symbol_min_len}\")\n    self.logger.debug(f\"Operator symbol max length: {self.operator_symbol_max_len}\")\n    self.logger.debug(f\"Max if branches: {self.max_if_branches}\")\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_generator/#opulse.operatorplus.operator_generator.OperatorGenerator.check_and_set_recursion_validity","title":"<code>check_and_set_recursion_validity(called_operator_info, op_type, param_order)</code>","text":"<p>Checks the recursion validity for a given operator based on its type (binary or unary), and the parameter order. If the conditions are met, it sets the corresponding bit in the operator's <code>recursive_used_cases</code> attribute to track recursion usage.</p> <p>This function handles recursion for both binary and unary operators, checking the <code>param_order</code> and setting the appropriate bit in <code>recursive_used_cases</code> for recursion tracking.</p> <p>Parameters:</p> Name Type Description Default <code>called_operator_info</code> <code>OperatorInfo</code> <p>The operator whose recursion validity is being checked.</p> required <code>op_type</code> <code>str</code> <p>The type of the operator, either \"binary\" or \"unary\".</p> required <code>param_order</code> <code>tuple</code> <p>A tuple representing the order of parameters, such as (\"result\", self.param_config.atoms['left_operand']).</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>Returns <code>True</code> if the bit was successfully set, <code>False</code> if the bit was already set.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the <code>op_type</code> or <code>param_order</code> does not match expected values.</p> Source code in <code>opulse/operatorplus/operator_generator.py</code> <pre><code>def check_and_set_recursion_validity(self, called_operator_info, op_type, param_order):\n    \"\"\"\n    Checks the recursion validity for a given operator based on its type (binary or unary),\n    and the parameter order. If the conditions are met, it sets the corresponding bit in the\n    operator's `recursive_used_cases` attribute to track recursion usage.\n\n    This function handles recursion for both binary and unary operators, checking the `param_order`\n    and setting the appropriate bit in `recursive_used_cases` for recursion tracking.\n\n    Args:\n        called_operator_info (OperatorInfo): The operator whose recursion validity is being checked.\n        op_type (str): The type of the operator, either \"binary\" or \"unary\".\n        param_order (tuple): A tuple representing the order of parameters, such as (\"result\", self.param_config.atoms['left_operand']).\n\n    Returns:\n        bool: Returns `True` if the bit was successfully set, `False` if the bit was already set.\n\n    Raises:\n        ValueError: If the `op_type` or `param_order` does not match expected values.\n\n    \"\"\"\n    self.logger.debug(f\"Checking recursion validity for operator {called_operator_info.symbol} of type {op_type} with param order {param_order}.\")\n\n    # Check binary operator conditions (binary -&gt; binary recursion)\n    if op_type == \"binary\" and called_operator_info.n_ary == 2:\n        if param_order == (\"result\", \"result\"):\n            self.logger.debug(\"Setting recursion for binary operator with binary-to-binary recursion ('result', 'result').\")\n            return self.set_bit_if_not_set(called_operator_info, 0)\n        elif param_order == (\"result\", self.param_config.atoms['left_operand']):\n            self.logger.debug(\"Setting recursion for binary operator with binary-to-binary recursion ('result', 'a').\")\n            return self.set_bit_if_not_set(called_operator_info, 1)\n        elif param_order == (\"result\", self.param_config.atoms['right_operand']):\n            self.logger.debug(\"Setting recursion for binary operator with binary-to-binary recursion ('result', 'b').\")\n            return self.set_bit_if_not_set(called_operator_info, 2)\n        elif param_order == (self.param_config.atoms['left_operand'], \"result\"):\n            self.logger.debug(\"Setting recursion for binary operator with binary-to-binary recursion ('a', 'result').\")\n            return self.set_bit_if_not_set(called_operator_info, 3)\n        elif param_order == (self.param_config.atoms['right_operand'], \"result\"):\n            self.logger.debug(\"Setting recursion for binary operator with binary-to-binary recursion ('b', 'result').\")\n            return self.set_bit_if_not_set(called_operator_info, 4)\n\n    # Check unary operator conditions with two parameters (unary -&gt; unary recursion)\n    elif op_type == \"unary\" and called_operator_info.n_ary == 2:\n        if param_order == (\"result\", \"result\"):\n            self.logger.debug(\"Setting recursion for unary operator with unary-to-unary recursion ('result', 'result').\")\n            return self.set_bit_if_not_set(called_operator_info, 5)\n        elif param_order == (\"result\", self.param_config.atoms['left_operand']):\n            self.logger.debug(\"Setting recursion for unary operator with unary-to-unary recursion ('result', 'a').\")\n            return self.set_bit_if_not_set(called_operator_info, 6)\n        elif param_order == (self.param_config.atoms['left_operand'], \"result\"):\n            self.logger.debug(\"Setting recursion for unary operator with unary-to-unary recursion ('a', 'result').\")\n            return self.set_bit_if_not_set(called_operator_info, 7)\n\n    # Check binary operator conditions with one parameter (binary -&gt; unary recursion)\n    elif op_type == \"binary\" and called_operator_info.n_ary == 1:\n        self.logger.debug(\"Setting recursion for binary operator with binary-to-unary recursion.\")\n        return self.set_bit_if_not_set(called_operator_info, 0)\n\n    # Check unary operator conditions with one parameter (unary -&gt; unary recursion)\n    elif op_type == \"unary\" and called_operator_info.n_ary == 1:\n        self.logger.debug(\"Setting recursion for unary operator with unary-to-unary recursion.\")\n        return self.set_bit_if_not_set(called_operator_info, 1)\n\n    else:\n        self.logger.error(f\"Invalid operation: op_type {op_type} and param_order {param_order} are not compatible.\")\n        raise ValueError(f\"Invalid operation: op_type {op_type} and param_order {param_order} are not compatible.\")\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_generator/#opulse.operatorplus.operator_generator.OperatorGenerator.create_operator_info","title":"<code>create_operator_info(choice)</code>","text":"<p>Generate an OperatorInfo object.</p> Source code in <code>opulse/operatorplus/operator_generator.py</code> <pre><code>def create_operator_info(self, choice: str) -&gt; Dict[str, Any]:\n    \"\"\"\n    Generate an OperatorInfo object.\n    \"\"\"\n    if choice == \"recursive_definition\":\n        operator_data = self.generate_recursive_operator_data_by_loop()\n    else:\n        operator_data = self.generate_operator_data_by_definition(choice)\n    return operator_data\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_generator/#opulse.operatorplus.operator_generator.OperatorGenerator.generate_base_operators","title":"<code>generate_base_operators()</code>","text":"<p>Generates unary prefix operators for each base from 2 to self.max_base.</p> <p>This method creates a unary prefix operator for each base in the range from 2 to <code>self.max_base</code>. For each base, a random operator symbol is generated, and the operator is added to the operator manager. The operator is stored with additional properties, such as its base number and the unary position.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>opulse/operatorplus/operator_generator.py</code> <pre><code>def generate_base_operators(self):\n    \"\"\"\n    Generates unary prefix operators for each base from 2 to self.max_base.\n\n    This method creates a unary prefix operator for each base in the range from 2 to `self.max_base`.\n    For each base, a random operator symbol is generated, and the operator is added to the operator manager.\n    The operator is stored with additional properties, such as its base number and the unary position.\n\n    Returns:\n        None\n    \"\"\"\n    self.logger.info(\"Starting to generate base operators for each base from 2 to max_base.\")\n\n    # Iterate through the range of bases from 2 to max_base\n    for n in range(2, self.max_base + 1):\n        self.logger.debug(f\"Generating operator for base {n}.\")\n\n        # Get existing operator symbols to avoid duplication\n        existing_symbols = self.operator_manager.get_operator_symbols()\n\n        # Generate a random operator symbol that isn't already used\n        op_symbol = self.random_operator(existing_symbols)\n\n        # Define operator type and position\n        op_type = \"unary\"\n        op_position = \"prefix\"\n\n        # Construct the operator data\n        operator_data = {\n            \"id\": None,  \n            \"symbol\": op_symbol,\n            \"n_ary\": 1,  # Unary operator\n            \"unary_position\": op_position if op_type == \"unary\" else None,\n            \"is_base\": n,  # Base number\n            \"definition\": None,\n            \"definition_type\": None,\n            \"priority\": None,\n            \"associativity_direction\": None,\n            \"n_order\": None,\n            \"op_compute_func\": None,\n            \"op_count_func\": None,\n            \"properties\": None,\n            \"dependencies\": None,\n            \"is_temporary\": False,\n        }\n\n        # Add the generated operator to the operator manager\n        self.operator_manager.add_operator(operator_data)\n\n        self.logger.info(f\"Base operator for base {n} with symbol '{op_symbol}' added successfully.\")\n\n    self.logger.info(\"Base operator generation completed.\")\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_generator/#opulse.operatorplus.operator_generator.OperatorGenerator.generate_branches","title":"<code>generate_branches()</code>","text":"<p>Generates a list of conditional branches for an expression, including 'if' and 'else' branches.</p> <p>This method generates a random number of 'if' branches based on the maximum allowed number  of branches (<code>max_if_branches</code>), each containing a randomly generated expression and a condition. Additionally, an 'else' branch is added with a randomly generated expression.</p> <p>The format of each branch is a tuple containing the expression and the corresponding condition.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of tuples, each containing a generated expression and its associated condition.</p> <p>Each tuple is in the form (expression, condition).</p> Source code in <code>opulse/operatorplus/operator_generator.py</code> <pre><code>def generate_branches(self):\n    \"\"\"\n    Generates a list of conditional branches for an expression, including 'if' and 'else' branches.\n\n    This method generates a random number of 'if' branches based on the maximum allowed number \n    of branches (`max_if_branches`), each containing a randomly generated expression and a condition.\n    Additionally, an 'else' branch is added with a randomly generated expression.\n\n    The format of each branch is a tuple containing the expression and the corresponding condition.\n\n    Returns:\n        list: A list of tuples, each containing a generated expression and its associated condition.\n        Each tuple is in the form (expression, condition).\n    \"\"\"\n    self.logger.debug(\"Generating branches for conditional expressions.\")\n\n    num_if_branches = random.randint(1, self.max_if_branches)\n    branches = []\n\n    self.logger.info(f\"Generating {num_if_branches} 'if' branches.\")\n\n    # Generate the specified number of 'if' branches\n    for i in range(num_if_branches):\n        expr = self.expr_generator.create_expression_str(atom_choice=\"variable_and_number\")\n        condition = self.condition_generator.generate_condition_expr()\n        branches.append((expr, f\"if {condition}\"))\n\n        self.logger.debug(f\"Generated 'if' branch {i+1}: {expr} with condition {condition}\")\n\n    # Add the required 'else' branch\n    else_expr = self.expr_generator.create_expression_str(atom_choice=\"variable_and_number\")  # Generate expression for 'else'\n    branches.append((else_expr, \"else\"))\n\n    self.logger.debug(f\"Generated 'else' branch: {else_expr}\")\n    self.logger.info(f\"Total branches generated: {len(branches)}.\")\n\n    return branches\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_generator/#opulse.operatorplus.operator_generator.OperatorGenerator.generate_definition","title":"<code>generate_definition(op_symbol, op_type, op_position, choice)</code>","text":"<p>Generates a complete operator definition rule based on the provided parameters.</p> <p>This method constructs the definition of an operator, which can vary depending on the  <code>choice</code> parameter. It can generate a simple expression, a recursive call, or a branching  expression with conditional logic.</p> The definition can be generated in three different forms <ol> <li>Simple Definition: A basic operator definition without any conditional branching.</li> <li>Recursive Definition: A definition where the operator is recursively applied, based on the operator type (unary or binary).</li> <li>Branch Definition: A definition with multiple branches, using conditional logic (if-else statements) to determine the behavior.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>op_symbol</code> <code>str</code> <p>The symbol representing the operator (e.g., '+', '-', '*', etc.).</p> required <code>op_type</code> <code>str</code> <p>The type of the operator, either 'unary' (one operand) or 'binary' (two operands).</p> required <code>op_position</code> <code>str</code> <p>The position of the unary operator, either 'prefix' or 'postfix'.</p> required <code>choice</code> <code>str</code> <p>A string that determines the type of operator definition to generate:         - \"simple_definition\": generates a simple expression without branching.         - \"recursive_definition\": generates an expression with a recursive call.         - \"branch_definition\": generates an expression with branching logic (if-else).</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>A string representing the operator definition. The content of the string depends on the <code>choice</code> parameter: - For \"simple_definition\", a simple expression is returned. - For \"recursive_definition\", a recursive call expression is returned. - For \"branch_definition\", an expression with conditional branches is returned.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the <code>choice</code> parameter is not one of the recognized options (\"simple_definition\", \"recursive_definition\", \"branch_definition\").</p> Source code in <code>opulse/operatorplus/operator_generator.py</code> <pre><code>def generate_definition(self, op_symbol, op_type, op_position, choice):\n    \"\"\"\n    Generates a complete operator definition rule based on the provided parameters.\n\n    This method constructs the definition of an operator, which can vary depending on the \n    `choice` parameter. It can generate a simple expression, a recursive call, or a branching \n    expression with conditional logic.\n\n    The definition can be generated in three different forms:\n        1. **Simple Definition**: A basic operator definition without any conditional branching.\n        2. **Recursive Definition**: A definition where the operator is recursively applied, based on the operator type (unary or binary).\n        3. **Branch Definition**: A definition with multiple branches, using conditional logic (if-else statements) to determine the behavior.\n\n    Parameters:\n        op_symbol (str): The symbol representing the operator (e.g., '+', '-', '*', etc.).\n        op_type (str): The type of the operator, either 'unary' (one operand) or 'binary' (two operands).\n        op_position (str): The position of the unary operator, either 'prefix' or 'postfix'.\n        choice (str): A string that determines the type of operator definition to generate:\n                    - \"simple_definition\": generates a simple expression without branching.\n                    - \"recursive_definition\": generates an expression with a recursive call.\n                    - \"branch_definition\": generates an expression with branching logic (if-else).\n\n    Returns:\n        str: A string representing the operator definition. The content of the string depends on the `choice` parameter:\n            - For \"simple_definition\", a simple expression is returned.\n            - For \"recursive_definition\", a recursive call expression is returned.\n            - For \"branch_definition\", an expression with conditional branches is returned.\n\n    Raises:\n        ValueError: If the `choice` parameter is not one of the recognized options (\"simple_definition\", \"recursive_definition\", \"branch_definition\").\n    \"\"\"\n    self.logger.debug(f\"Generating definition for operator: {op_symbol}, Type: {op_type}, Position: {op_position}, Choice: {choice}\")\n\n    # Generate the left-hand side of the operator definition\n    lhs = self.generate_lhs(op_symbol, op_type, op_position)\n\n    if choice == \"simple_definition\":\n        # Simple expression, no branches\n        expr = self.expr_generator.create_expression_str(atom_choice=\"variable_and_number\")\n        self.logger.info(f\"Simple definition generated: {lhs} {self.param_config.atoms['equal']} {{ {expr} }}\")\n        return f\"{lhs} {self.param_config.atoms['equal']} {{ {expr} }}\"\n\n    elif choice == \"recursive_definition\":\n        recursive_call = self.generate_recursive_call(\n            op_symbol, op_type, op_position\n        )\n        return f\"{lhs} = {{ {recursive_call} }}\"\n\n    elif choice == \"branch_definition\":\n        # Generate branches with conditions\n        branches = self.generate_branches()\n\n        # Build the branch strings\n        branch_strings = []\n        for expr, condition in branches:\n            if condition.startswith(\"if\"):\n                branch_strings.append(f\"{expr} , {condition}\")\n            elif condition == \"else\":\n                branch_strings.append(f\"{expr}, else\")\n\n        # Join branches with semicolons\n        rhs = \" ; \".join(branch_strings)\n        definition = f\"{lhs} {self.param_config.atoms['equal']} {{ {rhs} }}\"\n        self.logger.info(f\"Branch definition generated: {definition}\")\n        return definition\n\n    else:\n        self.logger.warning(f\"Unknown choice: {choice}. Returning None.\")\n        return None\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_generator/#opulse.operatorplus.operator_generator.OperatorGenerator.generate_lhs","title":"<code>generate_lhs(op_symbol, op_type, op_position)</code>","text":"<p>Generates the left-hand side (LHS) of an expression based on the operator type and position.</p> <p>This method constructs the left-hand side of an expression depending on the type of operator  (unary or binary) and its position (prefix or postfix). It uses the operator symbol and operands  defined in the configuration.</p> <p>Parameters:</p> Name Type Description Default <code>op_symbol</code> <code>str</code> <p>The operator symbol to be used in the expression (e.g., \"+\", \"\u2295\").</p> required <code>op_type</code> <code>str</code> <p>The type of the operator, either \"unary\" or \"binary\".</p> required <code>op_position</code> <code>str</code> <p>The position of the operator, either \"prefix\" or \"postfix\" (only for unary operators).</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>The generated left-hand side expression as a string.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the operator type is neither \"unary\" nor \"binary\".</p> Source code in <code>opulse/operatorplus/operator_generator.py</code> <pre><code>def generate_lhs(self, op_symbol, op_type, op_position):\n    \"\"\"\n    Generates the left-hand side (LHS) of an expression based on the operator type and position.\n\n    This method constructs the left-hand side of an expression depending on the type of operator \n    (unary or binary) and its position (prefix or postfix). It uses the operator symbol and operands \n    defined in the configuration.\n\n    Parameters:\n        op_symbol (str): The operator symbol to be used in the expression (e.g., \"+\", \"\u2295\").\n        op_type (str): The type of the operator, either \"unary\" or \"binary\".\n        op_position (str): The position of the operator, either \"prefix\" or \"postfix\" (only for unary operators).\n\n    Returns:\n        str: The generated left-hand side expression as a string.\n\n    Raises:\n        ValueError: If the operator type is neither \"unary\" nor \"binary\".\n    \"\"\"\n\n    self.logger.debug(f\"Generating LHS for operator '{op_symbol}', type '{op_type}', position '{op_position}'.\")\n\n    # Handle the case for unary operators\n    if op_type == \"unary\":\n        if op_position == \"prefix\":\n            lhs = f\"{op_symbol}{self.param_config.atoms['left_operand']}\"  # e.g., \"-a\"\n        elif op_position == \"postfix\":\n            lhs = f\"{self.param_config.atoms['left_operand']}{op_symbol}\"  # e.g., \"a-\"\n        else:\n            self.logger.error(f\"Invalid position '{op_position}' for unary operator.\")\n            raise ValueError(f\"Invalid position '{op_position}' for unary operator.\")\n\n    # Handle the case for binary operators\n    elif op_type == \"binary\":\n        lhs = f\"{self.param_config.atoms['left_operand']}{op_symbol}{self.param_config.atoms['right_operand']}\"  # e.g., 'a + b', 'a\u2295b'\n    else:\n        self.logger.error(f\"Invalid operator type '{op_type}' received.\")\n        raise ValueError(f\"Operator type must be either 'unary' or 'binary'.\")\n\n    self.logger.info(f\"LHS generated: {lhs}\")\n    return lhs\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_generator/#opulse.operatorplus.operator_generator.OperatorGenerator.generate_operator_data_by_definition","title":"<code>generate_operator_data_by_definition(choice)</code>","text":"<p>Generates operator data based on a specified operator definition type.</p> <p>This method generates an operator symbol, determines its type (unary or binary), and sets its position (prefix or postfix). Then, it creates an operator definition based on the given <code>choice</code> parameter, which determines whether the operator definition is simple or involves  conditional branching. The generated operator data includes the operator's symbol, type,  position, and its corresponding definition.</p> <p>Parameters:</p> Name Type Description Default <code>choice</code> <code>str</code> <p>The type of operator definition to generate.          Can be one of the following:         - \"simple_definition\": Generates a basic operator expression without branching.         - \"branch_definition\": Generates an operator definition with conditional branching (if-else).         - \"recursive_definition\": generates an expression with a recursive call.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the generated operator data.</p> Source code in <code>opulse/operatorplus/operator_generator.py</code> <pre><code>def generate_operator_data_by_definition(self, choice):\n    \"\"\"\n    Generates operator data based on a specified operator definition type.\n\n    This method generates an operator symbol, determines its type (unary or binary), and sets\n    its position (prefix or postfix). Then, it creates an operator definition based on the given\n    `choice` parameter, which determines whether the operator definition is simple or involves \n    conditional branching. The generated operator data includes the operator's symbol, type, \n    position, and its corresponding definition.\n\n    Parameters:\n        choice (str): The type of operator definition to generate. \n                    Can be one of the following:\n                    - \"simple_definition\": Generates a basic operator expression without branching.\n                    - \"branch_definition\": Generates an operator definition with conditional branching (if-else).\n                    - \"recursive_definition\": generates an expression with a recursive call.\n\n    Returns:\n        dict: A dictionary containing the generated operator data.\n    \"\"\"\n    self.logger.debug(f\"Generating operator data by definition with choice: {choice}\")\n\n    # Generate a random operator symbol that doesn't already exist in the operator manager\n    existing_symbols = self.operator_manager.get_operator_symbols()\n    op_symbol = self.random_operator(existing_symbols)\n    self.logger.debug(f\"Generated operator symbol: {op_symbol}\")\n\n    # Determine the type (unary or binary) and position (prefix or postfix) of the operator\n    op_type, op_position = self.random_operator_type_and_position()\n    self.logger.debug(f\"Operator type: {op_type}, Operator position: {op_position}\")\n\n    # Choose the appropriate variables based on the operator type\n    variables = self.unary_variables if op_type == \"unary\" else self.binary_variables\n    self.condition_generator.set_variables(variables)\n    self.expr_generator.set_variables(variables)\n    self.logger.debug(f\"Operator variables set to: {variables}\")\n\n    # Generate the operator definition based on the choice (simple or branch definition)\n    definition = self.generate_definition(op_symbol, op_type, op_position, choice)\n    self.logger.debug(f\"Generated operator definition: {definition}\")\n\n    # Construct the operator data dictionary\n    operator_data = {\n        \"id\": None,  # The id will be assigned by OperatorManager\n        \"symbol\": op_symbol,\n        \"n_ary\": 1 if op_type == \"unary\" else 2,  # Unary operators have 1 operand, binary have 2\n        \"unary_position\": op_position if op_type == \"unary\" else None,\n        \"is_base\": None,  # Not a base operator for now\n        \"definition\": definition,\n        \"definition_type\": choice,  # The type of definition generated (simple or branch)\n        \"priority\": None,  # Priority is not assigned for now\n        \"associativity_direction\": None,  # Not assigned for now\n        \"n_order\": None,  # Dependency order will be handled by OperatorManager\n        \"op_compute_func\": None,  # Compute function will be defined by the parser\n        \"op_count_func\": None,  # Count function will be defined by the parser\n        \"properties\": None,  # Properties are not assigned for now\n        \"dependencies\": None,  # Dependencies are not yet defined\n        \"is_temporary\": True,  # Indicates that this operator is temporary\n    }\n\n    self.logger.info(f\"Generated operator data: {operator_data}\")\n    return operator_data\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_generator/#opulse.operatorplus.operator_generator.OperatorGenerator.generate_recursive_call","title":"<code>generate_recursive_call(op_symbol, op_type, op_position)</code>","text":"<p>Generates recursive expressions for binary and unary operators.</p> <p>This function creates recursive calls for both unary and binary operators based on the following rules:</p> For binary operators <ul> <li>If b == 0, generates a basic expression involving a and b.</li> <li>If b &gt; 0, generates an expression involving a and (b-1), where the expression on the right side must include (b-1).</li> <li>If b &lt; 0, generates an expression involving a and (b+1), where the expression on the right side must include (b+1).</li> </ul> For unary operators <ul> <li>If a == 0, randomly generates a number.</li> <li>If a &gt; 0, generates an expression solely involving (a-1), with its own symbol, and only related to (a-1).</li> <li>If a &lt; 0, generates an expression solely involving (a+1), with its own symbol, and only related to (a+1).</li> </ul> <p>Parameters: op_symbol (str): The operator symbol (e.g., '+', '-', '*', etc.) to be used in the expressions. op_type (str): The type of the operator. Can be either 'unary' or 'binary'. op_position (str): The position of the unary operator. Can be either 'prefix' or 'postfix' (relevant only for unary operators).</p> <p>Returns: str: A string representing the recursive expression for the operator, with conditions based on the values of 'a' and 'b'.</p> <p>Raises: ValueError: If the provided operator type is neither 'unary' nor 'binary'.</p> Source code in <code>opulse/operatorplus/operator_generator.py</code> <pre><code>def generate_recursive_call(self, op_symbol, op_type, op_position):\n    \"\"\"\n    Generates recursive expressions for binary and unary operators.\n\n    This function creates recursive calls for both unary and binary operators\n    based on the following rules:\n\n    For binary operators:\n        - If b == 0, generates a basic expression involving a and b.\n        - If b &gt; 0, generates an expression involving a and (b-1), where the expression on the right side must include (b-1).\n        - If b &lt; 0, generates an expression involving a and (b+1), where the expression on the right side must include (b+1).\n\n    For unary operators:\n        - If a == 0, randomly generates a number.\n        - If a &gt; 0, generates an expression solely involving (a-1), with its own symbol, and only related to (a-1).\n        - If a &lt; 0, generates an expression solely involving (a+1), with its own symbol, and only related to (a+1).\n\n    Parameters:\n    op_symbol (str): The operator symbol (e.g., '+', '-', '*', etc.) to be used in the expressions.\n    op_type (str): The type of the operator. Can be either 'unary' or 'binary'.\n    op_position (str): The position of the unary operator. Can be either 'prefix' or 'postfix' (relevant only for unary operators).\n\n    Returns:\n    str: A string representing the recursive expression for the operator, with conditions based on the values of 'a' and 'b'.\n\n    Raises:\n    ValueError: If the provided operator type is neither 'unary' nor 'binary'.\n    \"\"\"\n    if op_type == \"binary\":\n        # The recursive expression for generating binary operators with operands a and b.\n        self.expr_generator.set_variables([self.param_config.atoms['left_operand'], self.param_config.atoms['right_operand']])\n\n        # If b == 0, generate a basic expression with a and b.\n        expr_base = self.expr_generator.create_expression_str(atom_choice=\"variable_and_number\")\n\n        # If b &gt; 0, generate an expression involving a and (b-1) (note that the expression on the right side must include b-1).\n        recursive_variable = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['right_operand']}-1{self.param_config.atoms['right_parenthesis']}{self.param_config.atoms['right_parenthesis']}\"\n        self.expr_generator.set_variables([self.param_config.atoms['left_operand'], self.param_config.atoms['right_operand'], recursive_variable])\n        recursive_expr_1 = \"\"\n        while recursive_variable not in recursive_expr_1:\n            recursive_expr_1 = self.expr_generator.create_expression_str(atom_choice=\"variable_and_number\")\n\n        # If b &lt; 0, generate an expression involving a and (b+1).\n        recursive_variable = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['right_operand']}+1{self.param_config.atoms['right_parenthesis']}{self.param_config.atoms['right_parenthesis']}\"\n        self.expr_generator.set_variables([self.param_config.atoms['left_operand'], self.param_config.atoms['right_operand'], recursive_variable])\n        recursive_expr_2 = \"\"\n        while recursive_variable not in recursive_expr_2:\n            recursive_expr_2 = self.expr_generator.create_expression_str(atom_choice=\"variable_and_number\")\n\n        return f\"{expr_base}, if {self.param_config.atoms['right_operand']} == 0 ; {recursive_expr_1}, if {self.param_config.atoms['right_operand']} &gt; 0 ; {recursive_expr_2}, else\"\n\n    elif op_type == \"unary\":\n        # For unary operators, generate a recursive expression with a single parameter.\n        self.expr_generator.set_variables([self.param_config.atoms['left_operand']])\n\n        # If a == 0, randomly generate a number.\n        expr_base = self.expr_generator.create_expression_str(atom_choice=\"number\")\n\n        # If a &gt; 0, generate an expression solely involving (a-1), with its own symbol, and only related to (a-1).\n        if op_position == \"prefix\":\n            recursive_variable = f\"{op_symbol}({self.param_config.atoms['left_operand']}-1)\"\n        elif op_position == \"postfix\":\n            recursive_variable = f\"({self.param_config.atoms['left_operand']}-1){op_symbol}\"\n        self.expr_generator.set_variables([self.param_config.atoms['left_operand'], recursive_variable])\n        recursive_expr_1 = \"\"\n        while recursive_variable not in recursive_expr_1:\n            recursive_expr_1 = self.expr_generator.create_expression_str(atom_choice=\"variable_and_number\")\n\n        # If a &lt; 0, generate an expression solely involving (a+1), with its own symbol, and only related to (a+1).\n        if op_position == \"prefix\":\n            recursive_variable = f\"{op_symbol}({self.param_config.atoms['left_operand']}+1)\"\n        elif op_position == \"postfix\":\n            recursive_variable = f\"({self.param_config.atoms['left_operand']}+1){op_symbol}\"\n        self.expr_generator.set_variables([self.param_config.atoms['left_operand'], recursive_variable])\n        recursive_expr_2 = \"\"\n        while recursive_variable not in recursive_expr_2:\n            recursive_expr_2 = self.expr_generator.create_expression_str(atom_choice=\"variable_and_number\")\n\n        return f\"{expr_base}, if {self.param_config.atoms['left_operand']} == 0 ; {recursive_expr_1}, if {self.param_config.atoms['left_operand']} &gt; 0 ; {recursive_expr_2}, else\"\n\n    else:\n        raise ValueError(\"Unsupported operator type. Only 'unary' and 'binary' are supported.\")\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_generator/#opulse.operatorplus.operator_generator.OperatorGenerator.generate_recursive_operator_data_by_loop","title":"<code>generate_recursive_operator_data_by_loop()</code>","text":"<p>Generates recursive operator data, including both unary and binary operators,  and defines recursive computation functions for the operators. The recursion  involves calling other operators within the defined computation functions.</p> <p>This method constructs recursive operator definitions and the corresponding  computation functions for both unary and binary operators based on the  random operator type, position, and symbols. It checks recursion validity  and ensures that recursion will not lead to infinite loops.</p> <p>The generated operator data includes: - The operator's symbol - Its type (unary or binary) - A computation function - A count function - A definition for the operator's behavior</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the operator data, including the operator's    symbol, definition, and computation functions.</p> <code>None</code> <p>If the recursion validity check fails, returns None.</p> Source code in <code>opulse/operatorplus/operator_generator.py</code> <pre><code>    def generate_recursive_operator_data_by_loop(self):\n        \"\"\"\n        Generates recursive operator data, including both unary and binary operators, \n        and defines recursive computation functions for the operators. The recursion \n        involves calling other operators within the defined computation functions.\n\n        This method constructs recursive operator definitions and the corresponding \n        computation functions for both unary and binary operators based on the \n        random operator type, position, and symbols. It checks recursion validity \n        and ensures that recursion will not lead to infinite loops.\n\n        The generated operator data includes:\n        - The operator's symbol\n        - Its type (unary or binary)\n        - A computation function\n        - A count function\n        - A definition for the operator's behavior\n\n        Returns:\n            dict: A dictionary containing the operator data, including the operator's \n                  symbol, definition, and computation functions.\n            None: If the recursion validity check fails, returns None.\n        \"\"\"\n\n        self.logger.debug(\"Fetching existing operator symbols to avoid duplication.\")\n        existing_symbols = self.operator_manager.get_operator_symbols()\n\n        # Randomly select a new operator symbol\n        op_symbol = self.random_operator(existing_symbols)\n\n        self.logger.debug(f\"Selected operator symbol: {op_symbol}\")\n\n        # Randomly choose operator type (unary or binary) and position\n        # op_type, op_position = self.random_operator_type_and_position()\n        op_type, op_position = \"binary\", None\n        # Set the variables for condition and expression generators\n        variables = self.unary_variables if op_type == \"unary\" else self.binary_variables\n        self.condition_generator.set_variables(variables)\n        self.expr_generator.set_variables(variables)\n\n        # Generate the operator ID\n        id = self.operator_manager.get_next_operator_id()\n\n        self.logger.debug(f\"Generated operator ID: {id}\")\n\n        # Fetch a random recursive operator to be called in the recursion\n        called_operator_info = self.get_random_recursive_call_operator()\n        called_id = called_operator_info.id\n        called_symbol = called_operator_info.symbol\n\n        self.logger.debug(f\"Chosen operator for recursion: {called_symbol} (ID: {called_id})\")\n\n        # Generate the left-hand side expression\n        lhs = self.generate_lhs(op_symbol, op_type, op_position)\n\n        indent = \"    \"  \n        # Handle binary operator recursion\n        if op_type == \"binary\":\n            self.logger.debug(\"Generating recursive binary operator.\")\n\n            if called_operator_info.n_ary == 2:\n                # Randomly select the parameter order for recursion\n                param_order = random.choice([\n                    (\"result\", \"result\"), \n                    (\"result\", self.param_config.atoms['left_operand']), \n                    (\"result\", self.param_config.atoms['right_operand']),\n                    (self.param_config.atoms['left_operand'], \"result\"), \n                    (self.param_config.atoms['right_operand'], \"result\")\n                ])\n                param1, param2 = param_order\n\n                self.logger.debug(f\"Selected parameter order for recursion: {param_order}\")\n\n                # Check recursion validity\n                if not self.check_and_set_recursion_validity(called_operator_info, op_type, param_order):\n                    self.logger.warning(\"Recursion validity check failed.\")\n                    return None\n\n                # Generate the recursive computation function for binary operator\n                op_compute_fun = f'''def op_{id}(a, b):\n{indent}if a == 'NaN' or b == 'NaN':\n{indent*2}return 'NaN'\n{indent}result = a\n{indent}for i in range(abs(b)):\n{indent*2}result = op_{called_id}({param1}, {param2})\n{indent}return result\n'''\n                op_count_fun = f'''def op_count_{id}(a, b):\n{indent}if a == 'NaN' or b == 'NaN':\n{indent*2}return 'NaN'\n{indent}count = 0 \n{indent}for i in range(abs(b)):\n{indent*2}count += op_count_{called_id}({param1}, {param2})\n{indent}return count \n'''\n                # Generate the right-hand side expressions for the recursive function\n                if param1 == \"result\":\n                    param1_str_1 = f\"{self.param_config.atoms['left_operand']}{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['right_operand']}-1{self.param_config.atoms['right_parenthesis']}\"\n                    param1_str_2 = f\"{self.param_config.atoms['left_operand']}{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['right_operand']}+1{self.param_config.atoms['right_parenthesis']}\"\n                else:\n                    param1_str_1 = param1\n                    param1_str_2 = param1\n\n                if param2 == \"result\":\n                    param2_str_1 = f\"{self.param_config.atoms['left_operand']}{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['right_operand']}-1{self.param_config.atoms['right_parenthesis']}\"\n                    param2_str_2 = f\"{self.param_config.atoms['left_operand']}{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['right_operand']}+1{self.param_config.atoms['right_parenthesis']}\"\n                else:\n                    param2_str_1 = param2\n                    param2_str_2 = param2\n\n                rhs_1 = f\"{self.param_config.atoms['left_parenthesis']}{param1_str_1}{self.param_config.atoms['right_parenthesis']}{called_symbol}{self.param_config.atoms['left_parenthesis']}{param2_str_1}{self.param_config.atoms['right_parenthesis']}\"\n                rhs_2 = f\"{self.param_config.atoms['left_parenthesis']}{param1_str_2}{self.param_config.atoms['right_parenthesis']}{called_symbol}{self.param_config.atoms['left_parenthesis']}{param2_str_2}{self.param_config.atoms['right_parenthesis']}\"\n                definition = f\"{lhs} = {{{self.param_config.atoms['left_operand']}, if {self.param_config.atoms['right_operand']} == 0; {rhs_1}, if {self.param_config.atoms['right_operand']} &gt; 0; {rhs_2}, else}}\"\n\n                self.logger.debug(f\"Binary operator definition generated: {definition}\")\n\n            elif called_operator_info.n_ary == 1:\n                # Check recursion validity for unary call within binary operator\n                if not self.check_and_set_recursion_validity(called_operator_info, op_type, None):\n                    self.logger.warning(\"Recursion validity check failed.\")\n                    return None\n\n                # Generate recursive function for unary operator call in binary\n                op_compute_fun = f'''def op_{id}(a, b):\n{indent}if a == 'NaN' or b == 'NaN':\n{indent*2}return 'NaN'\n{indent}result = a\n{indent}for i in range(abs(b)):\n{indent*2}result = op_{called_id}(result)\n{indent}return result\n'''\n                op_count_fun = f'''def op_count_{id}(a, b):\n{indent}if a == 'NaN' or b == 'NaN':\n{indent*2}return 'NaN'\n{indent}count = 0 \n{indent}for i in range(abs(b)):\n{indent*2}count += op_count_{called_id}(result)\n{indent}return count \n'''\n\n                # Generate the right-hand side for the unary operator in binary recursion\n                param_str_1 = f\"{self.param_config.atoms['left_operand']}{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['right_operand']}-1{self.param_config.atoms['right_parenthesis']}\"\n                param_str_2 = f\"{self.param_config.atoms['left_operand']}{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['right_operand']}+1{self.param_config.atoms['right_parenthesis']}\"\n\n                if called_operator_info.unary_position == \"prefix\":\n                    rhs_1 = f\"{called_symbol}{self.param_config.atoms['left_parenthesis']}{param_str_1}{self.param_config.atoms['right_parenthesis']}\"\n                    rhs_2 = f\"{called_symbol}{self.param_config.atoms['left_parenthesis']}{param_str_2}{self.param_config.atoms['right_parenthesis']}\"\n                elif called_operator_info.unary_position == \"postfix\":\n                    rhs_1 = f\"{self.param_config.atoms['left_parenthesis']}{param_str_1}{self.param_config.atoms['right_parenthesis']}{called_symbol}\"\n                    rhs_2 = f\"{self.param_config.atoms['left_parenthesis']}{param_str_2}{self.param_config.atoms['right_parenthesis']}{called_symbol}\"\n\n                definition = f\"{lhs} = {{{self.param_config.atoms['left_operand']}, if {self.param_config.atoms['right_operand']} == 0; {rhs_1}, if {self.param_config.atoms['right_operand']} &gt; 0; {rhs_2}, else}}\"\n\n                self.logger.debug(f\"Unary operator within binary operator definition generated: {definition}\")\n\n        # Handle unary operator recursion\n        elif op_type == \"unary\":\n            self.logger.debug(\"Generating recursive unary operator.\")\n\n            if called_operator_info.n_ary == 2:\n                param_order = random.choice([(\"result\", \"result\"), (\"result\", self.param_config.atoms['left_operand']), (self.param_config.atoms['left_operand'], \"result\")])\n                param1, param2 = param_order\n\n                self.logger.debug(f\"Selected parameter order for recursion: {param_order}\")\n\n                if not self.check_and_set_recursion_validity(called_operator_info, op_type, param_order):\n                    self.logger.warning(\"Recursion validity check failed.\")\n                    return None\n\n                op_compute_fun = f'''def op_{id}(a):\n{indent}if a == 'NaN':\n{indent*2}return 'NaN'\n{indent}result = a\n{indent}for i in range(abs(a)):\n{indent*2}result = op_{called_id}({param1}, {param2})\n{indent}return result\n'''\n                op_count_fun = f'''def op_count_{id}(a):\n{indent}if a == 'NaN':\n{indent*2}return 'NaN'\n{indent}count = 0 \n{indent}for i in range(abs(a)):\n{indent*2}count += op_count_{called_id}({param1}, {param2})\n{indent}return count \n'''\n\n                if param1 == \"result\":\n                    if op_position == \"prefix\":\n                        param1_str_1 = f\"{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}-1{self.param_config.atoms['right_parenthesis']}\"\n                        param1_str_2 = f\"{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}+1{self.param_config.atoms['right_parenthesis']}\"\n                    elif op_position == \"postfix\":\n                        param1_str_1 = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}-1{self.param_config.atoms['right_parenthesis']}{op_symbol}\"\n                        param1_str_2 = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}+1{self.param_config.atoms['right_parenthesis']}{op_symbol}\"\n                else:\n                    param1_str_1 = param1\n                    param1_str_2 = param1\n\n                if param2 == \"result\":\n                    if op_position == \"prefix\":\n                        param2_str_1 = f\"{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}-1{self.param_config.atoms['right_parenthesis']}\"\n                        param2_str_2 = f\"{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}+1{self.param_config.atoms['right_parenthesis']}\"\n                    elif op_position == \"postfix\":\n                        param2_str_1 = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}-1{self.param_config.atoms['right_parenthesis']}{op_symbol}\"\n                        param2_str_2 = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}+1{self.param_config.atoms['right_parenthesis']}{op_symbol}\"\n                else:\n                    param2_str_1 = param1\n                    param2_str_2 = param1\n\n                rhs_1 = f\"{self.param_config.atoms['left_parenthesis']}{param1_str_1}{self.param_config.atoms['right_parenthesis']}{called_symbol}{self.param_config.atoms['left_parenthesis']}{param2_str_1}{self.param_config.atoms['right_parenthesis']}\"\n                rhs_2 = f\"{self.param_config.atoms['left_parenthesis']}{param1_str_2}{self.param_config.atoms['right_parenthesis']}{called_symbol}{self.param_config.atoms['left_parenthesis']}{param2_str_2}{self.param_config.atoms['right_parenthesis']}\"\n                definition = f\"{lhs} = {{{self.param_config.atoms['left_operand']}, if {self.param_config.atoms['left_operand']} == 0; {rhs_1}, if {self.param_config.atoms['left_operand']} &gt; 0; {rhs_2}, else}}\"\n\n                self.logger.debug(f\"Unary operator recursive definition generated: {definition}\")\n\n            elif called_operator_info.n_ary == 1:\n                # Check recursion validity for unary operator\n                if not self.check_and_set_recursion_validity(called_operator_info, op_type, None):\n                    self.logger.warning(\"Recursion validity check failed.\")\n                    return None\n\n                op_compute_fun = f'''def op_{id}(a):\n{indent}if a == 'NaN':\n{indent*2}return 'NaN'\n{indent}result = a\n{indent}for i in range(abs(a)):\n{indent*2}result = op_{called_id}(result)\n{indent}return result\n'''\n                op_count_fun = f'''def op_count_{id}(a):\n{indent}if a == 'NaN':\n{indent*2}return 'NaN'\n{indent}count = 0 \n{indent}for i in range(abs(a)):\n{indent*2}count += op_count_{called_id}(result)\n{indent}return count \n'''\n\n                if op_position == \"prefix\":\n                    param_str_1 = f\"{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}-1{self.param_config.atoms['right_parenthesis']}\"\n                    param_str_2 = f\"{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}+1{self.param_config.atoms['right_parenthesis']}\"\n                elif op_position == \"postfix\":\n                    param_str_1 = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}-1{self.param_config.atoms['right_parenthesis']}{op_symbol}\"\n                    param_str_2 = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}+1{self.param_config.atoms['right_parenthesis']}{op_symbol}\"\n\n                if called_operator_info.unary_position == \"prefix\":\n                    rhs_1 = f\"{called_symbol}{self.param_config.atoms['left_parenthesis']}{param_str_1}{self.param_config.atoms['right_parenthesis']}\"\n                    rhs_2 = f\"{called_symbol}{self.param_config.atoms['left_parenthesis']}{param_str_2}{self.param_config.atoms['right_parenthesis']}\"\n                elif called_operator_info.unary_position == \"postfix\":\n                    rhs_1 = f\"{self.param_config.atoms['left_parenthesis']}{param_str_1}{self.param_config.atoms['right_parenthesis']}{called_symbol}\"\n                    rhs_2 = f\"{self.param_config.atoms['left_parenthesis']}{param_str_2}{self.param_config.atoms['right_parenthesis']}{called_symbol}\"\n\n                definition = f\"{lhs} = {{{self.param_config.atoms['left_operand']}, if {self.param_config.atoms['left_operand']} == 0; {rhs_1}, if {self.param_config.atoms['left_operand']} &gt; 0; {rhs_2}, else}}\"\n\n                self.logger.debug(f\"Unary operator definition generated: {definition}\")\n        else:\n            raise ValueError(\"Unsupported operator type. Only 'unary' and 'binary' are supported.\")\n\n        operator_data = {\n            \"id\": id,  # Unique identifier for the operator.\n            \"symbol\": op_symbol,  # The symbol representing the operator (e.g., \"+\", \"-\", \"*\").\n            \"n_ary\": 1 if op_type == \"unary\" else 2,  # Arity of the operator (1 for unary, 2 for binary).\n            \"unary_position\": op_position if op_type == \"unary\" else None,  # Position of the unary operator, None for binary.\n            \"is_base\": None,  # Initially no base operator flag.\n            \"definition\": definition,  # Recursive definition of the operator.\n            \"definition_type\": \"recursive_definition\",  # Type of the definition (\"recursive_definition\").\n            \"priority\": None,  # Operator priority, not assigned yet.\n            \"associativity_direction\": None,  # Operator associativity, not assigned yet.\n            \"n_order\": None,  # Computation order, managed by OperatorManager.\n            \"op_compute_func\": op_compute_fun,  # Function to compute the operator.\n            \"op_count_func\": op_count_fun,  # Function to count operations or recursive calls.\n            \"properties\": None,  # Additional properties of the operator, None initially.\n            \"dependencies\": None,  # Dependencies of the operator, None initially.\n            \"is_temporary\": True,  # Flag indicating the operator is temporarily generated.\n        }\n\n        # Log the generated operator data for tracking purposes.\n        self.logger.info(f\"Generated operator data: {operator_data}\")\n\n        return operator_data\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_generator/#opulse.operatorplus.operator_generator.OperatorGenerator.get_random_recursive_call_operator","title":"<code>get_random_recursive_call_operator()</code>","text":"<p>Selects a random operator that supports recursion from the operator manager.</p> <p>This method filters the operators managed by the <code>operator_manager</code> to find those that have recursion enabled (i.e., <code>is_recursion_enabled</code> is True). It then selects a random operator from the filtered list and returns the corresponding <code>OperatorInfo</code> object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no operators are available in the operator manager.</p> <code>ValueError</code> <p>If no operators with recursion enabled are available.</p> <p>Returns:</p> Name Type Description <code>OperatorInfo</code> <code>OperatorInfo</code> <p>The selected operator's <code>OperatorInfo</code> object, including its ID, symbol, and other properties.</p> Source code in <code>opulse/operatorplus/operator_generator.py</code> <pre><code>def get_random_recursive_call_operator(self) -&gt; OperatorInfo:\n    \"\"\"\n    Selects a random operator that supports recursion from the operator manager.\n\n    This method filters the operators managed by the `operator_manager` to find those\n    that have recursion enabled (i.e., `is_recursion_enabled` is True). It then selects\n    a random operator from the filtered list and returns the corresponding `OperatorInfo` object.\n\n    Raises:\n        ValueError: If no operators are available in the operator manager.\n        ValueError: If no operators with recursion enabled are available.\n\n    Returns:\n        OperatorInfo: The selected operator's `OperatorInfo` object, including its ID, symbol, and other properties.\n    \"\"\"\n    self.logger.debug(\"Attempting to get a random recursive call operator.\")\n\n    # Check if there are any operators available in the operator manager\n    if not self.operator_manager.operators:\n        self.logger.error(\"No operators available in the operator manager.\")\n        raise ValueError(\"No operators available.\")\n\n    # Filter operators that have recursion enabled\n    recursive_operators = [\n        (operator_id, operator_info)\n        for operator_id, operator_info in self.operator_manager.operators.items()\n        if operator_info.is_recursion_enabled\n    ]\n\n    self.logger.debug(f\"Filtered operators with recursion enabled: {recursive_operators}\")\n\n    # If no operators with recursion are available, raise an exception\n    if not recursive_operators:\n        self.logger.error(\"No operators with recursion enabled.\")\n        raise ValueError(\"No operators with recursion enabled.\")\n\n    # Randomly select one operator from the filtered list\n    _, operator_info = random.choice(recursive_operators)\n    self.logger.debug(f\"Selected operator: {operator_info}\")\n\n    # Return the `OperatorInfo` instance instead of a tuple\n    self.logger.info(f\"Random recursive call operator selected: {operator_info}\")\n    return operator_info  # Returning an instance of OperatorInfo\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_generator/#opulse.operatorplus.operator_generator.OperatorGenerator.get_unicode_symbols","title":"<code>get_unicode_symbols()</code>","text":"<p>Collects valid Unicode operator symbols from predefined ranges.</p> <p>This method retrieves symbols from several mathematical and arrow ranges in Unicode: - Mathematical Operators (U+2200 to U+22FF) - Supplemental Mathematical Operators (U+2A00 to U+2AFF) - Arrows (U+2190 to U+21FF)</p> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of valid Unicode operator symbols.</p> Source code in <code>opulse/operatorplus/operator_generator.py</code> <pre><code>def get_unicode_symbols(self):\n    \"\"\"\n    Collects valid Unicode operator symbols from predefined ranges.\n\n    This method retrieves symbols from several mathematical and arrow ranges in Unicode:\n    - Mathematical Operators (U+2200 to U+22FF)\n    - Supplemental Mathematical Operators (U+2A00 to U+2AFF)\n    - Arrows (U+2190 to U+21FF)\n\n    Returns:\n        list: A list of valid Unicode operator symbols.\n    \"\"\"\n    self.logger.info(\"Collecting Unicode symbols from predefined ranges.\")\n    unicode_ranges = [\n        (0x2200, 0x22FF),  # Mathematical Operators\n        (0x2A00, 0x2AFF),  # Supplemental Mathematical Operators\n        (0x2190, 0x21FF),  # Arrows\n    ]\n\n    symbols = []\n\n    for start, end in unicode_ranges:\n        for codepoint in range(start, end + 1):\n            char = chr(codepoint)\n            symbols.append(char)\n\n    self.logger.debug(f\"Collected {len(symbols)} Unicode symbols.\")\n    return symbols\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_generator/#opulse.operatorplus.operator_generator.OperatorGenerator.random_operator","title":"<code>random_operator(existing_symbols)</code>","text":"<p>Generates a random operator string composed of one or more valid symbols.</p> <p>This method generates a random operator string with a length between  <code>operator_symbol_min_len</code> and <code>operator_symbol_max_len</code>, ensuring that  the generated operator does not already exist in the list of <code>existing_symbols</code>.</p> <p>Parameters:</p> Name Type Description Default <code>existing_symbols</code> <code>List[str]</code> <p>A list of currently existing operator symbols.                             The new symbol must not be in this list.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>The generated random operator string that is unique and within the specified length range.</p> Source code in <code>opulse/operatorplus/operator_generator.py</code> <pre><code>def random_operator(self, existing_symbols: List[str]):\n    \"\"\"\n    Generates a random operator string composed of one or more valid symbols.\n\n    This method generates a random operator string with a length between \n    `operator_symbol_min_len` and `operator_symbol_max_len`, ensuring that \n    the generated operator does not already exist in the list of `existing_symbols`.\n\n    Parameters:\n        existing_symbols (List[str]): A list of currently existing operator symbols.\n                                        The new symbol must not be in this list.\n\n    Returns:\n        str: The generated random operator string that is unique and within the specified length range.\n    \"\"\"\n    self.logger.info(\"Generating a random operator string.\")\n\n    # Loop until a unique operator is generated\n    while True:\n        # Randomly choose a length for the operator within the specified range\n        length = random.randint(self.operator_symbol_min_len, self.operator_symbol_max_len)\n\n        # Generate the new symbol by randomly picking characters from valid symbols\n        new_symbol = \"\".join(random.choice(self.valid_symbols) for _ in range(length))\n\n        # Check if the generated symbol is unique (not in existing_symbols)\n        if new_symbol not in existing_symbols:\n            self.logger.debug(f\"Generated new operator symbol: {new_symbol} with length {length}.\")\n            return new_symbol\n        else:\n            self.logger.debug(f\"Generated operator {new_symbol} already exists. Retrying...\")\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_generator/#opulse.operatorplus.operator_generator.OperatorGenerator.random_operator_type_and_position","title":"<code>random_operator_type_and_position()</code>","text":"<p>Generates a random operator type and its position (if applicable).</p> <p>This method randomly selects an operator type, either \"unary\" or \"binary\". If the type is \"unary\", it also randomly chooses its position, either \"prefix\" or \"postfix\". For \"binary\" operators, the position is not applicable (set to None).</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing the operator type and its position. If the operator type is \"unary\", the position is either \"prefix\" or \"postfix\". If the operator type is \"binary\", the position is None.</p> Source code in <code>opulse/operatorplus/operator_generator.py</code> <pre><code>def random_operator_type_and_position(self):\n    \"\"\"\n    Generates a random operator type and its position (if applicable).\n\n    This method randomly selects an operator type, either \"unary\" or \"binary\".\n    If the type is \"unary\", it also randomly chooses its position, either \"prefix\" or \"postfix\".\n    For \"binary\" operators, the position is not applicable (set to None).\n\n    Returns:\n        tuple: A tuple containing the operator type and its position.\n            If the operator type is \"unary\", the position is either \"prefix\" or \"postfix\".\n            If the operator type is \"binary\", the position is None.\n    \"\"\"\n    self.logger.info(\"Generating random operator type and position.\")\n\n    # Randomly select the operator type\n    op_type = random.choice([\"unary\", \"binary\"])\n\n    # Initialize unary_position as None\n    unary_position = None\n\n    # If the operator type is \"unary\", randomly choose its position\n    if op_type == \"unary\":\n        unary_position = random.choice([\"prefix\", \"postfix\"])\n\n    # Log the final operator type and position\n    self.logger.info(f\"Operator type: {op_type}, Position: {unary_position if unary_position else 'None'}\")\n\n    return op_type, unary_position\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_generator/#opulse.operatorplus.operator_generator.OperatorGenerator.set_bit_if_not_set","title":"<code>set_bit_if_not_set(called_operator_info, bit_position)</code>","text":"<p>Sets a specific bit in the <code>recursive_used_cases</code> attribute of the given operator if that bit is not already set. The method also checks the number of recursive cases  used and disables recursion if certain conditions are met.</p> <p>This function performs the following actions: 1. Checks if the bit at <code>bit_position</code> is 0. 2. If it is 0, sets the bit to 1. 3. If the operator is unary (n_ary == 1) and all bits in the first 2 positions are set, recursion is disabled. 4. If the operator is binary (n_ary == 2) and all bits in the first 8 positions are set, recursion is disabled.</p> <p>Parameters:</p> Name Type Description Default <code>called_operator_info</code> <code>OperatorInfo</code> <p>The operator whose <code>recursive_used_cases</code> attribute is to be modified.</p> required <code>bit_position</code> <code>int</code> <p>The bit position to check and set.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>Returns <code>True</code> if the bit was successfully set, <code>False</code> if the bit was already set.</p> Source code in <code>opulse/operatorplus/operator_generator.py</code> <pre><code>def set_bit_if_not_set(self, called_operator_info, bit_position):\n    \"\"\"\n    Sets a specific bit in the `recursive_used_cases` attribute of the given operator\n    if that bit is not already set. The method also checks the number of recursive cases \n    used and disables recursion if certain conditions are met.\n\n    This function performs the following actions:\n    1. Checks if the bit at `bit_position` is 0.\n    2. If it is 0, sets the bit to 1.\n    3. If the operator is unary (n_ary == 1) and all bits in the first 2 positions are set, recursion is disabled.\n    4. If the operator is binary (n_ary == 2) and all bits in the first 8 positions are set, recursion is disabled.\n\n    Args:\n        called_operator_info (OperatorInfo): The operator whose `recursive_used_cases` attribute is to be modified.\n        bit_position (int): The bit position to check and set.\n\n    Returns:\n        bool: Returns `True` if the bit was successfully set, `False` if the bit was already set.\n\n    \"\"\"\n    self.logger.debug(f\"Checking bit position {bit_position} in operator {called_operator_info.symbol}.\")\n\n    # Check if the bit at the given position is 0\n    if (called_operator_info.recursive_used_cases &amp; (1 &lt;&lt; bit_position)) == 0:\n        # If the bit is 0, set it to 1\n        called_operator_info.recursive_used_cases |= (1 &lt;&lt; bit_position)\n        self.logger.debug(f\"Bit {bit_position} was not set. Setting it now. Updated recursive_used_cases: {bin(called_operator_info.recursive_used_cases)}\")\n\n        # Check conditions for disabling recursion for unary or binary operators\n        if called_operator_info.n_ary == 1:\n            if called_operator_info.recursive_used_cases == 0b00000011:\n                called_operator_info.is_recursion_enabled = False\n                self.logger.info(f\"Recursion disabled for unary operator {called_operator_info.symbol} due to recursive_used_cases: {bin(called_operator_info.recursive_used_cases)}\")\n        elif called_operator_info.n_ary == 2:\n            if called_operator_info.recursive_used_cases == 0b11111111:\n                called_operator_info.is_recursion_enabled = False\n                self.logger.info(f\"Recursion disabled for binary operator {called_operator_info.symbol} due to recursive_used_cases: {bin(called_operator_info.recursive_used_cases)}\")\n\n        return True\n    else:\n        self.logger.debug(f\"Bit {bit_position} is already set for operator {called_operator_info.symbol}. No action taken.\")\n        return False\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_info/","title":"Operator info","text":""},{"location":"Core%20API/operatorplus/operator_info/#opulse.operatorplus.operator_info.OperatorInfo","title":"<code>OperatorInfo</code>","text":"Source code in <code>opulse/operatorplus/operator_info.py</code> <pre><code>class OperatorInfo:\n    def __init__(\n        self,\n        id: int,\n        symbol: str,\n        n_ary: int,  # 1 for unary, 2 for binary\n        unary_position: Optional[str],  # 'prefix', 'postfix', or None\n        is_base: Optional[int],  # Used to identify the base type, e.g., 2 for binary, 10 for decimal, 16 for hexadecimal\n        definition: Optional[str],\n        definition_type: Optional[str],  # Types: simple_definition, recursive_definition, branch_definition\n        priority: int,  # Priority for operations with the same level, higher values represent higher priority\n        associativity_direction: Optional[str],  # 'left', 'right', or None\n        n_order: int,  # Order, used to measure complexity, particularly for recursive definitions\n        op_compute_func: Optional[\n            str\n        ],  # Function code for the operator, e.g., \"def op_11(a, b): ...\"\n        op_count_func: Optional[str],  # Function code to calculate the count, e.g., base = 0\n        z3_compute_func: Optional[str] = None, ##TODO:Still in the process of realising, Used for constraint solving\n        properties: Optional[Dict[str, bool]] = None,  # Other properties such as \"commutative\", \"associative\", \"idempotent\", etc.\n        dependencies: Optional[List[int]] = None,  # Record dependencies on other operators\n        is_temporary: bool = False,  # Whether the operator is temporary (for incomplete information)\n        recursive_used_cases: int = 0b00000000,  # Record used recursive cases\n        is_recursion_enabled: bool = True  # Whether recursion can still be enabled based on the recursive type\n    ):\n        \"\"\"\n        Initializes the OperatorInfo object with various parameters describing the operator's properties.\n\n        Args:\n            id (int): Unique identifier for the operator.\n            symbol (str): Symbol representing the operator.\n            n_ary (int): Arity of the operator, either 1 for unary or 2 for binary.\n            unary_position (Optional[str]): Position for unary operators ('prefix', 'postfix', or None).\n            is_base (Optional[int]): Base type identifier (e.g., 2 for binary, 10 for decimal).\n            definition (Optional[str]): Definition of the operator (could be a string representation of the definition).\n            definition_type (Optional[str]): Type of definition ('simple_definition', 'recursive_definition', or 'branch_definition').\n            priority (int): Priority of the operator, higher means higher priority.\n            associativity_direction (Optional[str]): Direction of associativity ('left', 'right', or None).\n            n_order (int): Order to measure complexity, especially for recursive operators.\n            op_compute_func (Optional[str]): Code string for computing the operator's result.\n            op_count_func (Optional[str]): Code string for counting the operations.\n            properties (Optional[Dict[str, bool]]): Additional properties of the operator (commutative, associative, etc.).\n            dependencies (Optional[List[int]]): List of dependencies on other operators.\n            is_temporary (bool): Whether the operator is temporary, typically used when its information is incomplete.\n            recursive_used_cases (int): Record of the recursive cases used.\n            is_recursion_enabled (bool): Whether recursion is still allowed for this operator.\n        \"\"\"\n        self.id = id\n        self.symbol = symbol\n        self.n_ary = n_ary\n        self.unary_position = unary_position\n        self.is_base = is_base\n        self.definition = definition\n        self.definition_type = definition_type\n        self.priority = priority\n        self.associativity_direction = associativity_direction\n        self.n_order = n_order\n        self.op_compute_func = op_compute_func\n        self.op_count_func = op_count_func\n        self.z3_compute_func = z3_compute_func\n        self.properties = properties\n        self.dependencies = dependencies\n        self.is_temporary = is_temporary\n        self.recursive_used_cases = recursive_used_cases\n        self.is_recursion_enabled = is_recursion_enabled\n        self.compiled_functions = {}  # Cache compiled functions to avoid recompiling\n\n    def __repr__(self):\n        \"\"\"\n        Provides a string representation of the operator information object.\n\n        Returns:\n            str: A string representation of the OperatorInfo object.\n        \"\"\"\n        return (\n            f\"OperatorInfo(id={self.id}, symbol='{self.symbol}', n_ary={self.n_ary}, \"\n            f\"unary_position={self.unary_position!r}, is_base={self.is_base}, \"\n            f\"definition={self.definition!r}, definition_type={self.definition_type!r}, \"\n            f\"priority={self.priority}, \"\n            f\"associativity_direction={self.associativity_direction!r}, n_order={self.n_order}, \"\n            f\"op_compute_func={self.op_compute_func!r}, op_count_func={self.op_count_func!r}, \"\n            # f\"properties={self.properties!r}, \"\n            f\"dependencies={self.dependencies!r}, \"\n            f\"compiled_functions={'{}' if not self.compiled_functions else f'{{...}}'})\"\n        )\n\n    def to_json(self) -&gt; str:\n        \"\"\"\n        Converts the operator information object to a JSON string, excluding temporary and compiled function data.\n\n        Returns:\n            str: A JSON string representing the OperatorInfo object.\n        \"\"\"\n        serializable_dict = self.__dict__.copy()\n        # Remove attributes that should not be serialized\n        for key in ['properties','is_temporary', 'recursive_used_cases', 'is_recursion_enabled', 'compiled_functions']:\n            serializable_dict.pop(key, None)\n        return json.dumps(serializable_dict, ensure_ascii=False)\n\n    @staticmethod\n    def from_json(json_str: str) -&gt; \"OperatorInfo\":\n        \"\"\"\n        Creates an OperatorInfo object from a JSON string.\n\n        Args:\n            json_str (str): A JSON string representing an OperatorInfo object.\n\n        Returns:\n            OperatorInfo: An instance of the OperatorInfo class initialized from the JSON data.\n        \"\"\"\n        data = json.loads(json_str)\n        return OperatorInfo(**data)\n\n    def get_compute_function(\n        self, available_funcs: Dict[str, Any] = None\n    ) -&gt; Optional[Any]:\n        \"\"\"\n        Retrieves the compute function for the operator, compiling it if necessary, and handling dependencies.\n\n        Args:\n            available_funcs (Dict[str, Any], optional): A dictionary of available functions that can be used by the operator's function.\n\n        Returns:\n            Optional[Any]: The compiled function object or None if it cannot be compiled.\n        \"\"\"\n        available_funcs = available_funcs or {}\n        return self._compile_function(\n            self.op_compute_func, f\"op_{self.id}\", available_funcs\n        )\n\n    def get_count_function(\n        self, available_funcs: Dict[str, Any] = None\n    ) -&gt; Optional[Any]:\n        \"\"\"\n        Retrieves the count function for the operator, compiling it if necessary, and handling dependencies.\n\n        Args:\n            available_funcs (Dict[str, Any], optional): A dictionary of available functions that can be used by the operator's function.\n\n        Returns:\n            Optional[Any]: The compiled function object or None if it cannot be compiled.\n        \"\"\"\n        available_funcs = available_funcs or {}\n        return self._compile_function(\n            self.op_count_func, f\"op_count_{self.id}\", available_funcs\n        )\n\n    def _compile_function(\n        self, func_code: Optional[str], func_name: str, available_funcs: Dict[str, Any]\n    ) -&gt; Optional[Any]:\n        \"\"\"\n        Compiles a given function code string into an executable function object, caching it for future use.\n\n        Args:\n            func_code (Optional[str]): The code for the function to be compiled.\n            func_name (str): The name of the function being compiled.\n            available_funcs (Dict[str, Any]): A dictionary of functions available in the current context.\n\n        Returns:\n            Optional[Any]: The compiled function object, or None if compilation fails.\n        \"\"\"\n        if not func_code:\n            return None\n        if func_name in self.compiled_functions:\n            return self.compiled_functions[func_name]\n\n        try:\n            # Create a local namespace and add available functions\n            local_namespace = {}\n            local_namespace.update(available_funcs)\n\n            # Execute the function code in the local namespace to compile the function\n            exec(func_code, local_namespace, local_namespace)\n            compiled_func = local_namespace.get(func_name, None)\n            self.compiled_functions[func_name] = compiled_func  # Cache the compiled function\n            return compiled_func\n        except Exception as e:\n            print(f\"Error compiling function '{func_name}' for operator '{self.symbol}': {e}\")\n            return None\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_info/#opulse.operatorplus.operator_info.OperatorInfo.__init__","title":"<code>__init__(id, symbol, n_ary, unary_position, is_base, definition, definition_type, priority, associativity_direction, n_order, op_compute_func, op_count_func, z3_compute_func=None, properties=None, dependencies=None, is_temporary=False, recursive_used_cases=0, is_recursion_enabled=True)</code>","text":"<p>Initializes the OperatorInfo object with various parameters describing the operator's properties.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>Unique identifier for the operator.</p> required <code>symbol</code> <code>str</code> <p>Symbol representing the operator.</p> required <code>n_ary</code> <code>int</code> <p>Arity of the operator, either 1 for unary or 2 for binary.</p> required <code>unary_position</code> <code>Optional[str]</code> <p>Position for unary operators ('prefix', 'postfix', or None).</p> required <code>is_base</code> <code>Optional[int]</code> <p>Base type identifier (e.g., 2 for binary, 10 for decimal).</p> required <code>definition</code> <code>Optional[str]</code> <p>Definition of the operator (could be a string representation of the definition).</p> required <code>definition_type</code> <code>Optional[str]</code> <p>Type of definition ('simple_definition', 'recursive_definition', or 'branch_definition').</p> required <code>priority</code> <code>int</code> <p>Priority of the operator, higher means higher priority.</p> required <code>associativity_direction</code> <code>Optional[str]</code> <p>Direction of associativity ('left', 'right', or None).</p> required <code>n_order</code> <code>int</code> <p>Order to measure complexity, especially for recursive operators.</p> required <code>op_compute_func</code> <code>Optional[str]</code> <p>Code string for computing the operator's result.</p> required <code>op_count_func</code> <code>Optional[str]</code> <p>Code string for counting the operations.</p> required <code>properties</code> <code>Optional[Dict[str, bool]]</code> <p>Additional properties of the operator (commutative, associative, etc.).</p> <code>None</code> <code>dependencies</code> <code>Optional[List[int]]</code> <p>List of dependencies on other operators.</p> <code>None</code> <code>is_temporary</code> <code>bool</code> <p>Whether the operator is temporary, typically used when its information is incomplete.</p> <code>False</code> <code>recursive_used_cases</code> <code>int</code> <p>Record of the recursive cases used.</p> <code>0</code> <code>is_recursion_enabled</code> <code>bool</code> <p>Whether recursion is still allowed for this operator.</p> <code>True</code> Source code in <code>opulse/operatorplus/operator_info.py</code> <pre><code>def __init__(\n    self,\n    id: int,\n    symbol: str,\n    n_ary: int,  # 1 for unary, 2 for binary\n    unary_position: Optional[str],  # 'prefix', 'postfix', or None\n    is_base: Optional[int],  # Used to identify the base type, e.g., 2 for binary, 10 for decimal, 16 for hexadecimal\n    definition: Optional[str],\n    definition_type: Optional[str],  # Types: simple_definition, recursive_definition, branch_definition\n    priority: int,  # Priority for operations with the same level, higher values represent higher priority\n    associativity_direction: Optional[str],  # 'left', 'right', or None\n    n_order: int,  # Order, used to measure complexity, particularly for recursive definitions\n    op_compute_func: Optional[\n        str\n    ],  # Function code for the operator, e.g., \"def op_11(a, b): ...\"\n    op_count_func: Optional[str],  # Function code to calculate the count, e.g., base = 0\n    z3_compute_func: Optional[str] = None, ##TODO:Still in the process of realising, Used for constraint solving\n    properties: Optional[Dict[str, bool]] = None,  # Other properties such as \"commutative\", \"associative\", \"idempotent\", etc.\n    dependencies: Optional[List[int]] = None,  # Record dependencies on other operators\n    is_temporary: bool = False,  # Whether the operator is temporary (for incomplete information)\n    recursive_used_cases: int = 0b00000000,  # Record used recursive cases\n    is_recursion_enabled: bool = True  # Whether recursion can still be enabled based on the recursive type\n):\n    \"\"\"\n    Initializes the OperatorInfo object with various parameters describing the operator's properties.\n\n    Args:\n        id (int): Unique identifier for the operator.\n        symbol (str): Symbol representing the operator.\n        n_ary (int): Arity of the operator, either 1 for unary or 2 for binary.\n        unary_position (Optional[str]): Position for unary operators ('prefix', 'postfix', or None).\n        is_base (Optional[int]): Base type identifier (e.g., 2 for binary, 10 for decimal).\n        definition (Optional[str]): Definition of the operator (could be a string representation of the definition).\n        definition_type (Optional[str]): Type of definition ('simple_definition', 'recursive_definition', or 'branch_definition').\n        priority (int): Priority of the operator, higher means higher priority.\n        associativity_direction (Optional[str]): Direction of associativity ('left', 'right', or None).\n        n_order (int): Order to measure complexity, especially for recursive operators.\n        op_compute_func (Optional[str]): Code string for computing the operator's result.\n        op_count_func (Optional[str]): Code string for counting the operations.\n        properties (Optional[Dict[str, bool]]): Additional properties of the operator (commutative, associative, etc.).\n        dependencies (Optional[List[int]]): List of dependencies on other operators.\n        is_temporary (bool): Whether the operator is temporary, typically used when its information is incomplete.\n        recursive_used_cases (int): Record of the recursive cases used.\n        is_recursion_enabled (bool): Whether recursion is still allowed for this operator.\n    \"\"\"\n    self.id = id\n    self.symbol = symbol\n    self.n_ary = n_ary\n    self.unary_position = unary_position\n    self.is_base = is_base\n    self.definition = definition\n    self.definition_type = definition_type\n    self.priority = priority\n    self.associativity_direction = associativity_direction\n    self.n_order = n_order\n    self.op_compute_func = op_compute_func\n    self.op_count_func = op_count_func\n    self.z3_compute_func = z3_compute_func\n    self.properties = properties\n    self.dependencies = dependencies\n    self.is_temporary = is_temporary\n    self.recursive_used_cases = recursive_used_cases\n    self.is_recursion_enabled = is_recursion_enabled\n    self.compiled_functions = {}  # Cache compiled functions to avoid recompiling\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_info/#opulse.operatorplus.operator_info.OperatorInfo.__repr__","title":"<code>__repr__()</code>","text":"<p>Provides a string representation of the operator information object.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>A string representation of the OperatorInfo object.</p> Source code in <code>opulse/operatorplus/operator_info.py</code> <pre><code>def __repr__(self):\n    \"\"\"\n    Provides a string representation of the operator information object.\n\n    Returns:\n        str: A string representation of the OperatorInfo object.\n    \"\"\"\n    return (\n        f\"OperatorInfo(id={self.id}, symbol='{self.symbol}', n_ary={self.n_ary}, \"\n        f\"unary_position={self.unary_position!r}, is_base={self.is_base}, \"\n        f\"definition={self.definition!r}, definition_type={self.definition_type!r}, \"\n        f\"priority={self.priority}, \"\n        f\"associativity_direction={self.associativity_direction!r}, n_order={self.n_order}, \"\n        f\"op_compute_func={self.op_compute_func!r}, op_count_func={self.op_count_func!r}, \"\n        # f\"properties={self.properties!r}, \"\n        f\"dependencies={self.dependencies!r}, \"\n        f\"compiled_functions={'{}' if not self.compiled_functions else f'{{...}}'})\"\n    )\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_info/#opulse.operatorplus.operator_info.OperatorInfo.from_json","title":"<code>from_json(json_str)</code>  <code>staticmethod</code>","text":"<p>Creates an OperatorInfo object from a JSON string.</p> <p>Parameters:</p> Name Type Description Default <code>json_str</code> <code>str</code> <p>A JSON string representing an OperatorInfo object.</p> required <p>Returns:</p> Name Type Description <code>OperatorInfo</code> <code>OperatorInfo</code> <p>An instance of the OperatorInfo class initialized from the JSON data.</p> Source code in <code>opulse/operatorplus/operator_info.py</code> <pre><code>@staticmethod\ndef from_json(json_str: str) -&gt; \"OperatorInfo\":\n    \"\"\"\n    Creates an OperatorInfo object from a JSON string.\n\n    Args:\n        json_str (str): A JSON string representing an OperatorInfo object.\n\n    Returns:\n        OperatorInfo: An instance of the OperatorInfo class initialized from the JSON data.\n    \"\"\"\n    data = json.loads(json_str)\n    return OperatorInfo(**data)\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_info/#opulse.operatorplus.operator_info.OperatorInfo.get_compute_function","title":"<code>get_compute_function(available_funcs=None)</code>","text":"<p>Retrieves the compute function for the operator, compiling it if necessary, and handling dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>available_funcs</code> <code>Dict[str, Any]</code> <p>A dictionary of available functions that can be used by the operator's function.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Any]</code> <p>Optional[Any]: The compiled function object or None if it cannot be compiled.</p> Source code in <code>opulse/operatorplus/operator_info.py</code> <pre><code>def get_compute_function(\n    self, available_funcs: Dict[str, Any] = None\n) -&gt; Optional[Any]:\n    \"\"\"\n    Retrieves the compute function for the operator, compiling it if necessary, and handling dependencies.\n\n    Args:\n        available_funcs (Dict[str, Any], optional): A dictionary of available functions that can be used by the operator's function.\n\n    Returns:\n        Optional[Any]: The compiled function object or None if it cannot be compiled.\n    \"\"\"\n    available_funcs = available_funcs or {}\n    return self._compile_function(\n        self.op_compute_func, f\"op_{self.id}\", available_funcs\n    )\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_info/#opulse.operatorplus.operator_info.OperatorInfo.get_count_function","title":"<code>get_count_function(available_funcs=None)</code>","text":"<p>Retrieves the count function for the operator, compiling it if necessary, and handling dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>available_funcs</code> <code>Dict[str, Any]</code> <p>A dictionary of available functions that can be used by the operator's function.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Any]</code> <p>Optional[Any]: The compiled function object or None if it cannot be compiled.</p> Source code in <code>opulse/operatorplus/operator_info.py</code> <pre><code>def get_count_function(\n    self, available_funcs: Dict[str, Any] = None\n) -&gt; Optional[Any]:\n    \"\"\"\n    Retrieves the count function for the operator, compiling it if necessary, and handling dependencies.\n\n    Args:\n        available_funcs (Dict[str, Any], optional): A dictionary of available functions that can be used by the operator's function.\n\n    Returns:\n        Optional[Any]: The compiled function object or None if it cannot be compiled.\n    \"\"\"\n    available_funcs = available_funcs or {}\n    return self._compile_function(\n        self.op_count_func, f\"op_count_{self.id}\", available_funcs\n    )\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_info/#opulse.operatorplus.operator_info.OperatorInfo.to_json","title":"<code>to_json()</code>","text":"<p>Converts the operator information object to a JSON string, excluding temporary and compiled function data.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A JSON string representing the OperatorInfo object.</p> Source code in <code>opulse/operatorplus/operator_info.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"\n    Converts the operator information object to a JSON string, excluding temporary and compiled function data.\n\n    Returns:\n        str: A JSON string representing the OperatorInfo object.\n    \"\"\"\n    serializable_dict = self.__dict__.copy()\n    # Remove attributes that should not be serialized\n    for key in ['properties','is_temporary', 'recursive_used_cases', 'is_recursion_enabled', 'compiled_functions']:\n        serializable_dict.pop(key, None)\n    return json.dumps(serializable_dict, ensure_ascii=False)\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_manager/","title":"Operator manager","text":""},{"location":"Core%20API/operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager","title":"<code>OperatorManager</code>","text":"Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>class OperatorManager:\n    def __init__(\n        self, \n        config_file: str,\n        param_config: ParamConfig,\n        logger: LogConfig\n    ):\n        self.config_file = config_file\n        self.param_config = param_config\n        self.logger = logger.get_logger()\n        self.operators: Dict[int, OperatorInfo] = (\n            {}\n        )  # key: operator id, value: OperatorInfo\n        self.symbol_to_operators: Dict[str, List[OperatorInfo]] = defaultdict(\n            list\n        )  # key: operator symbol, value: list of OperatorInfo\n        self.base_operators: Dict[int, List[OperatorInfo]] = defaultdict(list)\n        # key: is_base, value: list of OperatorInfo\n\n        self.available_funcs: Dict[str, Any] = {}  # to store available functions\n        self.load_operators()\n        self.temp_file_path = \"data/operator/temp_operators.temp\"  # Temporary file path\n\n    def load_operators(self):\n        \"\"\"\n        Loads operator definitions from a JSONL file.\n\n        This method reads the configuration file line by line, parses each line into an\n        `OperatorInfo` object, and stores the operators in various structures:\n        - `self.operators`: A dictionary with operator ID as the key and `OperatorInfo` as the value.\n        - `self.symbol_to_operators`: A dictionary with operator symbol as the key and a list of `OperatorInfo` as the value.\n        - `self.base_operators`: A dictionary to store base operators based on their base status.\n\n        Additionally, it updates the available functions for computation and counting based on the loaded operators.\n\n        Logs relevant information about the loading process for monitoring and debugging purposes.\n        \"\"\"\n        self.logger.info(f\"Loading operators from configuration file: {self.config_file}\")\n\n        with open(self.config_file, \"r\", encoding=\"utf-8\") as f:\n            line_count = 0\n            for line in f:\n                line_count += 1\n                if not line.strip():\n                    self.logger.debug(f\"Skipping empty line {line_count}.\")\n                    continue  # Skip empty lines\n                try:\n                    operator = OperatorInfo.from_json(line)\n                    self.operators[operator.id] = operator\n                    self.symbol_to_operators[operator.symbol].append(operator)\n\n                    # Update available functions for the operator\n                    if operator.is_base:\n                        self.base_operators[operator.is_base].append(operator)\n\n                    self._update_available_funcs(operator)\n                    self.logger.debug(f\"Loaded operator {operator.id} ({operator.symbol}) from line {line_count}.\")\n\n                except Exception as e:\n                    self.logger.warning(f\"Failed to parse operator from line {line_count}: {e}\")\n\n        self.logger.info(f\"Successfully loaded {len(self.operators)} operators from the configuration file.\")\n\n    def save_operators_to_jsonl(self, file_path: str):\n        \"\"\"\n        Saves all operators to a JSONL file.\n\n        This method serializes each operator in `self.operators` and writes it to the specified file path in JSONL format.\n\n        Args:\n            file_path (str): The path to the file where the operators should be saved.\n\n        Logs the process of saving operators to the file.\n        \"\"\"\n        self.logger.info(f\"Saving operators to {file_path}.\")\n\n        with open(file_path, \"w\", encoding=\"utf-8\") as file:\n            for operator in self.operators.values():\n                json_line = operator.to_json()\n                file.write(json_line + \"\\n\")\n                self.logger.debug(f\"Saved operator {operator.id} ({operator.symbol}) to {file_path}.\")\n\n        self.logger.info(f\"Successfully saved all operators to {file_path}.\")\n\n    def save_operator_to_temp(self, operator):\n        \"\"\"\n        Saves a single operator to a temporary file.\n\n        This method serializes the given operator and appends it to a temporary file defined in `self.temp_file_path`.\n\n        Args:\n            operator (OperatorInfo): The operator to be saved.\n\n        Logs the process of saving the operator to the temporary file.\n        \"\"\"\n        self.logger.info(f\"Saving operator {operator.id} ({operator.symbol}) to temporary file.\")\n\n        with open(self.temp_file_path, 'a', encoding=\"utf-8\") as temp_file:\n            json_line = operator.to_json()\n            temp_file.write(json_line + \"\\n\")\n            self.logger.debug(f\"Operator {operator.id} ({operator.symbol}) saved to temporary file.\")\n\n    def clear_temp_file(self):\n        \"\"\"\n        Clears the temporary file by removing it if it exists.\n\n        This method checks if the temporary file exists and removes it. If the file doesn't exist, a warning is logged.\n        In case of any error during file removal, an error log is generated.\n\n        Logs the status of the file clearance operation.\n        \"\"\"\n        try:\n            if os.path.exists(self.temp_file_path):\n                os.remove(self.temp_file_path)\n                self.logger.info(f\"Temporary file {self.temp_file_path} cleared.\")\n            else:\n                self.logger.warning(f\"Temporary file {self.temp_file_path} does not exist.\")\n        except Exception as e:\n            self.logger.error(f\"Error clearing temporary file: {e}\")\n\n    def rename_temp_to_jsonl(self, file_path: str):\n        \"\"\"Renames the temporary file to the specified file_path.\"\"\"\n        # Ensure the temporary file exists at self.temp_file_path\n        if os.path.exists(self.temp_file_path):\n            # If the destination file doesn't exist, create it\n            if not os.path.exists(file_path):\n                # Create an empty file at the destination path\n                open(file_path, 'w', encoding=\"utf-8\").close()\n\n            try:\n                # Now, rename the temporary file to the specified file_path\n                os.rename(self.temp_file_path, file_path)\n                self.logger.info(f\"Renamed temporary file {self.temp_file_path} to {file_path}\")\n            except OSError as e:\n                self.logger.error(f\"Error renaming file {self.temp_file_path} to {file_path}: {e}\")\n        else:\n            self.logger.warning(f\"Temporary file not found: {self.temp_file_path}\")\n\n    def _update_available_funcs(self, operator: OperatorInfo):\n        \"\"\"\n        Update available_funcs with the compute and count functions of the given operator.\n        \"\"\"\n        if operator.op_compute_func:\n            self.available_funcs[f\"op_{operator.id}\"] = operator.get_compute_function(\n                self.available_funcs\n            )\n        if operator.op_count_func:\n            self.available_funcs[f\"op_count_{operator.id}\"] = (\n                operator.get_count_function(self.available_funcs)\n            )\n\n    def get_available_funcs(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Returns the available functions (compute and count functions).\n        \"\"\"\n        return self.available_funcs\n\n    def add_available_funcs(self, operator: OperatorInfo):\n        \"\"\"\n        Updates the available functions whenever a new operator is added.\n        \"\"\"\n        self._update_available_funcs(operator)\n\n    def get_next_operator_id(self) -&gt; int:\n        \"\"\"\n        Retrieves the next available operator ID.\n\n        This method checks if there are existing operators, and if so, returns the next ID based on the \n        current maximum operator ID. If there are no operators, it starts from ID 1.\n\n        Returns:\n            int: The next available operator ID.\n        \"\"\"\n        self.logger.debug(\"Getting the next available operator ID.\")\n\n        if not self.operators:\n            self.logger.debug(\"No operators found, starting from ID 1.\")\n            return 1\n\n        # Get the current maximum operator ID\n        max_id = max(self.operators.keys())\n\n        # Return the next ID\n        self.logger.debug(f\"Current maximum operator ID is {max_id}. Returning next ID: {max_id + 1}.\")\n        return max_id + 1\n\n    def get_operator_by_id(self, op_id: int) -&gt; OperatorInfo:\n        \"\"\"\n        Retrieves an operator by its ID.\n\n        Args:\n            op_id (int): The operator ID.\n\n        Returns:\n            OperatorInfo: The operator corresponding to the given ID.\n\n        Raises:\n            ValueError: If the operator ID does not exist.\n        \"\"\"\n        self.logger.debug(f\"Fetching operator with ID {op_id}.\")\n\n        if op_id not in self.operators:\n            self.logger.error(f\"Operator ID {op_id} does not exist.\")\n            raise ValueError(f\"Operator ID {op_id} does not exist.\")\n\n        self.logger.debug(f\"Operator ID {op_id} found.\")\n        return self.operators[op_id]\n\n    def get_operators_by_symbol(self, symbol: str) -&gt; List[OperatorInfo]:\n        \"\"\"\n        Retrieves all operators corresponding to a given symbol.\n\n        Args:\n            symbol (str): The operator symbol.\n\n        Returns:\n            List[OperatorInfo]: A list of operators corresponding to the symbol.\n        \"\"\"\n        self.logger.debug(f\"Fetching operators with symbol '{symbol}'.\")\n\n        operators = self.symbol_to_operators.get(symbol, [])\n\n        self.logger.debug(f\"Found {len(operators)} operators for symbol '{symbol}'.\")\n        return operators\n\n    def get_operator_symbols(self) -&gt; List[str]:\n        \"\"\"\n        Retrieves a list of all operator symbols.\n\n        Returns:\n            List[str]: A list of operator symbols.\n        \"\"\"\n        self.logger.debug(\"Fetching all operator symbols.\")\n\n        symbols = list(self.symbol_to_operators.keys())\n\n        self.logger.debug(f\"Found {len(symbols)} operator symbols.\")\n        return symbols\n\n    def get_operator_function_id(\n        self, operator_symbol: str, is_unary: bool\n    ) -&gt; Optional[tuple[int, bool]]:\n        \"\"\"\n        Retrieves the function ID and temporary status of an operator based on its symbol and type (unary or binary).\n\n        Args:\n            operator_symbol (str): The operator symbol.\n            is_unary (bool): A boolean indicating whether the operator is unary (True) or binary (False).\n\n        Returns:\n            Optional[tuple[int, bool]]: A tuple containing the operator's function ID and its temporary status.\n                                        If no matching operator is found, returns (None, False).\n        \"\"\"\n        self.logger.debug(f\"Fetching function ID for operator symbol '{operator_symbol}' and type {'unary' if is_unary else 'binary'}.\")\n\n        for operator in self.symbol_to_operators.get(operator_symbol, []):\n            if (is_unary and operator.n_ary == 1) or (not is_unary and operator.n_ary == 2):\n                self.logger.debug(f\"Found operator {operator.id} ({operator.symbol}) matching the criteria.\")\n                return operator.id, operator.is_temporary\n\n        self.logger.debug(f\"No matching operator found for symbol '{operator_symbol}' and type {'unary' if is_unary else 'binary'}.\")\n        return None, False\n\n    def get_operator_by_base(self, base: int) -&gt; OperatorInfo:\n        \"\"\"\n        Retrieves an operator based on the given base (number system).\n\n        Args:\n            base (int): The base (e.g., 2 for binary, 10 for decimal, etc.).\n\n        Returns:\n            OperatorInfo: The operator corresponding to the given base.\n\n        Raises:\n            ValueError: If no operators are available for the given base.\n        \"\"\"\n        self.logger.debug(f\"Fetching operator for base {base}.\")\n\n        if base not in self.base_operators:\n            self.logger.error(f\"Base type {base} does not exist.\")\n            raise ValueError(f\"Base type {base} does not exist.\")\n\n        self.logger.debug(f\"Found operator(s) for base {base}.\")\n        return self.base_operators[base]\n\n    def get_unary_and_binary_operators(\n        self,\n    ) -&gt; Tuple[List[OperatorInfo], List[OperatorInfo], List[OperatorInfo]]:\n        \"\"\"\n        Retrieves the lists of unary prefix operators, unary postfix operators, and binary operators.\n\n        This method categorizes the operators into three types:\n        - Unary prefix operators: Operators that appear before their operands.\n        - Unary postfix operators: Operators that appear after their operands.\n        - Binary operators: Operators that take two operands.\n\n        Returns:\n            Tuple[List[OperatorInfo], List[OperatorInfo], List[OperatorInfo]]:\n            A tuple containing three lists:\n            1. List of unary prefix operators\n            2. List of unary postfix operators\n            3. List of binary operators\n        \"\"\"\n        self.logger.debug(\"Fetching unary and binary operators.\")\n\n        # Get unary prefix operators\n        unary_prefix_ops = [\n            op\n            for op in self.operators.values()\n            if op.n_ary == 1 and op.unary_position == \"prefix\"\n        ]\n\n        self.logger.debug(f\"Found {len(unary_prefix_ops)} unary prefix operators.\")\n\n        # Get unary postfix operators\n        unary_postfix_ops = [\n            op\n            for op in self.operators.values()\n            if op.n_ary == 1 and op.unary_position == \"postfix\"\n        ]\n\n        self.logger.debug(f\"Found {len(unary_postfix_ops)} unary postfix operators.\")\n\n        # Get binary operators\n        binary_ops = [op for op in self.operators.values() if op.n_ary == 2]\n\n        self.logger.debug(f\"Found {len(binary_ops)} binary operators.\")\n\n        return unary_prefix_ops, unary_postfix_ops, binary_ops\n\n    def get_operators_by_priority(self) -&gt; List[OperatorInfo]:\n        \"\"\"\n        Sorts and returns operators based on their priority.\n\n        This method sorts all operators by their priority, where operators with lower priority come first.\n\n        Returns:\n            List[OperatorInfo]: A list of operators sorted by priority.\n        \"\"\"\n        self.logger.debug(\"Sorting operators by priority.\")\n\n        # Sort operators by priority in ascending order (lower priority first)\n        sorted_operators = sorted(\n            self.operators.values(), key=lambda op: op.priority, reverse=False\n        )\n\n        self.logger.debug(f\"Sorted {len(sorted_operators)} operators by priority.\")\n\n        return sorted_operators\n\n    def extract_op_dependencies(self, op_id: int):\n        \"\"\"\n        Extracts dependencies of a given operator by analyzing its compute function.\n\n        This method uses a regular expression to match operator IDs in the `op_compute_func` \n        field of the operator and identifies any dependencies (operators that the current \n        operator relies on).\n\n        Parameters:\n            op_id (int): The ID of the operator whose dependencies need to be extracted.\n\n        Updates:\n            - The `dependencies` attribute of the operator is updated to a list of dependent operator IDs.\n        \"\"\"\n        self.logger.debug(f\"Extracting dependencies for operator ID {op_id}.\")\n\n        # Get the operator by ID\n        operator = self.get_operator_by_id(op_id)\n\n        # Regular expression pattern to match operator dependencies (e.g., op_1, op_2, etc.)\n        op_pattern = r\"op_(\\d+)\"\n\n        # Use re.findall to extract all matching operator IDs from the function\n        op_numbers = re.findall(op_pattern, operator.op_compute_func)\n\n        # Convert matched strings to integers and remove duplicates\n        op_numbers = list(set(map(int, op_numbers)))\n\n        # If the operator itself is in the list of dependencies, remove it\n        if op_id in op_numbers:\n            op_numbers.remove(op_id)\n\n        # Update operator dependencies\n        operator.dependencies = op_numbers\n        self.logger.info(f\"Operator {op_id} dependencies updated to: {op_numbers}.\")\n\n    def calculate_order(self, operator_id: int):\n        \"\"\"\n        Calculates the order (n_order) of a specific operator based on its dependencies.\n\n        The order of an operator is determined by its dependencies' orders:\n        - For recursive definitions: max order of dependencies + 1.\n        - For non-recursive definitions: max order of dependencies.\n\n        If no dependencies exist, the order is set to 1.\n\n        Parameters:\n            operator_id (int): The ID of the operator whose order is to be calculated.\n        \"\"\"\n        self.logger.debug(f\"Calculating order for operator ID {operator_id}.\")\n\n        # Retrieve the operator's information using the provided operator ID\n        operator_info = self.operators.get(operator_id)\n\n        if not operator_info:\n            self.logger.error(f\"Operator with ID {operator_id} not found.\")\n            return\n\n        # If the operator has dependencies, calculate its order based on them\n        if operator_info.dependencies:\n            # Get the n_order values of all dependencies\n            dependency_orders = [\n                self.operators[dep_id].n_order for dep_id in operator_info.dependencies\n            ]\n            self.logger.debug(f\"Dependency orders for operator {operator_id}: {dependency_orders}.\")\n\n            if operator_info.definition_type == \"recursive_definition\":\n                # For recursive definitions, the order is the max order of dependencies + 1\n                operator_info.n_order = max(dependency_orders) + 1\n                self.logger.debug(f\"Operator {operator_id} is recursive; setting n_order to {operator_info.n_order}.\")\n            else:\n                # For non-recursive definitions, the order is the max order of dependencies\n                operator_info.n_order = max(dependency_orders)\n                self.logger.debug(f\"Operator {operator_id} is non-recursive; setting n_order to {operator_info.n_order}.\")\n        else:\n            # If the operator has no dependencies, set its order to 1\n            operator_info.n_order = 1\n            self.logger.debug(f\"Operator {operator_id} has no dependencies; setting n_order to 1.\")\n\n        # Log the final n_order value for the operator\n        self.logger.info(f\"Operator {operator_info.symbol} (ID: {operator_id}) has n_order: {operator_info.n_order}.\")\n\n    def update_operator_temporary_status(self, operator_id: int, new_status: bool) -&gt; bool:\n        \"\"\"\n        Updates the 'is_temporary' status of the specified operator.\n\n        This function looks for an operator by its ID and sets its 'is_temporary' status\n        to the provided new status.\n\n        Parameters:\n            operator_id (int): The ID of the operator to update.\n            new_status (bool): The new 'is_temporary' status to set for the operator.\n\n        Returns:\n            bool: Returns True if the update was successful, otherwise returns False if the operator was not found.\n        \"\"\"\n        self.logger.debug(f\"Attempting to update 'is_temporary' status for operator ID {operator_id} to {new_status}.\")\n\n        # Loop through all operators to find the one with the specified ID\n        for operators in self.symbol_to_operators.values():\n            for operator in operators:\n                if operator.id == operator_id:\n                    # Found the operator, updating its is_temporary status\n                    operator.is_temporary = new_status\n                    self.logger.info(f\"Operator {operator_id}: 'is_temporary' status successfully updated to {new_status}.\")\n                    return True  # Update successful\n\n        # If the operator ID was not found, log an error and return False\n        self.logger.error(f\"Operator with ID {operator_id} not found. Update failed.\")\n        return False  # Operator not found\n\n    def add_operator(self, operator_data: Dict[str, Any]):\n        \"\"\"\n        Dynamically adds a new operator to the system.\n\n        This method assigns a new operator ID (if not provided), ensures that \n        the operator's `n_order` is set to `None` for later processing, and \n        adds the operator to the internal storage.\n\n        Parameters:\n            operator_data (Dict[str, Any]): A dictionary containing the operator's details, \n                                             such as 'symbol', 'id', and other relevant properties.\n\n        Returns:\n            OperatorInfo: The newly created operator object.\n        \"\"\"\n        self.logger.debug(\"Attempting to add a new operator with data: %s\", operator_data)\n\n        # Automatically assign an ID if not provided\n        if \"id\" not in operator_data or operator_data[\"id\"] is None:\n            new_id = max(self.operators.keys(), default=0) + 1\n            operator_data[\"id\"] = new_id\n            self.logger.info(f\"Automatically assigned operator ID: {new_id}\")\n        else:\n            new_id = operator_data[\"id\"]\n            if new_id in self.operators:\n                self.logger.error(f\"Operator ID {new_id} already exists.\")\n                raise ValueError(f\"Operator ID {new_id} already exists.\")\n\n        # Ensure that n_order is set to None for later processing by calculate_order\n        operator_data[\"n_order\"] = None  # Let calculate_order handle this\n\n        # Create the new operator\n        new_operator = OperatorInfo(**operator_data)\n\n        # Add the operator to the operators dictionary\n        self.operators[new_operator.id] = new_operator\n\n        # Map the operator to its symbol in the symbol_to_operators dictionary\n        if new_operator.symbol not in self.symbol_to_operators:\n            self.symbol_to_operators[new_operator.symbol] = []\n        self.symbol_to_operators[new_operator.symbol].append(new_operator)\n        self.logger.debug(f\"Operator {new_operator.symbol} (ID: {new_operator.id}) added to symbol_to_operators.\")\n\n        # Add the operator to the base_operators dictionary based on its base type\n        if new_operator.is_base is not None:\n            if new_operator.is_base not in self.base_operators:\n                self.base_operators[new_operator.is_base] = []\n            self.base_operators[new_operator.is_base].append(new_operator)\n            self.logger.debug(f\"Operator {new_operator.symbol} (ID: {new_operator.id}) added to base_operators.\")\n\n        return new_operator\n\n    def remove_operator(self, op_id: int):\n        \"\"\"\n        Dynamically removes an operator from the system.\n\n        This method removes an operator by its ID, updating the internal storage \n        (both `self.operators` and `self.symbol_to_operators`) accordingly. \n\n        Parameters:\n            op_id (int): The ID of the operator to be removed.\n\n        Raises:\n            ValueError: If the operator ID does not exist in the system.\n        \"\"\"\n        self.logger.debug(\"Attempting to remove operator with ID: %d\", op_id)\n\n        if op_id not in self.operators:\n            self.logger.error(f\"Operator ID {op_id} does not exist.\")\n            raise ValueError(f\"Operator ID {op_id} does not exist.\")\n\n        # Retrieve and remove the operator from the operators dictionary\n        operator = self.operators.pop(op_id)\n        self.available_funcs.pop(f\"op_{operator.id}\", None)\n        self.available_funcs.pop(f\"op_count_{operator.id}\", None)\n        self.logger.info(f\"Removed operator {operator.symbol} (ID: {op_id}).\")\n\n        # Remove the operator from the symbol_to_operators mapping\n        if operator.symbol in self.symbol_to_operators:\n            self.symbol_to_operators[operator.symbol].remove(operator)\n            self.logger.debug(f\"Operator {operator.symbol} (ID: {op_id}) removed from symbol_to_operators.\")\n\n    def update_operator(self, op_id: int, updated_data: Dict[str, Any]):\n        \"\"\"\n        Dynamically updates an existing operator in the system.\n\n        This method replaces the operator with the given ID (`op_id`) using the data \n        in `updated_data`. It performs the necessary checks and ensures that all required fields \n        are provided before updating the operator in the internal storage.\n\n        Parameters:\n            op_id (int): The ID of the operator to be updated.\n            updated_data (dict): A dictionary containing the updated data for the operator.\n\n        Raises:\n            ValueError: If the operator ID does not exist or required fields are missing.\n        \"\"\"\n        self.logger.debug(\"Attempting to update operator with ID: %d\", op_id)\n\n        # Check if the operator exists\n        if op_id not in self.operators:\n            self.logger.error(f\"Operator ID {op_id} does not exist.\")\n            raise ValueError(f\"Operator ID {op_id} does not exist.\")\n\n        # Ensure the 'id' in updated_data matches the op_id\n        updated_data[\"id\"] = op_id\n\n        # Ensure 'compute_func' is provided in the updated data\n        if \"compute_func\" not in updated_data or not updated_data[\"compute_func\"]:\n            self.logger.error(\"compute_func must be provided.\")\n            raise ValueError(\"compute_func must be provided.\")\n\n        # Set 'n_order' to None, letting calculate_order handle it later\n        updated_data[\"n_order\"] = None\n\n        # Remove the old operator\n        old_operator = self.operators.pop(op_id)\n        self.symbol_to_operators[old_operator.symbol].remove(old_operator)\n        self.logger.info(f\"Removed old operator {old_operator.symbol} (ID: {op_id}).\")\n\n        # Add the updated operator\n        updated_operator = OperatorInfo(**updated_data)\n        self.operators[updated_operator.id] = updated_operator\n        self.symbol_to_operators[updated_operator.symbol].append(updated_operator)\n        self.logger.info(f\"Updated operator {updated_operator.symbol} (ID: {op_id}).\")\n\n        # Recalculate order after the update\n        self.calculate_order()\n        self.logger.debug(f\"Recalculated order for operator ID: {op_id}.\")\n\n    def delete_one_operator(self, op_id: int) -&gt; None:\n        \"\"\"\n        Delete an operator and recursively remove dependent operators. \n        Afterward, reassign IDs for the remaining operators.\n\n        Parameters:\n            op_id (int): The ID of the operator to be deleted.\n        \"\"\"\n        self.logger.debug(\"Attempting to delete operator with ID: %d\", op_id)\n\n        # Recursively delete the operator and its dependencies\n        self.delete_one_operator_by_dep(op_id)\n\n        # Reassign operator IDs after deletion\n        sorted_keys = sorted(self.operators.keys())\n        op_pattern = r\"def op_(\\d+)\"\n        op_count_pattern = r\"def op_count_(\\d+)\"\n\n        for i, old_key in enumerate(sorted_keys, start=1):\n            if old_key != i:\n                self.operators[i] = self.operators[old_key]\n                # Update the ID of the operator\n                self.operators[i].id = i\n                # Update the operator's function string\n                self.operators[i].op_compute_func = re.sub(\n                    op_pattern,\n                    lambda m: f\"op_{i}\",\n                    self.operators[i].op_compute_func,\n                    count=1,\n                )\n                self.operators[i].op_count_func = re.sub(\n                    op_count_pattern,\n                    lambda m: f\"op_count_{i}\",\n                    self.operators[i].op_count_func,\n                    count=1,\n                )\n                for operator in self.operators.values():\n                    if old_key in operator.dependencies:\n                        # Replace old_key with i in dependencies\n                        operator.dependencies = [i if dep == old_key else dep for dep in operator.dependencies]\n                        # Also, update the operator's compute functions to reflect the new op_id\n                        operator.op_compute_func = re.sub(\n                            rf\"op_{old_key}\",\n                            lambda m: f\"op_{i}\",\n                            operator.op_compute_func\n                        )\n                        operator.op_count_func = re.sub(\n                            rf\"op_count_{old_key}\",\n                            lambda m: f\"op_count_{i}\",\n                            operator.op_count_func\n                        )\n                del self.operators[old_key]\n\n        self.logger.info(\"Operator with ID %d and its dependencies removed. Operator IDs reassigned.\", op_id)\n\n    def delete_one_operator_by_dep(self, op_id: int) -&gt; None:\n        \"\"\"\n        Recursively delete an operator and its dependencies.\n\n        Parameters:\n            op_id (int): The ID of the operator to be deleted.\n\n        Raises:\n            ValueError: If the operator with the given ID does not exist.\n        \"\"\"\n        self.logger.debug(\"Attempting to recursively delete operator with ID: %d\", op_id)\n\n        # Check if the operator exists\n        if op_id not in self.operators:\n            self.logger.error(f\"Operator ID {op_id} does not exist.\")\n            raise ValueError(f\"Operator ID {op_id} does not exist.\")\n\n        # Set to keep track of operators that need to be deleted\n        to_delete_ids = set()\n\n        # Recursively find all operators that depend on the given operator\n        self._find_all_dependent_operator_ids(op_id, to_delete_ids)\n\n        # Remove the operators\n        for op_id_to_delete in to_delete_ids:\n            self.remove_operator(op_id_to_delete)\n\n        self.logger.debug(\"Completed recursive deletion for operator ID: %d and its dependencies.\", op_id)\n\n    def _find_all_dependent_operator_ids(self, op_id: int, to_delete_ids: set) -&gt; None:\n        \"\"\"\n        Helper function to recursively find all dependent operators that should be deleted.\n\n        Parameters:\n            op_id (int): The ID of the operator whose dependencies should be found.\n            to_delete_ids (set): A set that stores all operator IDs that should be deleted.\n        \"\"\"\n        # If this operator has already been marked for deletion, return early\n        if op_id in to_delete_ids:\n            return\n\n        # Mark this operator for deletion\n        to_delete_ids.add(op_id)\n\n        # Recursively find operators that depend on the current operator\n        for operator in self.operators.values():\n            if op_id in operator.dependencies:\n                self._find_all_dependent_operator_ids(operator.id, to_delete_ids)\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager.add_available_funcs","title":"<code>add_available_funcs(operator)</code>","text":"<p>Updates the available functions whenever a new operator is added.</p> Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>def add_available_funcs(self, operator: OperatorInfo):\n    \"\"\"\n    Updates the available functions whenever a new operator is added.\n    \"\"\"\n    self._update_available_funcs(operator)\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager.add_operator","title":"<code>add_operator(operator_data)</code>","text":"<p>Dynamically adds a new operator to the system.</p> <p>This method assigns a new operator ID (if not provided), ensures that  the operator's <code>n_order</code> is set to <code>None</code> for later processing, and  adds the operator to the internal storage.</p> <p>Parameters:</p> Name Type Description Default <code>operator_data</code> <code>Dict[str, Any]</code> <p>A dictionary containing the operator's details,                               such as 'symbol', 'id', and other relevant properties.</p> required <p>Returns:</p> Name Type Description <code>OperatorInfo</code> <p>The newly created operator object.</p> Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>def add_operator(self, operator_data: Dict[str, Any]):\n    \"\"\"\n    Dynamically adds a new operator to the system.\n\n    This method assigns a new operator ID (if not provided), ensures that \n    the operator's `n_order` is set to `None` for later processing, and \n    adds the operator to the internal storage.\n\n    Parameters:\n        operator_data (Dict[str, Any]): A dictionary containing the operator's details, \n                                         such as 'symbol', 'id', and other relevant properties.\n\n    Returns:\n        OperatorInfo: The newly created operator object.\n    \"\"\"\n    self.logger.debug(\"Attempting to add a new operator with data: %s\", operator_data)\n\n    # Automatically assign an ID if not provided\n    if \"id\" not in operator_data or operator_data[\"id\"] is None:\n        new_id = max(self.operators.keys(), default=0) + 1\n        operator_data[\"id\"] = new_id\n        self.logger.info(f\"Automatically assigned operator ID: {new_id}\")\n    else:\n        new_id = operator_data[\"id\"]\n        if new_id in self.operators:\n            self.logger.error(f\"Operator ID {new_id} already exists.\")\n            raise ValueError(f\"Operator ID {new_id} already exists.\")\n\n    # Ensure that n_order is set to None for later processing by calculate_order\n    operator_data[\"n_order\"] = None  # Let calculate_order handle this\n\n    # Create the new operator\n    new_operator = OperatorInfo(**operator_data)\n\n    # Add the operator to the operators dictionary\n    self.operators[new_operator.id] = new_operator\n\n    # Map the operator to its symbol in the symbol_to_operators dictionary\n    if new_operator.symbol not in self.symbol_to_operators:\n        self.symbol_to_operators[new_operator.symbol] = []\n    self.symbol_to_operators[new_operator.symbol].append(new_operator)\n    self.logger.debug(f\"Operator {new_operator.symbol} (ID: {new_operator.id}) added to symbol_to_operators.\")\n\n    # Add the operator to the base_operators dictionary based on its base type\n    if new_operator.is_base is not None:\n        if new_operator.is_base not in self.base_operators:\n            self.base_operators[new_operator.is_base] = []\n        self.base_operators[new_operator.is_base].append(new_operator)\n        self.logger.debug(f\"Operator {new_operator.symbol} (ID: {new_operator.id}) added to base_operators.\")\n\n    return new_operator\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager.calculate_order","title":"<code>calculate_order(operator_id)</code>","text":"<p>Calculates the order (n_order) of a specific operator based on its dependencies.</p> <p>The order of an operator is determined by its dependencies' orders: - For recursive definitions: max order of dependencies + 1. - For non-recursive definitions: max order of dependencies.</p> <p>If no dependencies exist, the order is set to 1.</p> <p>Parameters:</p> Name Type Description Default <code>operator_id</code> <code>int</code> <p>The ID of the operator whose order is to be calculated.</p> required Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>def calculate_order(self, operator_id: int):\n    \"\"\"\n    Calculates the order (n_order) of a specific operator based on its dependencies.\n\n    The order of an operator is determined by its dependencies' orders:\n    - For recursive definitions: max order of dependencies + 1.\n    - For non-recursive definitions: max order of dependencies.\n\n    If no dependencies exist, the order is set to 1.\n\n    Parameters:\n        operator_id (int): The ID of the operator whose order is to be calculated.\n    \"\"\"\n    self.logger.debug(f\"Calculating order for operator ID {operator_id}.\")\n\n    # Retrieve the operator's information using the provided operator ID\n    operator_info = self.operators.get(operator_id)\n\n    if not operator_info:\n        self.logger.error(f\"Operator with ID {operator_id} not found.\")\n        return\n\n    # If the operator has dependencies, calculate its order based on them\n    if operator_info.dependencies:\n        # Get the n_order values of all dependencies\n        dependency_orders = [\n            self.operators[dep_id].n_order for dep_id in operator_info.dependencies\n        ]\n        self.logger.debug(f\"Dependency orders for operator {operator_id}: {dependency_orders}.\")\n\n        if operator_info.definition_type == \"recursive_definition\":\n            # For recursive definitions, the order is the max order of dependencies + 1\n            operator_info.n_order = max(dependency_orders) + 1\n            self.logger.debug(f\"Operator {operator_id} is recursive; setting n_order to {operator_info.n_order}.\")\n        else:\n            # For non-recursive definitions, the order is the max order of dependencies\n            operator_info.n_order = max(dependency_orders)\n            self.logger.debug(f\"Operator {operator_id} is non-recursive; setting n_order to {operator_info.n_order}.\")\n    else:\n        # If the operator has no dependencies, set its order to 1\n        operator_info.n_order = 1\n        self.logger.debug(f\"Operator {operator_id} has no dependencies; setting n_order to 1.\")\n\n    # Log the final n_order value for the operator\n    self.logger.info(f\"Operator {operator_info.symbol} (ID: {operator_id}) has n_order: {operator_info.n_order}.\")\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager.clear_temp_file","title":"<code>clear_temp_file()</code>","text":"<p>Clears the temporary file by removing it if it exists.</p> <p>This method checks if the temporary file exists and removes it. If the file doesn't exist, a warning is logged. In case of any error during file removal, an error log is generated.</p> <p>Logs the status of the file clearance operation.</p> Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>def clear_temp_file(self):\n    \"\"\"\n    Clears the temporary file by removing it if it exists.\n\n    This method checks if the temporary file exists and removes it. If the file doesn't exist, a warning is logged.\n    In case of any error during file removal, an error log is generated.\n\n    Logs the status of the file clearance operation.\n    \"\"\"\n    try:\n        if os.path.exists(self.temp_file_path):\n            os.remove(self.temp_file_path)\n            self.logger.info(f\"Temporary file {self.temp_file_path} cleared.\")\n        else:\n            self.logger.warning(f\"Temporary file {self.temp_file_path} does not exist.\")\n    except Exception as e:\n        self.logger.error(f\"Error clearing temporary file: {e}\")\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager.delete_one_operator","title":"<code>delete_one_operator(op_id)</code>","text":"<p>Delete an operator and recursively remove dependent operators.  Afterward, reassign IDs for the remaining operators.</p> <p>Parameters:</p> Name Type Description Default <code>op_id</code> <code>int</code> <p>The ID of the operator to be deleted.</p> required Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>def delete_one_operator(self, op_id: int) -&gt; None:\n    \"\"\"\n    Delete an operator and recursively remove dependent operators. \n    Afterward, reassign IDs for the remaining operators.\n\n    Parameters:\n        op_id (int): The ID of the operator to be deleted.\n    \"\"\"\n    self.logger.debug(\"Attempting to delete operator with ID: %d\", op_id)\n\n    # Recursively delete the operator and its dependencies\n    self.delete_one_operator_by_dep(op_id)\n\n    # Reassign operator IDs after deletion\n    sorted_keys = sorted(self.operators.keys())\n    op_pattern = r\"def op_(\\d+)\"\n    op_count_pattern = r\"def op_count_(\\d+)\"\n\n    for i, old_key in enumerate(sorted_keys, start=1):\n        if old_key != i:\n            self.operators[i] = self.operators[old_key]\n            # Update the ID of the operator\n            self.operators[i].id = i\n            # Update the operator's function string\n            self.operators[i].op_compute_func = re.sub(\n                op_pattern,\n                lambda m: f\"op_{i}\",\n                self.operators[i].op_compute_func,\n                count=1,\n            )\n            self.operators[i].op_count_func = re.sub(\n                op_count_pattern,\n                lambda m: f\"op_count_{i}\",\n                self.operators[i].op_count_func,\n                count=1,\n            )\n            for operator in self.operators.values():\n                if old_key in operator.dependencies:\n                    # Replace old_key with i in dependencies\n                    operator.dependencies = [i if dep == old_key else dep for dep in operator.dependencies]\n                    # Also, update the operator's compute functions to reflect the new op_id\n                    operator.op_compute_func = re.sub(\n                        rf\"op_{old_key}\",\n                        lambda m: f\"op_{i}\",\n                        operator.op_compute_func\n                    )\n                    operator.op_count_func = re.sub(\n                        rf\"op_count_{old_key}\",\n                        lambda m: f\"op_count_{i}\",\n                        operator.op_count_func\n                    )\n            del self.operators[old_key]\n\n    self.logger.info(\"Operator with ID %d and its dependencies removed. Operator IDs reassigned.\", op_id)\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager.delete_one_operator_by_dep","title":"<code>delete_one_operator_by_dep(op_id)</code>","text":"<p>Recursively delete an operator and its dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>op_id</code> <code>int</code> <p>The ID of the operator to be deleted.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the operator with the given ID does not exist.</p> Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>def delete_one_operator_by_dep(self, op_id: int) -&gt; None:\n    \"\"\"\n    Recursively delete an operator and its dependencies.\n\n    Parameters:\n        op_id (int): The ID of the operator to be deleted.\n\n    Raises:\n        ValueError: If the operator with the given ID does not exist.\n    \"\"\"\n    self.logger.debug(\"Attempting to recursively delete operator with ID: %d\", op_id)\n\n    # Check if the operator exists\n    if op_id not in self.operators:\n        self.logger.error(f\"Operator ID {op_id} does not exist.\")\n        raise ValueError(f\"Operator ID {op_id} does not exist.\")\n\n    # Set to keep track of operators that need to be deleted\n    to_delete_ids = set()\n\n    # Recursively find all operators that depend on the given operator\n    self._find_all_dependent_operator_ids(op_id, to_delete_ids)\n\n    # Remove the operators\n    for op_id_to_delete in to_delete_ids:\n        self.remove_operator(op_id_to_delete)\n\n    self.logger.debug(\"Completed recursive deletion for operator ID: %d and its dependencies.\", op_id)\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager.extract_op_dependencies","title":"<code>extract_op_dependencies(op_id)</code>","text":"<p>Extracts dependencies of a given operator by analyzing its compute function.</p> <p>This method uses a regular expression to match operator IDs in the <code>op_compute_func</code>  field of the operator and identifies any dependencies (operators that the current  operator relies on).</p> <p>Parameters:</p> Name Type Description Default <code>op_id</code> <code>int</code> <p>The ID of the operator whose dependencies need to be extracted.</p> required Updates <ul> <li>The <code>dependencies</code> attribute of the operator is updated to a list of dependent operator IDs.</li> </ul> Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>def extract_op_dependencies(self, op_id: int):\n    \"\"\"\n    Extracts dependencies of a given operator by analyzing its compute function.\n\n    This method uses a regular expression to match operator IDs in the `op_compute_func` \n    field of the operator and identifies any dependencies (operators that the current \n    operator relies on).\n\n    Parameters:\n        op_id (int): The ID of the operator whose dependencies need to be extracted.\n\n    Updates:\n        - The `dependencies` attribute of the operator is updated to a list of dependent operator IDs.\n    \"\"\"\n    self.logger.debug(f\"Extracting dependencies for operator ID {op_id}.\")\n\n    # Get the operator by ID\n    operator = self.get_operator_by_id(op_id)\n\n    # Regular expression pattern to match operator dependencies (e.g., op_1, op_2, etc.)\n    op_pattern = r\"op_(\\d+)\"\n\n    # Use re.findall to extract all matching operator IDs from the function\n    op_numbers = re.findall(op_pattern, operator.op_compute_func)\n\n    # Convert matched strings to integers and remove duplicates\n    op_numbers = list(set(map(int, op_numbers)))\n\n    # If the operator itself is in the list of dependencies, remove it\n    if op_id in op_numbers:\n        op_numbers.remove(op_id)\n\n    # Update operator dependencies\n    operator.dependencies = op_numbers\n    self.logger.info(f\"Operator {op_id} dependencies updated to: {op_numbers}.\")\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager.get_available_funcs","title":"<code>get_available_funcs()</code>","text":"<p>Returns the available functions (compute and count functions).</p> Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>def get_available_funcs(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Returns the available functions (compute and count functions).\n    \"\"\"\n    return self.available_funcs\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager.get_next_operator_id","title":"<code>get_next_operator_id()</code>","text":"<p>Retrieves the next available operator ID.</p> <p>This method checks if there are existing operators, and if so, returns the next ID based on the  current maximum operator ID. If there are no operators, it starts from ID 1.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The next available operator ID.</p> Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>def get_next_operator_id(self) -&gt; int:\n    \"\"\"\n    Retrieves the next available operator ID.\n\n    This method checks if there are existing operators, and if so, returns the next ID based on the \n    current maximum operator ID. If there are no operators, it starts from ID 1.\n\n    Returns:\n        int: The next available operator ID.\n    \"\"\"\n    self.logger.debug(\"Getting the next available operator ID.\")\n\n    if not self.operators:\n        self.logger.debug(\"No operators found, starting from ID 1.\")\n        return 1\n\n    # Get the current maximum operator ID\n    max_id = max(self.operators.keys())\n\n    # Return the next ID\n    self.logger.debug(f\"Current maximum operator ID is {max_id}. Returning next ID: {max_id + 1}.\")\n    return max_id + 1\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager.get_operator_by_base","title":"<code>get_operator_by_base(base)</code>","text":"<p>Retrieves an operator based on the given base (number system).</p> <p>Parameters:</p> Name Type Description Default <code>base</code> <code>int</code> <p>The base (e.g., 2 for binary, 10 for decimal, etc.).</p> required <p>Returns:</p> Name Type Description <code>OperatorInfo</code> <code>OperatorInfo</code> <p>The operator corresponding to the given base.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no operators are available for the given base.</p> Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>def get_operator_by_base(self, base: int) -&gt; OperatorInfo:\n    \"\"\"\n    Retrieves an operator based on the given base (number system).\n\n    Args:\n        base (int): The base (e.g., 2 for binary, 10 for decimal, etc.).\n\n    Returns:\n        OperatorInfo: The operator corresponding to the given base.\n\n    Raises:\n        ValueError: If no operators are available for the given base.\n    \"\"\"\n    self.logger.debug(f\"Fetching operator for base {base}.\")\n\n    if base not in self.base_operators:\n        self.logger.error(f\"Base type {base} does not exist.\")\n        raise ValueError(f\"Base type {base} does not exist.\")\n\n    self.logger.debug(f\"Found operator(s) for base {base}.\")\n    return self.base_operators[base]\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager.get_operator_by_id","title":"<code>get_operator_by_id(op_id)</code>","text":"<p>Retrieves an operator by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>op_id</code> <code>int</code> <p>The operator ID.</p> required <p>Returns:</p> Name Type Description <code>OperatorInfo</code> <code>OperatorInfo</code> <p>The operator corresponding to the given ID.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the operator ID does not exist.</p> Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>def get_operator_by_id(self, op_id: int) -&gt; OperatorInfo:\n    \"\"\"\n    Retrieves an operator by its ID.\n\n    Args:\n        op_id (int): The operator ID.\n\n    Returns:\n        OperatorInfo: The operator corresponding to the given ID.\n\n    Raises:\n        ValueError: If the operator ID does not exist.\n    \"\"\"\n    self.logger.debug(f\"Fetching operator with ID {op_id}.\")\n\n    if op_id not in self.operators:\n        self.logger.error(f\"Operator ID {op_id} does not exist.\")\n        raise ValueError(f\"Operator ID {op_id} does not exist.\")\n\n    self.logger.debug(f\"Operator ID {op_id} found.\")\n    return self.operators[op_id]\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager.get_operator_function_id","title":"<code>get_operator_function_id(operator_symbol, is_unary)</code>","text":"<p>Retrieves the function ID and temporary status of an operator based on its symbol and type (unary or binary).</p> <p>Parameters:</p> Name Type Description Default <code>operator_symbol</code> <code>str</code> <p>The operator symbol.</p> required <code>is_unary</code> <code>bool</code> <p>A boolean indicating whether the operator is unary (True) or binary (False).</p> required <p>Returns:</p> Type Description <code>Optional[tuple[int, bool]]</code> <p>Optional[tuple[int, bool]]: A tuple containing the operator's function ID and its temporary status.                         If no matching operator is found, returns (None, False).</p> Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>def get_operator_function_id(\n    self, operator_symbol: str, is_unary: bool\n) -&gt; Optional[tuple[int, bool]]:\n    \"\"\"\n    Retrieves the function ID and temporary status of an operator based on its symbol and type (unary or binary).\n\n    Args:\n        operator_symbol (str): The operator symbol.\n        is_unary (bool): A boolean indicating whether the operator is unary (True) or binary (False).\n\n    Returns:\n        Optional[tuple[int, bool]]: A tuple containing the operator's function ID and its temporary status.\n                                    If no matching operator is found, returns (None, False).\n    \"\"\"\n    self.logger.debug(f\"Fetching function ID for operator symbol '{operator_symbol}' and type {'unary' if is_unary else 'binary'}.\")\n\n    for operator in self.symbol_to_operators.get(operator_symbol, []):\n        if (is_unary and operator.n_ary == 1) or (not is_unary and operator.n_ary == 2):\n            self.logger.debug(f\"Found operator {operator.id} ({operator.symbol}) matching the criteria.\")\n            return operator.id, operator.is_temporary\n\n    self.logger.debug(f\"No matching operator found for symbol '{operator_symbol}' and type {'unary' if is_unary else 'binary'}.\")\n    return None, False\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager.get_operator_symbols","title":"<code>get_operator_symbols()</code>","text":"<p>Retrieves a list of all operator symbols.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: A list of operator symbols.</p> Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>def get_operator_symbols(self) -&gt; List[str]:\n    \"\"\"\n    Retrieves a list of all operator symbols.\n\n    Returns:\n        List[str]: A list of operator symbols.\n    \"\"\"\n    self.logger.debug(\"Fetching all operator symbols.\")\n\n    symbols = list(self.symbol_to_operators.keys())\n\n    self.logger.debug(f\"Found {len(symbols)} operator symbols.\")\n    return symbols\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager.get_operators_by_priority","title":"<code>get_operators_by_priority()</code>","text":"<p>Sorts and returns operators based on their priority.</p> <p>This method sorts all operators by their priority, where operators with lower priority come first.</p> <p>Returns:</p> Type Description <code>List[OperatorInfo]</code> <p>List[OperatorInfo]: A list of operators sorted by priority.</p> Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>def get_operators_by_priority(self) -&gt; List[OperatorInfo]:\n    \"\"\"\n    Sorts and returns operators based on their priority.\n\n    This method sorts all operators by their priority, where operators with lower priority come first.\n\n    Returns:\n        List[OperatorInfo]: A list of operators sorted by priority.\n    \"\"\"\n    self.logger.debug(\"Sorting operators by priority.\")\n\n    # Sort operators by priority in ascending order (lower priority first)\n    sorted_operators = sorted(\n        self.operators.values(), key=lambda op: op.priority, reverse=False\n    )\n\n    self.logger.debug(f\"Sorted {len(sorted_operators)} operators by priority.\")\n\n    return sorted_operators\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager.get_operators_by_symbol","title":"<code>get_operators_by_symbol(symbol)</code>","text":"<p>Retrieves all operators corresponding to a given symbol.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The operator symbol.</p> required <p>Returns:</p> Type Description <code>List[OperatorInfo]</code> <p>List[OperatorInfo]: A list of operators corresponding to the symbol.</p> Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>def get_operators_by_symbol(self, symbol: str) -&gt; List[OperatorInfo]:\n    \"\"\"\n    Retrieves all operators corresponding to a given symbol.\n\n    Args:\n        symbol (str): The operator symbol.\n\n    Returns:\n        List[OperatorInfo]: A list of operators corresponding to the symbol.\n    \"\"\"\n    self.logger.debug(f\"Fetching operators with symbol '{symbol}'.\")\n\n    operators = self.symbol_to_operators.get(symbol, [])\n\n    self.logger.debug(f\"Found {len(operators)} operators for symbol '{symbol}'.\")\n    return operators\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager.get_unary_and_binary_operators","title":"<code>get_unary_and_binary_operators()</code>","text":"<p>Retrieves the lists of unary prefix operators, unary postfix operators, and binary operators.</p> <p>This method categorizes the operators into three types: - Unary prefix operators: Operators that appear before their operands. - Unary postfix operators: Operators that appear after their operands. - Binary operators: Operators that take two operands.</p> <p>Returns:</p> Type Description <code>List[OperatorInfo]</code> <p>Tuple[List[OperatorInfo], List[OperatorInfo], List[OperatorInfo]]:</p> <code>List[OperatorInfo]</code> <p>A tuple containing three lists:</p> <code>List[OperatorInfo]</code> <ol> <li>List of unary prefix operators</li> </ol> <code>Tuple[List[OperatorInfo], List[OperatorInfo], List[OperatorInfo]]</code> <ol> <li>List of unary postfix operators</li> </ol> <code>Tuple[List[OperatorInfo], List[OperatorInfo], List[OperatorInfo]]</code> <ol> <li>List of binary operators</li> </ol> Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>def get_unary_and_binary_operators(\n    self,\n) -&gt; Tuple[List[OperatorInfo], List[OperatorInfo], List[OperatorInfo]]:\n    \"\"\"\n    Retrieves the lists of unary prefix operators, unary postfix operators, and binary operators.\n\n    This method categorizes the operators into three types:\n    - Unary prefix operators: Operators that appear before their operands.\n    - Unary postfix operators: Operators that appear after their operands.\n    - Binary operators: Operators that take two operands.\n\n    Returns:\n        Tuple[List[OperatorInfo], List[OperatorInfo], List[OperatorInfo]]:\n        A tuple containing three lists:\n        1. List of unary prefix operators\n        2. List of unary postfix operators\n        3. List of binary operators\n    \"\"\"\n    self.logger.debug(\"Fetching unary and binary operators.\")\n\n    # Get unary prefix operators\n    unary_prefix_ops = [\n        op\n        for op in self.operators.values()\n        if op.n_ary == 1 and op.unary_position == \"prefix\"\n    ]\n\n    self.logger.debug(f\"Found {len(unary_prefix_ops)} unary prefix operators.\")\n\n    # Get unary postfix operators\n    unary_postfix_ops = [\n        op\n        for op in self.operators.values()\n        if op.n_ary == 1 and op.unary_position == \"postfix\"\n    ]\n\n    self.logger.debug(f\"Found {len(unary_postfix_ops)} unary postfix operators.\")\n\n    # Get binary operators\n    binary_ops = [op for op in self.operators.values() if op.n_ary == 2]\n\n    self.logger.debug(f\"Found {len(binary_ops)} binary operators.\")\n\n    return unary_prefix_ops, unary_postfix_ops, binary_ops\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager.load_operators","title":"<code>load_operators()</code>","text":"<p>Loads operator definitions from a JSONL file.</p> <p>This method reads the configuration file line by line, parses each line into an <code>OperatorInfo</code> object, and stores the operators in various structures: - <code>self.operators</code>: A dictionary with operator ID as the key and <code>OperatorInfo</code> as the value. - <code>self.symbol_to_operators</code>: A dictionary with operator symbol as the key and a list of <code>OperatorInfo</code> as the value. - <code>self.base_operators</code>: A dictionary to store base operators based on their base status.</p> <p>Additionally, it updates the available functions for computation and counting based on the loaded operators.</p> <p>Logs relevant information about the loading process for monitoring and debugging purposes.</p> Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>def load_operators(self):\n    \"\"\"\n    Loads operator definitions from a JSONL file.\n\n    This method reads the configuration file line by line, parses each line into an\n    `OperatorInfo` object, and stores the operators in various structures:\n    - `self.operators`: A dictionary with operator ID as the key and `OperatorInfo` as the value.\n    - `self.symbol_to_operators`: A dictionary with operator symbol as the key and a list of `OperatorInfo` as the value.\n    - `self.base_operators`: A dictionary to store base operators based on their base status.\n\n    Additionally, it updates the available functions for computation and counting based on the loaded operators.\n\n    Logs relevant information about the loading process for monitoring and debugging purposes.\n    \"\"\"\n    self.logger.info(f\"Loading operators from configuration file: {self.config_file}\")\n\n    with open(self.config_file, \"r\", encoding=\"utf-8\") as f:\n        line_count = 0\n        for line in f:\n            line_count += 1\n            if not line.strip():\n                self.logger.debug(f\"Skipping empty line {line_count}.\")\n                continue  # Skip empty lines\n            try:\n                operator = OperatorInfo.from_json(line)\n                self.operators[operator.id] = operator\n                self.symbol_to_operators[operator.symbol].append(operator)\n\n                # Update available functions for the operator\n                if operator.is_base:\n                    self.base_operators[operator.is_base].append(operator)\n\n                self._update_available_funcs(operator)\n                self.logger.debug(f\"Loaded operator {operator.id} ({operator.symbol}) from line {line_count}.\")\n\n            except Exception as e:\n                self.logger.warning(f\"Failed to parse operator from line {line_count}: {e}\")\n\n    self.logger.info(f\"Successfully loaded {len(self.operators)} operators from the configuration file.\")\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager.remove_operator","title":"<code>remove_operator(op_id)</code>","text":"<p>Dynamically removes an operator from the system.</p> <p>This method removes an operator by its ID, updating the internal storage  (both <code>self.operators</code> and <code>self.symbol_to_operators</code>) accordingly. </p> <p>Parameters:</p> Name Type Description Default <code>op_id</code> <code>int</code> <p>The ID of the operator to be removed.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the operator ID does not exist in the system.</p> Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>def remove_operator(self, op_id: int):\n    \"\"\"\n    Dynamically removes an operator from the system.\n\n    This method removes an operator by its ID, updating the internal storage \n    (both `self.operators` and `self.symbol_to_operators`) accordingly. \n\n    Parameters:\n        op_id (int): The ID of the operator to be removed.\n\n    Raises:\n        ValueError: If the operator ID does not exist in the system.\n    \"\"\"\n    self.logger.debug(\"Attempting to remove operator with ID: %d\", op_id)\n\n    if op_id not in self.operators:\n        self.logger.error(f\"Operator ID {op_id} does not exist.\")\n        raise ValueError(f\"Operator ID {op_id} does not exist.\")\n\n    # Retrieve and remove the operator from the operators dictionary\n    operator = self.operators.pop(op_id)\n    self.available_funcs.pop(f\"op_{operator.id}\", None)\n    self.available_funcs.pop(f\"op_count_{operator.id}\", None)\n    self.logger.info(f\"Removed operator {operator.symbol} (ID: {op_id}).\")\n\n    # Remove the operator from the symbol_to_operators mapping\n    if operator.symbol in self.symbol_to_operators:\n        self.symbol_to_operators[operator.symbol].remove(operator)\n        self.logger.debug(f\"Operator {operator.symbol} (ID: {op_id}) removed from symbol_to_operators.\")\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager.rename_temp_to_jsonl","title":"<code>rename_temp_to_jsonl(file_path)</code>","text":"<p>Renames the temporary file to the specified file_path.</p> Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>def rename_temp_to_jsonl(self, file_path: str):\n    \"\"\"Renames the temporary file to the specified file_path.\"\"\"\n    # Ensure the temporary file exists at self.temp_file_path\n    if os.path.exists(self.temp_file_path):\n        # If the destination file doesn't exist, create it\n        if not os.path.exists(file_path):\n            # Create an empty file at the destination path\n            open(file_path, 'w', encoding=\"utf-8\").close()\n\n        try:\n            # Now, rename the temporary file to the specified file_path\n            os.rename(self.temp_file_path, file_path)\n            self.logger.info(f\"Renamed temporary file {self.temp_file_path} to {file_path}\")\n        except OSError as e:\n            self.logger.error(f\"Error renaming file {self.temp_file_path} to {file_path}: {e}\")\n    else:\n        self.logger.warning(f\"Temporary file not found: {self.temp_file_path}\")\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager.save_operator_to_temp","title":"<code>save_operator_to_temp(operator)</code>","text":"<p>Saves a single operator to a temporary file.</p> <p>This method serializes the given operator and appends it to a temporary file defined in <code>self.temp_file_path</code>.</p> <p>Parameters:</p> Name Type Description Default <code>operator</code> <code>OperatorInfo</code> <p>The operator to be saved.</p> required <p>Logs the process of saving the operator to the temporary file.</p> Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>def save_operator_to_temp(self, operator):\n    \"\"\"\n    Saves a single operator to a temporary file.\n\n    This method serializes the given operator and appends it to a temporary file defined in `self.temp_file_path`.\n\n    Args:\n        operator (OperatorInfo): The operator to be saved.\n\n    Logs the process of saving the operator to the temporary file.\n    \"\"\"\n    self.logger.info(f\"Saving operator {operator.id} ({operator.symbol}) to temporary file.\")\n\n    with open(self.temp_file_path, 'a', encoding=\"utf-8\") as temp_file:\n        json_line = operator.to_json()\n        temp_file.write(json_line + \"\\n\")\n        self.logger.debug(f\"Operator {operator.id} ({operator.symbol}) saved to temporary file.\")\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager.save_operators_to_jsonl","title":"<code>save_operators_to_jsonl(file_path)</code>","text":"<p>Saves all operators to a JSONL file.</p> <p>This method serializes each operator in <code>self.operators</code> and writes it to the specified file path in JSONL format.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the file where the operators should be saved.</p> required <p>Logs the process of saving operators to the file.</p> Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>def save_operators_to_jsonl(self, file_path: str):\n    \"\"\"\n    Saves all operators to a JSONL file.\n\n    This method serializes each operator in `self.operators` and writes it to the specified file path in JSONL format.\n\n    Args:\n        file_path (str): The path to the file where the operators should be saved.\n\n    Logs the process of saving operators to the file.\n    \"\"\"\n    self.logger.info(f\"Saving operators to {file_path}.\")\n\n    with open(file_path, \"w\", encoding=\"utf-8\") as file:\n        for operator in self.operators.values():\n            json_line = operator.to_json()\n            file.write(json_line + \"\\n\")\n            self.logger.debug(f\"Saved operator {operator.id} ({operator.symbol}) to {file_path}.\")\n\n    self.logger.info(f\"Successfully saved all operators to {file_path}.\")\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager.update_operator","title":"<code>update_operator(op_id, updated_data)</code>","text":"<p>Dynamically updates an existing operator in the system.</p> <p>This method replaces the operator with the given ID (<code>op_id</code>) using the data  in <code>updated_data</code>. It performs the necessary checks and ensures that all required fields  are provided before updating the operator in the internal storage.</p> <p>Parameters:</p> Name Type Description Default <code>op_id</code> <code>int</code> <p>The ID of the operator to be updated.</p> required <code>updated_data</code> <code>dict</code> <p>A dictionary containing the updated data for the operator.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the operator ID does not exist or required fields are missing.</p> Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>def update_operator(self, op_id: int, updated_data: Dict[str, Any]):\n    \"\"\"\n    Dynamically updates an existing operator in the system.\n\n    This method replaces the operator with the given ID (`op_id`) using the data \n    in `updated_data`. It performs the necessary checks and ensures that all required fields \n    are provided before updating the operator in the internal storage.\n\n    Parameters:\n        op_id (int): The ID of the operator to be updated.\n        updated_data (dict): A dictionary containing the updated data for the operator.\n\n    Raises:\n        ValueError: If the operator ID does not exist or required fields are missing.\n    \"\"\"\n    self.logger.debug(\"Attempting to update operator with ID: %d\", op_id)\n\n    # Check if the operator exists\n    if op_id not in self.operators:\n        self.logger.error(f\"Operator ID {op_id} does not exist.\")\n        raise ValueError(f\"Operator ID {op_id} does not exist.\")\n\n    # Ensure the 'id' in updated_data matches the op_id\n    updated_data[\"id\"] = op_id\n\n    # Ensure 'compute_func' is provided in the updated data\n    if \"compute_func\" not in updated_data or not updated_data[\"compute_func\"]:\n        self.logger.error(\"compute_func must be provided.\")\n        raise ValueError(\"compute_func must be provided.\")\n\n    # Set 'n_order' to None, letting calculate_order handle it later\n    updated_data[\"n_order\"] = None\n\n    # Remove the old operator\n    old_operator = self.operators.pop(op_id)\n    self.symbol_to_operators[old_operator.symbol].remove(old_operator)\n    self.logger.info(f\"Removed old operator {old_operator.symbol} (ID: {op_id}).\")\n\n    # Add the updated operator\n    updated_operator = OperatorInfo(**updated_data)\n    self.operators[updated_operator.id] = updated_operator\n    self.symbol_to_operators[updated_operator.symbol].append(updated_operator)\n    self.logger.info(f\"Updated operator {updated_operator.symbol} (ID: {op_id}).\")\n\n    # Recalculate order after the update\n    self.calculate_order()\n    self.logger.debug(f\"Recalculated order for operator ID: {op_id}.\")\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager.update_operator_temporary_status","title":"<code>update_operator_temporary_status(operator_id, new_status)</code>","text":"<p>Updates the 'is_temporary' status of the specified operator.</p> <p>This function looks for an operator by its ID and sets its 'is_temporary' status to the provided new status.</p> <p>Parameters:</p> Name Type Description Default <code>operator_id</code> <code>int</code> <p>The ID of the operator to update.</p> required <code>new_status</code> <code>bool</code> <p>The new 'is_temporary' status to set for the operator.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Returns True if the update was successful, otherwise returns False if the operator was not found.</p> Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>def update_operator_temporary_status(self, operator_id: int, new_status: bool) -&gt; bool:\n    \"\"\"\n    Updates the 'is_temporary' status of the specified operator.\n\n    This function looks for an operator by its ID and sets its 'is_temporary' status\n    to the provided new status.\n\n    Parameters:\n        operator_id (int): The ID of the operator to update.\n        new_status (bool): The new 'is_temporary' status to set for the operator.\n\n    Returns:\n        bool: Returns True if the update was successful, otherwise returns False if the operator was not found.\n    \"\"\"\n    self.logger.debug(f\"Attempting to update 'is_temporary' status for operator ID {operator_id} to {new_status}.\")\n\n    # Loop through all operators to find the one with the specified ID\n    for operators in self.symbol_to_operators.values():\n        for operator in operators:\n            if operator.id == operator_id:\n                # Found the operator, updating its is_temporary status\n                operator.is_temporary = new_status\n                self.logger.info(f\"Operator {operator_id}: 'is_temporary' status successfully updated to {new_status}.\")\n                return True  # Update successful\n\n    # If the operator ID was not found, log an error and return False\n    self.logger.error(f\"Operator with ID {operator_id} not found. Update failed.\")\n    return False  # Operator not found\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_priority_manager/","title":"Operator priority manager","text":""},{"location":"Core%20API/operatorplus/operator_priority_manager/#opulse.operatorplus.operator_priority_manager.OperatorPriorityManager","title":"<code>OperatorPriorityManager</code>","text":"Source code in <code>opulse/operatorplus/operator_priority_manager.py</code> <pre><code>class OperatorPriorityManager:\n    def __init__(\n        self,\n        logger: LogConfig,\n        operator_manager: \"OperatorManager\" = None,\n    ):\n        \"\"\"\n        Initializes the OperatorPriorityManager with a logger and an optional OperatorManager.\n\n        Parameters:\n            logger (logging.Logger): Logger instance for logging messages.\n            operator_manager (OperatorManager, optional): An instance of OperatorManager for managing operators.\n        \"\"\"\n        self.logger = logger.get_logger()\n        self.operator_manager = operator_manager\n\n    def assign_priorities(self):\n        \"\"\"\n        Assigns priorities and associativities to operators.\n\n        Rules:\n        1. Postfix operators have a higher priority than prefix operators.\n        2. Operators with the same priority have the same associativity.\n\n        This method assigns priorities and associativities to all operators managed by the OperatorManager.\n        The assignment follows the rules defined above.\n        \"\"\"\n        self.logger.info(\"Starting to assign operator priorities and associativities...\")\n\n        # A dictionary to hold the associativity direction for each priority level\n        self.priority_associativity = {}\n        self.max_priority = 0\n\n        # Reset the current priority and associativity of each operator\n        for op in self.operator_manager.operators.values():\n            op.priority = 0\n            op.associativity_direction = None\n\n        # Iterate over all operators to assign priority and associativity\n        for op in self.operator_manager.operators.values():\n            if op.n_ary == 1:\n                # Assign priority for unary operators (either prefix or postfix)\n                if op.unary_position == \"prefix\":\n                    # Prefix operators typically have right associativity\n                    available_priority = [\n                        p for p, a in self.priority_associativity.items() if a == \"right\"\n                    ]\n                    available_priority.append(self.max_priority + 1)\n                    op.priority = random.choice(available_priority)\n                    op.associativity_direction = \"right\"\n                    self.logger.debug(f\"Assigned 'prefix' unary operator '{op.symbol}' a priority of {op.priority} and right associativity.\")\n                elif op.unary_position == \"postfix\":\n                    # Postfix operators typically have left associativity\n                    available_priority = [\n                        p for p, a in self.priority_associativity.items() if a == \"left\"\n                    ]\n                    available_priority.append(self.max_priority + 1)\n                    op.priority = random.choice(available_priority)\n                    op.associativity_direction = \"left\"\n                    self.logger.debug(f\"Assigned 'postfix' unary operator '{op.symbol}' a priority of {op.priority} and left associativity.\")\n\n                # If a new priority was assigned, update max_priority and associativity\n                if op.priority == self.max_priority + 1:\n                    self.max_priority += 1\n                    self.priority_associativity[self.max_priority] = op.associativity_direction\n\n            elif op.n_ary == 2:\n                # Assign priority for binary operators\n                available_priority = [p for p, a in self.priority_associativity.items()]\n                available_priority.append(self.max_priority + 1)\n                op.priority = random.choice(available_priority)\n\n                # If a new priority is assigned, set associativity\n                if op.priority == self.max_priority + 1:\n                    op.associativity_direction = random.choice([\"left\", \"right\"])\n                    self.max_priority += 1\n                    self.priority_associativity[self.max_priority] = op.associativity_direction\n                    self.logger.debug(f\"Assigned binary operator '{op.symbol}' a new priority of {op.priority} and random associativity.\")\n                else:\n                    op.associativity_direction = self.priority_associativity[op.priority]\n                    self.logger.debug(f\"Assigned binary operator '{op.symbol}' the existing priority of {op.priority} and associativity {op.associativity_direction}.\")\n\n            # Log the assigned priority and associativity for each operator\n            self.logger.info(\n                f\"Assigned operator '{op.symbol}' ({op.n_ary}-ary, ID: {op.id}) with priority: {op.priority}, associativity: {op.associativity_direction}\"\n            )\n\n        self.logger.info(\"Operator priority and associativity assignment completed.\")\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_priority_manager/#opulse.operatorplus.operator_priority_manager.OperatorPriorityManager.__init__","title":"<code>__init__(logger, operator_manager=None)</code>","text":"<p>Initializes the OperatorPriorityManager with a logger and an optional OperatorManager.</p> <p>Parameters:</p> Name Type Description Default <code>logger</code> <code>Logger</code> <p>Logger instance for logging messages.</p> required <code>operator_manager</code> <code>OperatorManager</code> <p>An instance of OperatorManager for managing operators.</p> <code>None</code> Source code in <code>opulse/operatorplus/operator_priority_manager.py</code> <pre><code>def __init__(\n    self,\n    logger: LogConfig,\n    operator_manager: \"OperatorManager\" = None,\n):\n    \"\"\"\n    Initializes the OperatorPriorityManager with a logger and an optional OperatorManager.\n\n    Parameters:\n        logger (logging.Logger): Logger instance for logging messages.\n        operator_manager (OperatorManager, optional): An instance of OperatorManager for managing operators.\n    \"\"\"\n    self.logger = logger.get_logger()\n    self.operator_manager = operator_manager\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_priority_manager/#opulse.operatorplus.operator_priority_manager.OperatorPriorityManager.assign_priorities","title":"<code>assign_priorities()</code>","text":"<p>Assigns priorities and associativities to operators.</p> <p>Rules: 1. Postfix operators have a higher priority than prefix operators. 2. Operators with the same priority have the same associativity.</p> <p>This method assigns priorities and associativities to all operators managed by the OperatorManager. The assignment follows the rules defined above.</p> Source code in <code>opulse/operatorplus/operator_priority_manager.py</code> <pre><code>def assign_priorities(self):\n    \"\"\"\n    Assigns priorities and associativities to operators.\n\n    Rules:\n    1. Postfix operators have a higher priority than prefix operators.\n    2. Operators with the same priority have the same associativity.\n\n    This method assigns priorities and associativities to all operators managed by the OperatorManager.\n    The assignment follows the rules defined above.\n    \"\"\"\n    self.logger.info(\"Starting to assign operator priorities and associativities...\")\n\n    # A dictionary to hold the associativity direction for each priority level\n    self.priority_associativity = {}\n    self.max_priority = 0\n\n    # Reset the current priority and associativity of each operator\n    for op in self.operator_manager.operators.values():\n        op.priority = 0\n        op.associativity_direction = None\n\n    # Iterate over all operators to assign priority and associativity\n    for op in self.operator_manager.operators.values():\n        if op.n_ary == 1:\n            # Assign priority for unary operators (either prefix or postfix)\n            if op.unary_position == \"prefix\":\n                # Prefix operators typically have right associativity\n                available_priority = [\n                    p for p, a in self.priority_associativity.items() if a == \"right\"\n                ]\n                available_priority.append(self.max_priority + 1)\n                op.priority = random.choice(available_priority)\n                op.associativity_direction = \"right\"\n                self.logger.debug(f\"Assigned 'prefix' unary operator '{op.symbol}' a priority of {op.priority} and right associativity.\")\n            elif op.unary_position == \"postfix\":\n                # Postfix operators typically have left associativity\n                available_priority = [\n                    p for p, a in self.priority_associativity.items() if a == \"left\"\n                ]\n                available_priority.append(self.max_priority + 1)\n                op.priority = random.choice(available_priority)\n                op.associativity_direction = \"left\"\n                self.logger.debug(f\"Assigned 'postfix' unary operator '{op.symbol}' a priority of {op.priority} and left associativity.\")\n\n            # If a new priority was assigned, update max_priority and associativity\n            if op.priority == self.max_priority + 1:\n                self.max_priority += 1\n                self.priority_associativity[self.max_priority] = op.associativity_direction\n\n        elif op.n_ary == 2:\n            # Assign priority for binary operators\n            available_priority = [p for p, a in self.priority_associativity.items()]\n            available_priority.append(self.max_priority + 1)\n            op.priority = random.choice(available_priority)\n\n            # If a new priority is assigned, set associativity\n            if op.priority == self.max_priority + 1:\n                op.associativity_direction = random.choice([\"left\", \"right\"])\n                self.max_priority += 1\n                self.priority_associativity[self.max_priority] = op.associativity_direction\n                self.logger.debug(f\"Assigned binary operator '{op.symbol}' a new priority of {op.priority} and random associativity.\")\n            else:\n                op.associativity_direction = self.priority_associativity[op.priority]\n                self.logger.debug(f\"Assigned binary operator '{op.symbol}' the existing priority of {op.priority} and associativity {op.associativity_direction}.\")\n\n        # Log the assigned priority and associativity for each operator\n        self.logger.info(\n            f\"Assigned operator '{op.symbol}' ({op.n_ary}-ary, ID: {op.id}) with priority: {op.priority}, associativity: {op.associativity_direction}\"\n        )\n\n    self.logger.info(\"Operator priority and associativity assignment completed.\")\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_transformer/","title":"Operator transformer","text":""},{"location":"Core%20API/operatorplus/operator_transformer/#opulse.operatorplus.operator_transformer.OperatorTransformer","title":"<code>OperatorTransformer</code>","text":"<p>               Bases: <code>Transformer</code></p> Source code in <code>opulse/operatorplus/operator_transformer.py</code> <pre><code>class OperatorTransformer(Transformer):\n    def __init__(\n        self,\n        param_config: ParamConfig,\n        logger: LogConfig,\n        operator_manager: \"OperatorManager\" = None,\n    ):\n        \"\"\"\n        Initializes the OperatorTransformer instance with given configurations.\n\n        Args:\n           param_config (ParamConfig): Configuration for parameters.\n           logger (LogConfig): Logger configuration for logging debug and info messages.\n           operator_manager (OperatorManager, optional): Operator manager for handling operators.\n        \"\"\"\n        self.param_config = param_config\n        self.logger = logger.get_logger()\n        self.operator_manager = operator_manager\n\n    @v_args(inline=True)\n    def no_solution(self, token):\n        \"\"\"\n        Handles the NO_SOLUTION rule, returns the string 'NaN'.\n\n        Parameters:\n            token (Token): The token representing NO_SOLUTION.\n\n        Returns:\n            (str): The string '\"NaN\"'.\n        \"\"\"\n        self.logger.debug(f\"Processing NO_SOLUTION: {token}\")\n        result = '\"NaN\"'  # Ensure to return 'NaN' as a quoted string.\n        self.logger.debug(f\"Returning NO_SOLUTION result: {result}\")\n        return result\n\n    @v_args(inline=True)\n    def int_conversion(self, token):\n        \"\"\"\n        Converts an INT token to a string.\n\n        Parameters:\n            token (Token): The INT token to convert.\n\n        Returns:\n            (str): The string representation of the token's value.\n        \"\"\"\n        self.logger.debug(f\"Converting INT token: {token}\")\n        result = str(token.value)\n        self.logger.debug(f\"Returning INT conversion result: {result}\")\n        return result\n\n    @v_args(inline=True)\n    def variable_conversion(self, token):\n        \"\"\"\n        Converts a VARIABLE token to its string value.\n\n        Parameters:\n            token (Token): The VARIABLE token to convert.\n\n        Returns:\n            (str): The string representation of the token's value.\n        \"\"\"\n        self.logger.debug(f\"Converting VARIABLE token: {token}\")\n        result = token.value  # Assumes it's a simple variable name like 'a' or 'b'.\n        self.logger.debug(f\"Returning VARIABLE conversion result: {result}\")\n        return result\n\n    @v_args(inline=True)\n    def binary_operation(self, left, operator, right):\n        \"\"\"\n        Converts a binary operation into a function call.\n\n        Parameters:\n            left (str): The left operand.\n            operator (str): The operator symbol.\n            right (str): The right operand.\n\n        Returns:\n            (str): The function call string using the operator's function ID.\n        \"\"\"\n        self.logger.debug(\n            f\"Binary operation: left={left}, operator={operator}, right={right}\"\n        )\n        func_id, is_temporary = self.operator_manager.get_operator_function_id(\n            operator, is_unary=False\n        )\n        self.logger.debug(f\"Function ID: {func_id}, Is temporary: {is_temporary}\")\n        if func_id and not is_temporary:\n            result = f\"op_{func_id}({left},{right})\"\n        else:\n            raise ValueError(\n                f\"Operator '{operator}' is not supported or lacks a function ID.\"\n            )\n        self.logger.debug(f\"Returning binary operation result: {result}\")\n        return result\n\n    @v_args(inline=True)\n    def unary_operation_prefix(self, operator, operand):\n        \"\"\"\n        Converts a prefix unary operation into a function call.\n\n        Parameters:\n            operator (str): The operator symbol.\n            operand (str): The operand.\n\n        Returns:\n            (str): The function call string using the operator's function ID.\n        \"\"\"\n        self.logger.debug(\n            f\"Prefix unary operation: operator={operator}, operand={operand}\"\n        )\n        func_id, is_temporary = self.operator_manager.get_operator_function_id(\n            operator, is_unary=True\n        )\n        self.logger.debug(f\"Function ID: {func_id}, Is temporary: {is_temporary}\")\n        if func_id and not is_temporary:\n            result = f\"op_{func_id}({operand})\"\n        else:\n            raise ValueError(\n                f\"Operator '{operator}' is not supported or lacks a function ID.\"\n            )\n        self.logger.debug(f\"Returning prefix unary operation result: {result}\")\n        return result\n\n    @v_args(inline=True)\n    def unary_operation_postfix(self, operand, operator):\n        \"\"\"\n        Converts a postfix unary operation into a function call.\n\n        Parameters:\n            operand (str): The operand.\n            operator (str): The operator symbol.\n\n        Returns:\n            (str): The function call string using the operator's function ID.\n        \"\"\"\n        self.logger.debug(\n            f\"Postfix unary operation: operand={operand}, operator={operator}\"\n        )\n        func_id, is_temporary = self.operator_manager.get_operator_function_id(\n            operator, is_unary=True\n        )\n        self.logger.debug(f\"Function ID: {func_id}, Is temporary: {is_temporary}\")\n        if func_id and not is_temporary:\n            result = f\"op_{func_id}({operand})\"\n        else:\n            raise ValueError(\n                f\"Operator '{operator}' is not supported or lacks a function ID.\"\n            )\n        self.logger.debug(f\"Returning postfix unary operation result: {result}\")\n        return result\n\n    @v_args(inline=True)\n    def grouped_condition(self, condition):\n        \"\"\"\n        Wraps a condition in parentheses.\n\n        Parameters:\n            condition (str): The condition to wrap.\n\n        Returns:\n            (str): The condition wrapped in parentheses.\n        \"\"\"\n        self.logger.debug(f\"Processing grouped condition: {condition}\")\n        result = f\"({condition})\"\n        self.logger.debug(f\"Returning grouped condition result: {result}\")\n        return result\n\n    @v_args(inline=True)\n    def comparison(self, left, condition_operator, right):\n        \"\"\"\n        Converts a comparison expression into a string representation.\n\n        Parameters:\n            left (str): The left operand.\n            condition_operator (str): The comparison operator.\n            right (str): The right operand.\n\n        Returns:\n            (str): The comparison expression as a string.\n        \"\"\"\n        self.logger.debug(\n            f\"Processing comparison: left={left}, operator={condition_operator}, right={right}\"\n        )\n        result = f\"{left} {condition_operator} {right}\"\n        self.logger.debug(f\"Returning comparison result: {result}\")\n        return result\n\n    @v_args(inline=True)\n    def not_condition(self, condition):\n        \"\"\"\n        Wraps the condition with a 'not' operator.\n\n        Parameters:\n            condition (str): The condition to negate.\n\n        Returns:\n            (str): The negated condition as a string.\n        \"\"\"\n        self.logger.debug(f\"Processing 'not' condition: {condition}\")\n        result = f\"not ({condition})\"\n        self.logger.debug(f\"Returning 'not' condition result: {result}\")\n        return result\n\n    @v_args(inline=True)\n    def and_condition(self, left, right):\n        \"\"\"\n        Converts an 'and' condition into a string representation.\n\n        Parameters:\n            left (str): The left operand.\n            right (str): The right operand.\n\n        Returns:\n            (str): The 'and' condition as a string.\n        \"\"\"\n        self.logger.debug(f\"Processing 'and' condition: left={left}, right={right}\")\n        result = f\"{left} and {right}\"\n        self.logger.debug(f\"Returning 'and' condition result: {result}\")\n        return result\n\n    @v_args(inline=True)\n    def or_condition(self, left, right):\n        \"\"\"\n        Converts an 'or' condition into a string representation.\n\n        Parameters:\n            left (str): The left operand.\n            right (str): The right operand.\n\n        Returns:\n            (str): The 'or' condition as a string.\n        \"\"\"\n        self.logger.debug(f\"Processing 'or' condition: left={left}, right={right}\")\n        result = f\"{left} or {right}\"\n        self.logger.debug(f\"Returning 'or' condition result: {result}\")\n        return result\n\n    @v_args(inline=True)\n    def if_branch(self, expr, condition):\n        \"\"\"\n        Converts an 'if' branch into a tuple.\n\n        Parameters:\n            expr (str): The expression for the if branch.\n            condition (str): The condition for the if branch.\n\n        Returns:\n            (tuple): A tuple representing the if branch.\n        \"\"\"\n        self.logger.debug(f\"Processing 'if' branch: expr={expr}, condition={condition}\")\n        result = (\"if_branch\", expr, condition)\n        self.logger.debug(f\"Returning 'if' branch result: {result}\")\n        return result\n\n    @v_args(inline=True)\n    def else_branch(self, expr):\n        \"\"\"\n        Converts an 'else' branch into a tuple.\n\n        Parameters:\n            expr (str): The expression for the else branch.\n\n        Returns:\n            (tuple): A tuple representing the else branch.\n        \"\"\"\n        self.logger.debug(f\"Processing 'else' branch: expr={expr}\")\n        result = (\"else_branch\", expr)\n        self.logger.debug(f\"Returning 'else' branch result: {result}\")\n        return result\n\n    @v_args(inline=True)\n    def unconditional_branch(self, expr):\n        \"\"\"\n        Converts an unconditional branch into a tuple.\n\n        Parameters:\n            expr (str): The expression for the unconditional branch.\n\n        Returns:\n            (tuple): A tuple representing the unconditional branch.\n        \"\"\"\n        self.logger.debug(f\"Processing unconditional branch: expr={expr}\")\n        result = (\"unconditional_branch\", expr)\n        self.logger.debug(f\"Returning unconditional branch result: {result}\")\n        return result\n\n    @v_args(inline=True)\n    def rhs_expr(self, *args):\n        \"\"\"\n        Processes the right-hand side expressions, filtering out semicolons and empty items.\n\n        Parameters:\n            *args: Variadic arguments representing the expressions.\n\n        Returns:\n            (list): The filtered list of right-hand side expressions.\n        \"\"\"\n        self.logger.debug(f\"Processing rhs_expr with args: {args}\")\n        filtered_rhs_expr = [\n            item\n            for item in args\n            if not isinstance(item, Token) or item.type != \"SEMICOLON\" and item\n        ]\n        self.logger.debug(f\"Filtered rhs_expr: {filtered_rhs_expr}\")\n        result = filtered_rhs_expr\n        self.logger.debug(f\"Returning rhs_expr result: {result}\")\n        return result\n\n    def extract_rhs_expr(self, parsed_tree):\n        \"\"\"\n        Extracts the rhs_expr part from the parsed tree.\n\n        Args:\n            parsed_tree (Tree): The root of the parsed syntax tree.\n\n        Returns:\n            (Tree): The subtree corresponding to rhs_expr, or None if not found.\n        \"\"\"\n        self.logger.debug(f\"Extracting rhs_expr from parsed tree.\")\n        for child in parsed_tree.children:\n            if isinstance(child, Tree) and child.data == \"rhs_expr\":\n                return child\n        return None  # Return None if rhs_expr is not found\n\n    def generate_function(self, func_id, func_unary, parsed_definition):\n        \"\"\"\n        Generates and saves the function code from the parsed definition.\n\n        Parameters:\n            func_id (int): The function ID.\n            func_unary (int): Indicates if the function is unary (1) or binary (2).\n            parsed_definition (Tree): The parsed definition tree.\n\n        Returns:\n            (tuple): A tuple containing the compute function definition and the count function definition as strings.\n        \"\"\"\n        rhs_tree = self.extract_rhs_expr(parsed_definition)\n        filtered_rhs_expr = self.transform(rhs_tree)\n\n        func_name = f\"op_{func_id}\"\n        count_func_name = f\"op_count_{func_id}\"\n        if func_unary == 1:\n            params = [\"a\"]\n        elif func_unary == 2:\n            params = [\"a\", \"b\"]\n\n        func_def = f\"def {func_name}({', '.join(params)}):\\n\"\n        count_func_def = f\"def {count_func_name}({', '.join(params)}):\\n\"\n        indent = \"    \"\n\n        if func_unary == 1:\n            nan_check = f\"{indent}if {params[0]} == 'NaN':\\n{indent*2}return 'NaN'\\n\"\n        elif func_unary == 2:\n            nan_check = f\"{indent}if {params[0]} == 'NaN' or {params[1]} == 'NaN':\\n{indent*2}return 'NaN'\\n\"\n\n        func_def += nan_check\n        count_func_def += nan_check\n\n        for _, branch in enumerate(filtered_rhs_expr):\n            branch_type = branch[0]\n            if branch_type == \"if_branch\":\n                _, expr, condition = branch\n\n                condition = add_nan_check_to_conditions(condition)\n\n                #Because of the previous judgement on NaN, all are elif\n                func_def += f\"{indent}elif {condition}:\\n\"\n                count_func_def += f\"{indent}elif {condition}:\\n\"\n\n                if isinstance(expr, int) or expr in [\"a\", \"b\"]:\n                    func_def += f\"{indent*2}return {expr}\\n\"\n                    count_func_def += f\"{indent*2}return 1\\n\"\n                else:\n                    func_def += f\"{indent*2}return {expr}\\n\"\n                    count_expr = expr.replace(\"op_\", \"op_count_\")\n                    count_func_def += f\"{indent*2}return {count_expr}\\n\"\n\n            elif branch_type == \"else_branch\":\n                _, expr = branch\n                func_def += f\"{indent}else:\\n\"\n                count_func_def += f\"{indent}else:\\n\"\n\n                if isinstance(expr, int) or expr in [\"a\", \"b\"]:\n                    func_def += f\"{indent*2}return {expr}\\n\"\n                    count_func_def += f\"{indent*2}return 1\\n\"\n                else:\n                    func_def += f\"{indent*2}return {expr}\\n\"\n                    count_expr = expr.replace(\"op_\", \"op_count_\")\n                    count_func_def += f\"{indent*2}return {count_expr}\\n\"\n\n            elif branch_type == \"unconditional_branch\":\n                _, expr = branch\n                if isinstance(expr, int) or expr in [\"a\", \"b\"]:\n                    func_def += f\"{indent}return {expr}\\n\"\n                    count_func_def += (\n                        f\"{indent}return 1\\n\"\n                    )\n                else:\n                    func_def += f\"{indent}return {expr}\\n\"\n                    count_expr = expr.replace(\"op_\", \"op_count_\")\n                    count_func_def += f\"{indent}return {count_expr}\\n\"\n\n        self.logger.debug(f\"Generated Compute function:\\n{func_def}\")\n        self.logger.debug(f\"Generated Count function:\\n{count_func_def}\")\n\n        return func_def, count_func_def\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_transformer/#opulse.operatorplus.operator_transformer.OperatorTransformer.__init__","title":"<code>__init__(param_config, logger, operator_manager=None)</code>","text":"<p>Initializes the OperatorTransformer instance with given configurations.</p> <p>Parameters:</p> Name Type Description Default <code>param_config</code> <code>ParamConfig</code> <p>Configuration for parameters.</p> required <code>logger</code> <code>LogConfig</code> <p>Logger configuration for logging debug and info messages.</p> required <code>operator_manager</code> <code>OperatorManager</code> <p>Operator manager for handling operators.</p> <code>None</code> Source code in <code>opulse/operatorplus/operator_transformer.py</code> <pre><code>def __init__(\n    self,\n    param_config: ParamConfig,\n    logger: LogConfig,\n    operator_manager: \"OperatorManager\" = None,\n):\n    \"\"\"\n    Initializes the OperatorTransformer instance with given configurations.\n\n    Args:\n       param_config (ParamConfig): Configuration for parameters.\n       logger (LogConfig): Logger configuration for logging debug and info messages.\n       operator_manager (OperatorManager, optional): Operator manager for handling operators.\n    \"\"\"\n    self.param_config = param_config\n    self.logger = logger.get_logger()\n    self.operator_manager = operator_manager\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_transformer/#opulse.operatorplus.operator_transformer.OperatorTransformer.and_condition","title":"<code>and_condition(left, right)</code>","text":"<p>Converts an 'and' condition into a string representation.</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <code>str</code> <p>The left operand.</p> required <code>right</code> <code>str</code> <p>The right operand.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The 'and' condition as a string.</p> Source code in <code>opulse/operatorplus/operator_transformer.py</code> <pre><code>@v_args(inline=True)\ndef and_condition(self, left, right):\n    \"\"\"\n    Converts an 'and' condition into a string representation.\n\n    Parameters:\n        left (str): The left operand.\n        right (str): The right operand.\n\n    Returns:\n        (str): The 'and' condition as a string.\n    \"\"\"\n    self.logger.debug(f\"Processing 'and' condition: left={left}, right={right}\")\n    result = f\"{left} and {right}\"\n    self.logger.debug(f\"Returning 'and' condition result: {result}\")\n    return result\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_transformer/#opulse.operatorplus.operator_transformer.OperatorTransformer.binary_operation","title":"<code>binary_operation(left, operator, right)</code>","text":"<p>Converts a binary operation into a function call.</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <code>str</code> <p>The left operand.</p> required <code>operator</code> <code>str</code> <p>The operator symbol.</p> required <code>right</code> <code>str</code> <p>The right operand.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The function call string using the operator's function ID.</p> Source code in <code>opulse/operatorplus/operator_transformer.py</code> <pre><code>@v_args(inline=True)\ndef binary_operation(self, left, operator, right):\n    \"\"\"\n    Converts a binary operation into a function call.\n\n    Parameters:\n        left (str): The left operand.\n        operator (str): The operator symbol.\n        right (str): The right operand.\n\n    Returns:\n        (str): The function call string using the operator's function ID.\n    \"\"\"\n    self.logger.debug(\n        f\"Binary operation: left={left}, operator={operator}, right={right}\"\n    )\n    func_id, is_temporary = self.operator_manager.get_operator_function_id(\n        operator, is_unary=False\n    )\n    self.logger.debug(f\"Function ID: {func_id}, Is temporary: {is_temporary}\")\n    if func_id and not is_temporary:\n        result = f\"op_{func_id}({left},{right})\"\n    else:\n        raise ValueError(\n            f\"Operator '{operator}' is not supported or lacks a function ID.\"\n        )\n    self.logger.debug(f\"Returning binary operation result: {result}\")\n    return result\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_transformer/#opulse.operatorplus.operator_transformer.OperatorTransformer.comparison","title":"<code>comparison(left, condition_operator, right)</code>","text":"<p>Converts a comparison expression into a string representation.</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <code>str</code> <p>The left operand.</p> required <code>condition_operator</code> <code>str</code> <p>The comparison operator.</p> required <code>right</code> <code>str</code> <p>The right operand.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The comparison expression as a string.</p> Source code in <code>opulse/operatorplus/operator_transformer.py</code> <pre><code>@v_args(inline=True)\ndef comparison(self, left, condition_operator, right):\n    \"\"\"\n    Converts a comparison expression into a string representation.\n\n    Parameters:\n        left (str): The left operand.\n        condition_operator (str): The comparison operator.\n        right (str): The right operand.\n\n    Returns:\n        (str): The comparison expression as a string.\n    \"\"\"\n    self.logger.debug(\n        f\"Processing comparison: left={left}, operator={condition_operator}, right={right}\"\n    )\n    result = f\"{left} {condition_operator} {right}\"\n    self.logger.debug(f\"Returning comparison result: {result}\")\n    return result\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_transformer/#opulse.operatorplus.operator_transformer.OperatorTransformer.else_branch","title":"<code>else_branch(expr)</code>","text":"<p>Converts an 'else' branch into a tuple.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>str</code> <p>The expression for the else branch.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple representing the else branch.</p> Source code in <code>opulse/operatorplus/operator_transformer.py</code> <pre><code>@v_args(inline=True)\ndef else_branch(self, expr):\n    \"\"\"\n    Converts an 'else' branch into a tuple.\n\n    Parameters:\n        expr (str): The expression for the else branch.\n\n    Returns:\n        (tuple): A tuple representing the else branch.\n    \"\"\"\n    self.logger.debug(f\"Processing 'else' branch: expr={expr}\")\n    result = (\"else_branch\", expr)\n    self.logger.debug(f\"Returning 'else' branch result: {result}\")\n    return result\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_transformer/#opulse.operatorplus.operator_transformer.OperatorTransformer.extract_rhs_expr","title":"<code>extract_rhs_expr(parsed_tree)</code>","text":"<p>Extracts the rhs_expr part from the parsed tree.</p> <p>Parameters:</p> Name Type Description Default <code>parsed_tree</code> <code>Tree</code> <p>The root of the parsed syntax tree.</p> required <p>Returns:</p> Type Description <code>Tree</code> <p>The subtree corresponding to rhs_expr, or None if not found.</p> Source code in <code>opulse/operatorplus/operator_transformer.py</code> <pre><code>def extract_rhs_expr(self, parsed_tree):\n    \"\"\"\n    Extracts the rhs_expr part from the parsed tree.\n\n    Args:\n        parsed_tree (Tree): The root of the parsed syntax tree.\n\n    Returns:\n        (Tree): The subtree corresponding to rhs_expr, or None if not found.\n    \"\"\"\n    self.logger.debug(f\"Extracting rhs_expr from parsed tree.\")\n    for child in parsed_tree.children:\n        if isinstance(child, Tree) and child.data == \"rhs_expr\":\n            return child\n    return None  # Return None if rhs_expr is not found\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_transformer/#opulse.operatorplus.operator_transformer.OperatorTransformer.generate_function","title":"<code>generate_function(func_id, func_unary, parsed_definition)</code>","text":"<p>Generates and saves the function code from the parsed definition.</p> <p>Parameters:</p> Name Type Description Default <code>func_id</code> <code>int</code> <p>The function ID.</p> required <code>func_unary</code> <code>int</code> <p>Indicates if the function is unary (1) or binary (2).</p> required <code>parsed_definition</code> <code>Tree</code> <p>The parsed definition tree.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing the compute function definition and the count function definition as strings.</p> Source code in <code>opulse/operatorplus/operator_transformer.py</code> <pre><code>def generate_function(self, func_id, func_unary, parsed_definition):\n    \"\"\"\n    Generates and saves the function code from the parsed definition.\n\n    Parameters:\n        func_id (int): The function ID.\n        func_unary (int): Indicates if the function is unary (1) or binary (2).\n        parsed_definition (Tree): The parsed definition tree.\n\n    Returns:\n        (tuple): A tuple containing the compute function definition and the count function definition as strings.\n    \"\"\"\n    rhs_tree = self.extract_rhs_expr(parsed_definition)\n    filtered_rhs_expr = self.transform(rhs_tree)\n\n    func_name = f\"op_{func_id}\"\n    count_func_name = f\"op_count_{func_id}\"\n    if func_unary == 1:\n        params = [\"a\"]\n    elif func_unary == 2:\n        params = [\"a\", \"b\"]\n\n    func_def = f\"def {func_name}({', '.join(params)}):\\n\"\n    count_func_def = f\"def {count_func_name}({', '.join(params)}):\\n\"\n    indent = \"    \"\n\n    if func_unary == 1:\n        nan_check = f\"{indent}if {params[0]} == 'NaN':\\n{indent*2}return 'NaN'\\n\"\n    elif func_unary == 2:\n        nan_check = f\"{indent}if {params[0]} == 'NaN' or {params[1]} == 'NaN':\\n{indent*2}return 'NaN'\\n\"\n\n    func_def += nan_check\n    count_func_def += nan_check\n\n    for _, branch in enumerate(filtered_rhs_expr):\n        branch_type = branch[0]\n        if branch_type == \"if_branch\":\n            _, expr, condition = branch\n\n            condition = add_nan_check_to_conditions(condition)\n\n            #Because of the previous judgement on NaN, all are elif\n            func_def += f\"{indent}elif {condition}:\\n\"\n            count_func_def += f\"{indent}elif {condition}:\\n\"\n\n            if isinstance(expr, int) or expr in [\"a\", \"b\"]:\n                func_def += f\"{indent*2}return {expr}\\n\"\n                count_func_def += f\"{indent*2}return 1\\n\"\n            else:\n                func_def += f\"{indent*2}return {expr}\\n\"\n                count_expr = expr.replace(\"op_\", \"op_count_\")\n                count_func_def += f\"{indent*2}return {count_expr}\\n\"\n\n        elif branch_type == \"else_branch\":\n            _, expr = branch\n            func_def += f\"{indent}else:\\n\"\n            count_func_def += f\"{indent}else:\\n\"\n\n            if isinstance(expr, int) or expr in [\"a\", \"b\"]:\n                func_def += f\"{indent*2}return {expr}\\n\"\n                count_func_def += f\"{indent*2}return 1\\n\"\n            else:\n                func_def += f\"{indent*2}return {expr}\\n\"\n                count_expr = expr.replace(\"op_\", \"op_count_\")\n                count_func_def += f\"{indent*2}return {count_expr}\\n\"\n\n        elif branch_type == \"unconditional_branch\":\n            _, expr = branch\n            if isinstance(expr, int) or expr in [\"a\", \"b\"]:\n                func_def += f\"{indent}return {expr}\\n\"\n                count_func_def += (\n                    f\"{indent}return 1\\n\"\n                )\n            else:\n                func_def += f\"{indent}return {expr}\\n\"\n                count_expr = expr.replace(\"op_\", \"op_count_\")\n                count_func_def += f\"{indent}return {count_expr}\\n\"\n\n    self.logger.debug(f\"Generated Compute function:\\n{func_def}\")\n    self.logger.debug(f\"Generated Count function:\\n{count_func_def}\")\n\n    return func_def, count_func_def\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_transformer/#opulse.operatorplus.operator_transformer.OperatorTransformer.grouped_condition","title":"<code>grouped_condition(condition)</code>","text":"<p>Wraps a condition in parentheses.</p> <p>Parameters:</p> Name Type Description Default <code>condition</code> <code>str</code> <p>The condition to wrap.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The condition wrapped in parentheses.</p> Source code in <code>opulse/operatorplus/operator_transformer.py</code> <pre><code>@v_args(inline=True)\ndef grouped_condition(self, condition):\n    \"\"\"\n    Wraps a condition in parentheses.\n\n    Parameters:\n        condition (str): The condition to wrap.\n\n    Returns:\n        (str): The condition wrapped in parentheses.\n    \"\"\"\n    self.logger.debug(f\"Processing grouped condition: {condition}\")\n    result = f\"({condition})\"\n    self.logger.debug(f\"Returning grouped condition result: {result}\")\n    return result\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_transformer/#opulse.operatorplus.operator_transformer.OperatorTransformer.if_branch","title":"<code>if_branch(expr, condition)</code>","text":"<p>Converts an 'if' branch into a tuple.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>str</code> <p>The expression for the if branch.</p> required <code>condition</code> <code>str</code> <p>The condition for the if branch.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple representing the if branch.</p> Source code in <code>opulse/operatorplus/operator_transformer.py</code> <pre><code>@v_args(inline=True)\ndef if_branch(self, expr, condition):\n    \"\"\"\n    Converts an 'if' branch into a tuple.\n\n    Parameters:\n        expr (str): The expression for the if branch.\n        condition (str): The condition for the if branch.\n\n    Returns:\n        (tuple): A tuple representing the if branch.\n    \"\"\"\n    self.logger.debug(f\"Processing 'if' branch: expr={expr}, condition={condition}\")\n    result = (\"if_branch\", expr, condition)\n    self.logger.debug(f\"Returning 'if' branch result: {result}\")\n    return result\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_transformer/#opulse.operatorplus.operator_transformer.OperatorTransformer.int_conversion","title":"<code>int_conversion(token)</code>","text":"<p>Converts an INT token to a string.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Token</code> <p>The INT token to convert.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The string representation of the token's value.</p> Source code in <code>opulse/operatorplus/operator_transformer.py</code> <pre><code>@v_args(inline=True)\ndef int_conversion(self, token):\n    \"\"\"\n    Converts an INT token to a string.\n\n    Parameters:\n        token (Token): The INT token to convert.\n\n    Returns:\n        (str): The string representation of the token's value.\n    \"\"\"\n    self.logger.debug(f\"Converting INT token: {token}\")\n    result = str(token.value)\n    self.logger.debug(f\"Returning INT conversion result: {result}\")\n    return result\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_transformer/#opulse.operatorplus.operator_transformer.OperatorTransformer.no_solution","title":"<code>no_solution(token)</code>","text":"<p>Handles the NO_SOLUTION rule, returns the string 'NaN'.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Token</code> <p>The token representing NO_SOLUTION.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The string '\"NaN\"'.</p> Source code in <code>opulse/operatorplus/operator_transformer.py</code> <pre><code>@v_args(inline=True)\ndef no_solution(self, token):\n    \"\"\"\n    Handles the NO_SOLUTION rule, returns the string 'NaN'.\n\n    Parameters:\n        token (Token): The token representing NO_SOLUTION.\n\n    Returns:\n        (str): The string '\"NaN\"'.\n    \"\"\"\n    self.logger.debug(f\"Processing NO_SOLUTION: {token}\")\n    result = '\"NaN\"'  # Ensure to return 'NaN' as a quoted string.\n    self.logger.debug(f\"Returning NO_SOLUTION result: {result}\")\n    return result\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_transformer/#opulse.operatorplus.operator_transformer.OperatorTransformer.not_condition","title":"<code>not_condition(condition)</code>","text":"<p>Wraps the condition with a 'not' operator.</p> <p>Parameters:</p> Name Type Description Default <code>condition</code> <code>str</code> <p>The condition to negate.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The negated condition as a string.</p> Source code in <code>opulse/operatorplus/operator_transformer.py</code> <pre><code>@v_args(inline=True)\ndef not_condition(self, condition):\n    \"\"\"\n    Wraps the condition with a 'not' operator.\n\n    Parameters:\n        condition (str): The condition to negate.\n\n    Returns:\n        (str): The negated condition as a string.\n    \"\"\"\n    self.logger.debug(f\"Processing 'not' condition: {condition}\")\n    result = f\"not ({condition})\"\n    self.logger.debug(f\"Returning 'not' condition result: {result}\")\n    return result\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_transformer/#opulse.operatorplus.operator_transformer.OperatorTransformer.or_condition","title":"<code>or_condition(left, right)</code>","text":"<p>Converts an 'or' condition into a string representation.</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <code>str</code> <p>The left operand.</p> required <code>right</code> <code>str</code> <p>The right operand.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The 'or' condition as a string.</p> Source code in <code>opulse/operatorplus/operator_transformer.py</code> <pre><code>@v_args(inline=True)\ndef or_condition(self, left, right):\n    \"\"\"\n    Converts an 'or' condition into a string representation.\n\n    Parameters:\n        left (str): The left operand.\n        right (str): The right operand.\n\n    Returns:\n        (str): The 'or' condition as a string.\n    \"\"\"\n    self.logger.debug(f\"Processing 'or' condition: left={left}, right={right}\")\n    result = f\"{left} or {right}\"\n    self.logger.debug(f\"Returning 'or' condition result: {result}\")\n    return result\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_transformer/#opulse.operatorplus.operator_transformer.OperatorTransformer.rhs_expr","title":"<code>rhs_expr(*args)</code>","text":"<p>Processes the right-hand side expressions, filtering out semicolons and empty items.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Variadic arguments representing the expressions.</p> <code>()</code> <p>Returns:</p> Type Description <code>list</code> <p>The filtered list of right-hand side expressions.</p> Source code in <code>opulse/operatorplus/operator_transformer.py</code> <pre><code>@v_args(inline=True)\ndef rhs_expr(self, *args):\n    \"\"\"\n    Processes the right-hand side expressions, filtering out semicolons and empty items.\n\n    Parameters:\n        *args: Variadic arguments representing the expressions.\n\n    Returns:\n        (list): The filtered list of right-hand side expressions.\n    \"\"\"\n    self.logger.debug(f\"Processing rhs_expr with args: {args}\")\n    filtered_rhs_expr = [\n        item\n        for item in args\n        if not isinstance(item, Token) or item.type != \"SEMICOLON\" and item\n    ]\n    self.logger.debug(f\"Filtered rhs_expr: {filtered_rhs_expr}\")\n    result = filtered_rhs_expr\n    self.logger.debug(f\"Returning rhs_expr result: {result}\")\n    return result\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_transformer/#opulse.operatorplus.operator_transformer.OperatorTransformer.unary_operation_postfix","title":"<code>unary_operation_postfix(operand, operator)</code>","text":"<p>Converts a postfix unary operation into a function call.</p> <p>Parameters:</p> Name Type Description Default <code>operand</code> <code>str</code> <p>The operand.</p> required <code>operator</code> <code>str</code> <p>The operator symbol.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The function call string using the operator's function ID.</p> Source code in <code>opulse/operatorplus/operator_transformer.py</code> <pre><code>@v_args(inline=True)\ndef unary_operation_postfix(self, operand, operator):\n    \"\"\"\n    Converts a postfix unary operation into a function call.\n\n    Parameters:\n        operand (str): The operand.\n        operator (str): The operator symbol.\n\n    Returns:\n        (str): The function call string using the operator's function ID.\n    \"\"\"\n    self.logger.debug(\n        f\"Postfix unary operation: operand={operand}, operator={operator}\"\n    )\n    func_id, is_temporary = self.operator_manager.get_operator_function_id(\n        operator, is_unary=True\n    )\n    self.logger.debug(f\"Function ID: {func_id}, Is temporary: {is_temporary}\")\n    if func_id and not is_temporary:\n        result = f\"op_{func_id}({operand})\"\n    else:\n        raise ValueError(\n            f\"Operator '{operator}' is not supported or lacks a function ID.\"\n        )\n    self.logger.debug(f\"Returning postfix unary operation result: {result}\")\n    return result\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_transformer/#opulse.operatorplus.operator_transformer.OperatorTransformer.unary_operation_prefix","title":"<code>unary_operation_prefix(operator, operand)</code>","text":"<p>Converts a prefix unary operation into a function call.</p> <p>Parameters:</p> Name Type Description Default <code>operator</code> <code>str</code> <p>The operator symbol.</p> required <code>operand</code> <code>str</code> <p>The operand.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The function call string using the operator's function ID.</p> Source code in <code>opulse/operatorplus/operator_transformer.py</code> <pre><code>@v_args(inline=True)\ndef unary_operation_prefix(self, operator, operand):\n    \"\"\"\n    Converts a prefix unary operation into a function call.\n\n    Parameters:\n        operator (str): The operator symbol.\n        operand (str): The operand.\n\n    Returns:\n        (str): The function call string using the operator's function ID.\n    \"\"\"\n    self.logger.debug(\n        f\"Prefix unary operation: operator={operator}, operand={operand}\"\n    )\n    func_id, is_temporary = self.operator_manager.get_operator_function_id(\n        operator, is_unary=True\n    )\n    self.logger.debug(f\"Function ID: {func_id}, Is temporary: {is_temporary}\")\n    if func_id and not is_temporary:\n        result = f\"op_{func_id}({operand})\"\n    else:\n        raise ValueError(\n            f\"Operator '{operator}' is not supported or lacks a function ID.\"\n        )\n    self.logger.debug(f\"Returning prefix unary operation result: {result}\")\n    return result\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_transformer/#opulse.operatorplus.operator_transformer.OperatorTransformer.unconditional_branch","title":"<code>unconditional_branch(expr)</code>","text":"<p>Converts an unconditional branch into a tuple.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>str</code> <p>The expression for the unconditional branch.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple representing the unconditional branch.</p> Source code in <code>opulse/operatorplus/operator_transformer.py</code> <pre><code>@v_args(inline=True)\ndef unconditional_branch(self, expr):\n    \"\"\"\n    Converts an unconditional branch into a tuple.\n\n    Parameters:\n        expr (str): The expression for the unconditional branch.\n\n    Returns:\n        (tuple): A tuple representing the unconditional branch.\n    \"\"\"\n    self.logger.debug(f\"Processing unconditional branch: expr={expr}\")\n    result = (\"unconditional_branch\", expr)\n    self.logger.debug(f\"Returning unconditional branch result: {result}\")\n    return result\n</code></pre>"},{"location":"Core%20API/operatorplus/operator_transformer/#opulse.operatorplus.operator_transformer.OperatorTransformer.variable_conversion","title":"<code>variable_conversion(token)</code>","text":"<p>Converts a VARIABLE token to its string value.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Token</code> <p>The VARIABLE token to convert.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The string representation of the token's value.</p> Source code in <code>opulse/operatorplus/operator_transformer.py</code> <pre><code>@v_args(inline=True)\ndef variable_conversion(self, token):\n    \"\"\"\n    Converts a VARIABLE token to its string value.\n\n    Parameters:\n        token (Token): The VARIABLE token to convert.\n\n    Returns:\n        (str): The string representation of the token's value.\n    \"\"\"\n    self.logger.debug(f\"Converting VARIABLE token: {token}\")\n    result = token.value  # Assumes it's a simple variable name like 'a' or 'b'.\n    self.logger.debug(f\"Returning VARIABLE conversion result: {result}\")\n    return result\n</code></pre>"}]}